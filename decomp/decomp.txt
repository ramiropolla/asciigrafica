/* VV */
#define FLAGS_1           0x10
#define FLAGS_1_SHORTBEEP (1<<2) /* 0x04 */

#define DIPSW1            0x31
#define DIPSW2            0x32
#define VOLTAGE_STATUS    0x41
#define UNDER_VOLTAGE_1   (1<<0) /* 0x01 */
#define UNDER_VOLTAGE_2   (1<<1) /* 0x02 */

#define ADDRESS_93C06     0x42
#define CHECKSUM_93c06    0x56

uint16_t data_buffer_wptr; /**< 0x9911 */
uint16_t data_buffer_rptr; /**< 0x9913 */
uint16_t data_buffer_size; /**< 0x9915 */
uint8_t *cr_step_array;    /**< 0x991D */
uint8_t *tm1_array;        /**< 0x991F */

/* VV[0x00] */
#define CR_IS_HOME       0x02
#define CR_HALF_STEP     0x20
#define CR_SEEK_HOME     0x80 /* maybe ? */

/* VV[0x03] */
#define DATA_DUMP_MODE   0x04
#define SELF_TEST_MODE   0x02

/* VV[0x04] */
#define PC_SEL_18        0x01
#define PC_SEL_17        0x02
#define PC_SEL_16        0x04
#define GRAPHICS_1       0x10
#define GRAPHICS_2       0x20
#define SLASHED_ZERO     0x40

/* VV[0x0f] */
#define CR_SHOULD_STOP   0x01

/* VV[0x11] */
#define DATA_BUFFER_FULL 0x02
#define DONT_READ_DATA   0x40
#define COMM_SERIAL      0x80

uint8_t  print_this_char;  /**< 0x9815 (VV[0x15]) */

uint8_t  jmp_insn_timer1;  /**< 0x9817 (VV[0x17]) */
uint16_t timer1_func;      /**< 0x9818 (VV[0x18]) */
uint8_t  jmp_insn_etimer;  /**< 0x981A (VV[0x1A]) */
uint16_t etimer_func;      /**< 0x981B (VV[0x1B]) */
uint8_t  cr_step_ops;      /**< 0x981D (VV[0x1D]) */
uint8_t  cr_countdown;     /**< 0x981E (VV[0x1E]) */ /* deceleration */
uint8_t  tm1_array_choice; /**< 0x981F (VV[0x1F]) */

uint8_t  char_field_1;     /**< 0x983F (VV[0x3F]) */

uint8_t  unused_rld_trick; /**< 0xFF89 */

/* [0xC004] */
#define C004_0           (1<<0)
#define C004_1           (1<<1)
#define C004_2           (1<<2)
#define C004_3           (1<<3)
#define C004_4           (1<<4)
#define C004_5           (1<<5)
#define C004_6           (1<<6)
#define C004_7           (1<<7) /* seems like some kind of reset */

0000: goto _start;                     /* reset */
0004: goto irq_nmi;                    /* IRQ 0 */ /* INTNMI */
0008: exx();                           /* IRQ 1 */ /* INTFT0, INTFT1 */
0009: exa();
000A: goto jmp_insn_timer1;
0010: 00                 NOP           /* IRQ 2 */
0018: exx();                           /* IRQ 3 */
0019: exa();
001A: goto jmp_insn_etimer;
0020: 00                 NOP           /* IRQ 4 */
0028: goto irq_serial;                 /* IRQ 5 */ /* INTSR, INTST */ /* serial */

002B: void delay(C ms){}
0041: [HL]--; return;

/* 0050 */
int inv_CALB(uint16_t B)
{
	return !(*B)();
}

0060: 00                 NOP          /* IRQ 6 */

0080: 002B /* DONE */ delay(C ms);
0082: 1057 /* DONE */ one_short_beep();
0084: 1325 /* DONE */ func_1325();
0086: 14ec /* DONE */ func_14EC(); /* always returns 0 */
0088: 00ca /* DONE */ EA = mul24(EA, A);
008A: 170F /* DONE */ func_170F(); /* always returns 0 */
008C: 16f7
008E: 0feb /* DONE */ sw_form_feed();
0090: 0f01 /* DONE */ sw_online_wait(); /* always returns 0 */
0092: 10A1 /* DONE */ { [0xC004] |= A; }
0094: 109B /* DONE */ { [0xC004] &= A; }
0096: 1b05 /* DONE */ func_1B05(); /* always returns 0 */
0098: 1c93 /* DONE */ func_1C93();
009A: 2089 /* DONE */ check_gate_array_input(); /* always returns 0 */
009C: 2116
009E: 21F3
00A0: 2E3A sensor_paper_end_debounced();
00A2: 313F /* DONE */ func_313F(); /* always returns 0 */
00A4: 78D2
00A6: 7BA4 /* DONE */ main_loop_1(); /* always returns 0 */
00A8: 7B4D /* DONE */ cr_step(); /* always returns 0 */
00AA: 798D /* DONE */ start_moving_cr(); /* always returns 0 */
00AC: 7B95 /* DONE */ sensor_home_position();
00AE: 1680
00B0: 1B02 /* DONE */ func_1B02(); /* always returns 0 */
00B2: 0050 /* DONE */ inv_CALB(B); /* inverts return of CALB */
00B4: 242B /* DONE */ { if (D > 0x97) D = 0x90; if (D < 0x90) D = 0x97; }
00B6: 28F4 /* DONE */ func_28F4();
00B8: 05A5 /* DONE */ { memset(EA, 0x00, B*255+C); A = 0x00; }
00BA: 216F /* DONE */ func_216F(); /* always returns 0 */
00BC: 1334 /* DONE */ func_1334(); /* always returns 0 */
00BE: 0041 /* DONE */ { [HL]--; }

/* bitmask for bit n, 0 = 00000001, 1 = 00000010, etc */
/* always returns 0 */
/* 00C0 */
uint8_t bitmask(uint8_t A)
{
	B = 0x00;
	carry = 1;
	do {
		B = (B << 1) | carry;
		carry = 0;
	} while (A--);
	A = B;
	return A;
}

/* 00CA */
uint16_t mul24(uint16_t EA, uint8_t A)
{
	/* uses EA, BC, and A */
	uint8_t h = in16 >> 8;
	uint8_t l = in16 & 0xff;
	uint16_t mh = (uint16_t) in8 * h;
	uint16_t ml = (uint16_t) in8 * l;
	uint16_t r = 0;
	if (mh & 0xff00) {
		/* check is wrong, we don't care */
		carry = 1;
	} else {
		r =   mh;
		r <<= 8;
		r +=  ml;
	}
	return r; /* EA */
}

int skit(int interrupt)
{
	int ret = (IRR & interrupt);
	IRR &= ~interrupt;
	return ret;
}

#if 0
Epson LX-800 Technical Manual.pdf

When the printer is initialized, the following operations are performed:
a. Seek to carriage home position.
b. Set to ON-LINE mode.
c. Clear the all buffers.
d. Set the line spacing to 1/6 inches.
e. Set the page length to 11 or 12 inches, according to the DIP switch.
f. Clear all vertical tab positions.
g. Set the horizontal tab position to every 8 columns.
i. Set the print mode according to the DIP switches.
#endif

void _noreturn _start()
{
	/* 1>>> Clears all port outputs. Executes the program from address OH. */
	/* 2>>> Sets up the I/O ports. Initializes the CR and PF motors. */
	/* 3>>> Clears the memory. Sends the ACK signal to the host computer via the interface. */
	/* 4>>> Detects the HOME signal. Outputs motor phase data. */
	/* 5>>> Initializes the gate array. (Outputs the instructions to the gate array.) */
	/* 6>>> Reads the DIP switch settings on the optional interface board if the board is installed. */
	/* 7>>> Checks whether the paper is set or not. Sends the result to the gate array. */
	/* 8>>> Enters the interface waiting state (main routine for data processing). */
	V     = 0xff;
	SP    = 0x0000; /* set stack pointer to internal ram */
	MM    = 0x0f; /* 64k EPROM | Internal RAM Access */
	PORTA = b00111000;
	MA    = b11000111; /* 0 = output; 1 = input */
	MB    = b11111111; /* 0 = output; 1 = input */
	EOM   = b10011001; /* to set LVx, output LVx */
	MCC   = b11001011; /* 0 = port mode; 1 = control mode; CO1 output, CO0 output, TI Input, RxD, TxD */
	PORTC = b00000000;
	MC    = b00001010; /* 0 = output; 1 = input */

	/* wait for input voltage to be above 24V (Epson LX-800 Technical Manual.pdf, page 44) */
	B = 0x02; /* 0000 0010 */
	do {
		C = 0xff;
		ANM = 0x08; /* scan mode, AN4 - AN7, more than 9MHz */
		while (!skit(FAD) || C--); /* wait for 0x100 AD conversions */

		A = CR1;
		if (!(B & 0x02)) /* 0000 0010 */
			break;
		if (A >= 0xCA)
			B = 0xfd; /* 1111 1101 */
	} while (1);

	if (A < 0xCA || skit(NMI))
		reset();

	[0xC004] = C004_7 | C004_0; /* 1000 0001 */
	memset(0xff00, 0xFF, 0x100);
	memset(0xff00, 0x00, 0x100);
	if ([0xffff] != 0x00)
		beep_endlessly(); /* HANG */

	/* 3>>> Clears the memory. Sends the ACK signal to the host computer via the interface. */
	reset_ram(0xff);
	reset_ram(0x00);

	[9841] = 0x01;
	SP  = 0xa000; /* set stack pointer now that we know the ram is ok */
	VV  = 0x98xx;
	VV' = 0x98xx;
	clear_interrupt(F2); /* ONLINE BUTTON */
	enable_interrupts();
	read_dipsw_to_ram();

	/* 0165 */
	MB  = b11111101; /* 0 = output; 1 = input */ /* 93c06.DI = input */

	read_all_93c06(); /* always returns 0 */

	jmp_insn_timer1 = 0x54; /* JMP instruction */
	jmp_insn_etimer = 0x54; /* JMP instruction */

	timer1_reset(); /* always returns 0 */

	VV[VOLTAGE_STATUS] &= ~UNDER_VOLTAGE_1; /* 1111 1110 */

/* 017A */
	check_test_switches(); /* always returns 0 */
/* 017D */
	configure_serial(); /* always returns 0 */
/* 0180 */
	reset_data_buffer(); /* always returns 0 */
/* 0183 */
	reset_highmem(); /* always returns 0 */

	VV[0x4f] &= 0xf7; /* 1111 0111 */
	VV[0x4f] |= 0x40; /* 0100 0000 */

/* 018c */
	func_77b1(); /* always returns 0 */
	func_2AFA(); /* always returns 0 */
/* 0192 */
	clear_0xff00_0xff48(); /* always returns 0 */
0195:
	func_216F(); /* always returns 0 */
	if (VV[0x4f] & 0x08) [0x993D] = 0x4C80;
	else                 [0x993D] = 0x2D00;
/* 01a2 */
	func_2B5A(); /* always returns 0 */
/* 01a5 */
	func_10A8(); /* always returns 0 */
/* 01a8 */
	func_0233(); /* always returns 0 */

/* 01ab */
	if (!(VV[0x14] & 0x20)) {
/* 01af */
		func_0F5B(); /* always returns 0 */ /* DEBUG stuck here 1 */
		if (VV[0x03] & SELF_TEST_MODE) goto 0350;
		if (VV[0x03] & DATA_DUMP_MODE) goto 0392;
		if (VV[0x14] & 0x04) goto 043E;
	}

	/* 8>>> Enters the interface waiting state (main routine for data processing). */
	while (1) {
		func_01CF(); /* always returns 0 */
		if (func_1338())
			func_05CD(); /* always returns 0 */
	}
}

/* always returns 0 */
/* 01CF */
void func_01CF()
{
	do {
		40 A2 0E           CALL    $0EA2
		check_gate_array_input(); /* always returns 0 */
	} while (!func_2127());
	return 0;
}

/* 01D8 */
void read_dipsw_to_ram()
{
	uint16_t dip;
	do {
		dip = read_dipsw();
	} while (dip != read_dipsw());
	if (!(SW2 & COMM_SERIAL))
		VV[0x11] |= COMM_SERIAL;
	VV[DIPSW1] = SW1;
	VV[DIPSW2] = SW2 & 0x7f;
}

/* C = SW1, B = SW2 */
/* 01F1 */
uint16_t read_dipsw(void)
{
	C = PB; /* DIP SW1 */
	B = 0;
	wait_for_ADC(0x00); /* scan mode, AN0 - AN3, more than 9MHz */
	if (CR0 & 0x80)	B |= 0x01;	/* DIP SW2.1 */
	if (CR1 & 0x80)	B |= 0x02;	/* DIP SW2.2 */
	if (CR2 & 0x80)	B |= 0x04;	/* DIP SW2.3 */
	if (CR3 & 0x80)	B |= 0x08;	/* DIP SW2.4 */
	wait_for_ADC(0x08); /* scan mode, AN4 - AN7, more than 9MHz */
	if (CR0 & 0x80)	B |= 0x10; /* PARPORT bar{SLCT IN} */
	if (CR3 & 0x80)	B |= 0x80; /* extension, Parallel/Serial */
}

/* 022B */
void wait_for_ADC(uint8_t A)
{
	ANM = A;
	while (!(IIR & FAD));
	return 0;
}

/* always returns 0 */
/* 0233 */
void func_0233()
{
	uint8_t dipsw1 = VV[DIPSW1];
	uint8_t dipsw2;

	if (!(dipsw1 & 0x01)) {
		/* 12 cpi */
		func_1510(); /* always returns 0 */
	}
	if (!(dipsw1 & 0x02)) {
		/* shape of zero */
		VV[0x04] |= SLASHED_ZERO; /* 0100 0000 */
	}
	/* page length */
	if (!(dipsw1 & 0x08)) {
		if (dipsw1 & 0x04) HL = 0x072C; /*  8.5" */
		else          HL = 0x09D8; /* 11.7" */
	} else {
		if (dipsw1 & 0x04) HL = 0x0948; /* 11"   */
		else          HL = 0x0A20; /* 12"   */
	}
	[0x992D] = HL;
	[0x9931] = HL;
	if (dipsw1 & 0x10) {
		/* italics mode */
		VV[0x04] &= 0xf8; /* 1111 1000 */
		if (dipsw1 & 0x80) VV[0x0c] |= 0x01;
		if (dipsw1 & 0x40) VV[0x0c] |= 0x02;
		if (dipsw1 & 0x20) VV[0x0c] |= 0x04;
	} else {
		/* graphics mode */
		VV[0x04] |= GRAPHICS_1 | GRAPHICS_2; /* 0011 0000 */
		if (dipsw1 & 0x80) VV[0x04] |= PC_SEL_18;
		if (dipsw1 & 0x40) VV[0x04] |= PC_SEL_17;
		if (dipsw1 & 0x20) VV[0x04] |= PC_SEL_16;
		VV[0x0C] = 0x00;
	}

	dipsw2 = VV[DIPSW2];
	if (!(dipsw2 & 0x01)) VV[0x14] |= 0x01;
	VV[0x02] &= 0xdf;
	if (!(dipsw2 & 0x02)) VV[0x02] |= 0x20;
	EA = HL;
	B = 0x00;
	if (!(dipsw2 & 0x04)) B = 0xD8;
	EA -= B;
	HL = EA;
	[0x992F] = HL;
	if (!(dipsw2 & 0x08))	VV[0x02] |= 0x80;
	if (dipsw2 & 0x10)
		VV[0x02] |= 0x0c;
	[0x9806] = 0x10;
	if (VV[0x4F] & 0x04)
		func_14F8(); /* always returns 0 */
	func_152B(); /* always returns 0 */
	58 4F              BIT     0,VV:4F
	func_152F(); /* always returns 0 */
	59 4F              BIT     1,VV:4F
	goto 15CD;
	goto 15C9;
}

/* always returns 0 */
/* 02CC */
void check_test_switches(void)
{
	if (sw_line_feed()) {
		if (sw_form_feed()) {
			VV[0x03] |= DATA_DUMP_MODE; /* 0000 0010 */
			one_short_beep(); /* always returns 0 */
			return 0;
		}
		if (sw_load_eject()) {
			func_0309(); /* always returns 0 */
			one_short_beep(); /* always returns 0 */
			return 0;
		}
		VV[0x4F] &= 0xFE; /* 1111 1110 */
		VV[0x03] |= SELF_TEST_MODE; /* 0000 0010 */
		VV[0x11] |= DONT_READ_DATA; /* 0100 0000 */
		one_short_beep(); /* always returns 0 */
		return 0;
	}
	if (sw_form_feed()) {
		if (sw_load_eject()) {
			clear_93c06_partially(); /* always returns 0 */
			wait_for_button(); /* always returns 0 */
			return 0;
		}
		VV[0x4F] |= 0x01; /* 0000 0001 */
		VV[0x03] |= SELF_TEST_MODE; /* 0000 0010 */
		VV[0x11] |= DONT_READ_DATA; /* 0100 0000 */
		one_short_beep(); /* always returns 0 */
		return 0;
	}
	if (sw_load_eject()) {
		wait_for_button(); /* always returns 0 */
		return 0;
	}
	return 0;
}

/* always returns 0 */
/* 0309 */
void func_0309(void)
{
	uint16_t counter = 0x0000;

	beep_x_y(1, 2, 1); /* 1054 */
	wait_for_button(); /* always returns 0 */

	do {
		if (++counter == 0xFF00)
			return 0;
	} while (!sw_form_feed());
	one_short_beep(); /* always returns 0 */
	wait_for_button(); /* always returns 0 */
	do {
		if (++counter == 0xFF00)
			return 0;
	} while (!sw_line_feed());
	one_short_beep(); /* always returns 0 */
	wait_for_button(); /* always returns 0 */
	do {
		if (++counter == 0xFF00)
			return 0;
	} while (!sw_load_eject());
	one_short_beep(); /* always returns 0 */
	wait_for_button(); /* always returns 0 */
	do {
		if (++counter == 0xFF00)
			return 0;
	} while (!sw_form_feed());
	VV[0x14] |= 0x04;
	return 0;
}

0350:
	40 B9 0D           CALL    $0DB9
	HL = 038B;
	40 F4 08           CALL    $08F4
	40 82 2B           CALL    $2B82
	wait_for_button(); /* always returns 0 */
	func_090A(); /* always returns 0 */
	A = 0x20;
	VV[0x28] = A;
	while (42) {
		push(VA);
		40 A2 0E           CALL    $0EA2
		VA = pop();
		VV[0x16] = A;
		print_this_char = A;
		func_05E4(); /* always returns 0 */
		if (!func_08B1()) {
			86                 CALT    ($008C)
			A = VV[0x28];
			func_0434(); /* always returns 0 */
			VV[0x28] = A;
		} else {
			func_221B(); /* always returns 0 */
			A = VV[0x16];
			func_0434(); /* always returns 0 */
		}
	}

038B: DW: 50 53 32 34 31 34 00
          "PS2414"

0392:
	func_152F(); /* always returns 0 */
	func_14FC(); /* always returns 0 */
	HL = 0403;
	40 F4 08           CALL    $08F4
	40 82 2B           CALL    $2B82
	wait_for_button(); /* always returns 0 */
	BC = 0000;
	while (42) {
		push(BC);
		clear_80_spaces(); /* always returns 0 */
		BC = pop();
03AC:
		push(BC);
		func_01CF(); /* always returns 0 */
		BC = pop();
		EA = [0x000F];
		EA &= BC;
		DE = EA;
		EA = [0xFF06];
		EA += DE;
		EA += DE;
		EA += DE;
		DE = EA;
		push(VA);
		printf_02x_rld(A);
		VA = pop();
		EA = [0x000F];
		EA &= BC;
		DE = EA;
		EA = [0xFF37];
		EA += DE;
		DE = EA;
		push(BC);
		B = A;
		B &= 0x7f;
		if (B < 0x20 || B == 0x7F)
			A = '.';
		[DE] = A;
		BC = pop();
		if (VV[0x03] & 0x01)
			goto 03F3;
		DE = 0xFF00;
		printf_02x_rld(B);
		printf_02x_rld(C);
		VV[0x03] |= 0x01;
03F3:
		BC++;
		74 5B 0F           OFFI    C,$0F
		goto 03AC
		push(BC);
		HL = 0xFF00;
		40 F4 08           CALL    $08F4
		BC = pop();
	}

0403: DW: 44 61 74 61 20 44 75 6D 70 20 4D 6F 64 65 00
          "Data Dump Mode"

/* always returns 1 */
/* 0412 */
int func_0412(void)
{
	HL = 0xFF00;
	func_08FE(); /* always returns 0 */
	clear_80_spaces(); /* always returns 0 */
	func_1B05(); /* always returns 0 */
	func_1707(); /* always returns 0 */
	return 1;
}
/* always returns 0 */
/* 0420 */
void printf_02x_rld(uint8_t A)
{
	/* another implementation of printf_02x using a clever RLD trick */
	printf_02x(A);
	return 0;
}
/* always returns 0 */
/* 0434 */
void func_0434(void)
{
	A++;
	if (A == 0x7f)
		A = 0xA0;
	if (A == 0xff)
		A = ' ';
	return 0;
}

043E:
	beep_x_y(1, 2, 1); /* 1054 */
	40 D8 31           CALL    $31D8 /* returns int */
	40 CC 04           CALL    $04CC
	func_152B(); /* always returns 0 */
	40 C9 15           CALL    $15C9
	func_14FC(); /* always returns 0 */
	func_1514(); /* always returns 0 */
	VV[0x46] = 0x04;
	goto 046F
0457:
	65 46 02           NEIW    VV:46,$02
	VV[0x46] = 0x01;
	65 46 01           NEIW    VV:46,$01
	goto 0465
	func_152F(); /* always returns 0 */
	goto 046B
0465:
	func_152B(); /* always returns 0 */
	40 C9 15           CALL    $15C9
046B:
	BC = 0x8288;
	func_313F(); /* always returns 0 */
046F:
	40 D6 04           CALL    $04D6
	BC = 0x0288;
	func_313F(); /* always returns 0 */
0476:
	48 64              SKNIT   F2 /* ONLINE BUTTON */
	goto 0487
	if (!sw_load_eject())
		goto 047E;
	goto 049A
047E:
	if (!sw_line_feed())
		goto 0484;
	goto 04A9
0484:
	if (!sw_form_feed())
		goto 0476;
	goto 046B
0487:
	wait_for_button(); /* always returns 0 */
	30 46              DCRW    VV:46
	goto 0457
	VV[0x14] &= 0xfb; /* 1111 1011 */
	killall(); /* always returns 0 */
	write_all_93c06(); /* always returns 0 */
	reset();
	one_short_beep(); /* always returns 0 */
	wait_for_button(); /* always returns 0 */
	40 B8 04           CALL    $04B8
	37 FF              LTI     A,$FF
	goto 0476
	41                 INR     A
	3B                 STAX    (HL)
	goto 0476
04A9:
	one_short_beep(); /* always returns 0 */
	wait_for_button(); /* always returns 0 */
	40 B8 04           CALL    $04B8
	27 00              GTI     A,$00
	goto 0476
	51                 DCR     A
	3B                 STAX    (HL)
	goto 0476
04B8:
	A = VV[0x46];
	EA = [0x9850];
	EA += A;
	HL = EA;
	A = [HL];
	return 0;

04CC:
	EA -= BC;
	BC = EA;
	40 88 2B           CALL    $2B88
	func_32B9(); /* always returns 0 */
	return 0;

04D6:
	VV[0x2C] = 0x24;
	if (VV[0x46] == 0x04) goto 04F2;
	if (VV[0x46] == 0x03) goto 04EF;
	if (VV[0x46] == 0x01) goto 04EC;
	if (VV[0x46] != 0x00) return 0;
	HL = 0x058A;
04EC:
	HL = 0x0578;
04EF:
	HL = 0x0565;
04F2:
	HL = 0x0553;
	40 9C 05           CALL    $059C
	A = [0x0D21[VV[0x46]]];
	B = A;
	40 B8 04           CALL    $04B8
	60 B2              SUBNB   A,B
	int borrow = (A >= B);
	A -= B;
	if (!borrow)
		goto 0503;
	goto 0511
0503:
	48 3A              NEGA    
	67 00              NEI     A,$00
	goto 0511
	push(VA);
	print_this_char = '-';
	func_05CD(); /* always returns 0 */
	VA = pop();
0511:
	EA = byte_to_char(A);
	print_this_char = EAL;
	push(EA);
	func_05CD(); /* always returns 0 */
	EA = pop();
	print_this_char = EAH;
	func_05CD(); /* always returns 0 */
	print_this_char = 'H';
	func_05CD(); /* always returns 0 */
	40 4C 05           CALL    $054C
	86                 CALT    ($008C)
	VV[0x2C] = 0x15;
	VV[0x45] = 0x03;
0533:
	print_this_char = 'H';
	func_05E4(); /* always returns 0 */
	if (!func_08B1())
		goto 0541;
	func_221B(); /* always returns 0 */
	goto 0533
0541:
	40 4C 05           CALL    $054C
	86                 CALT    ($008C)
	30 45              DCRW    VV:45
	goto 0533
	VV[0x2C] = 0x24;
	return 0;

054C:
	25 46 02           GTIW    VV:46,$02
	VV[0x06] &= 0xef;
	return 0;

0553: DW: 4E 4C 51 20 20 20 48 20 2F 41 64 6A 75 73 74 3D 20 00
          "NLQ   H /Adjust= "
0565: DW: 44 72 61 66 74 20 48 20 2F 41 64 6A 75 73 74 3D 20 00 00
          "Draft H /Adjust= "
0578: DW: 4E 4C 51 20 20 20 4C 20 2F 41 64 6A 75 73 74 3D 20 00
          "NLQ   L /Adjust= "
058A: DW: 44 72 61 66 74 20 4C 20 2F 41 64 6A 75 73 74 3D 20 00
          "Draft L /Adjust= "

059C:
	push(HL);
	40 A5 0E           CALL    $0EA5
	HL = pop();
	func_08FE(); /* always returns 0 */
	return 0;

05A5: A = 0x00;
05A7: memset(EA, A, B*255+C); A = A;

/* 05B3, 05B5 */
void reset_ram(uint8_t c)
{
	uint8_t last;
	memset(0x9800, c, 0x2000);
	A = [0xb7ff];
	if (A != C) { /* C is 0xff */
		killall(); /* always returns 0 */
		beep_x_y(4, 2, 0); /* 1044 */
		while(1); /* HANG */
	}
	return;
}

/* IMPORTANT looks like function to print char */
/* always returns 0 */
/* 05CD */
void func_05CD(void)
{
	do {
		A = print_this_char;
		push(VA);
		func_05E4(); /* always returns 0 */
		if (func_08B1()) {
			VA = pop();
			func_221B(); /* always returns 0 */
			return 0;
		}
		86                 CALT    ($008C)
		VA = pop();
		print_this_char = A;
	} while (!(VV[0x05] & 0x01));
	return 0;
}
/* always returns 0 */
/* 05E4 */
void func_05E4(void)
{
	VV[0x08] &= 0x8c;
	VV[0x08] |= VV[0x0a] & 0x73;
	VV[0x09] &= 0x26;
	VV[0x09] |= VV[0x0b] & 0xd9;
	VV[0x07] &= 0xef;

	if (VV[0x09] & 0x02) {
		if ((VV[0x09] & 0x80) && ((VV[0x08] & 0x04) || (VV[0x09] & 0x40)))
			VV[0x06] &= 0xef; /* 1110 1111 */
		VV[0x08] |= 0x20;
	} else {
		if (VV[0x09] & 0x40)
			VV[0x08] |= 0x20;
	}

	if (!func_1AD6()) {
		func_0632(); /* always returns 0 */
		if (VV[0x07] & 0x10)
			swap_special_char(); /* always returns 0 */
		if ((VV[0x04] & SLASHED_ZERO) && print_this_char == '0')
			print_this_char = 0x7F; /* slashed zero */
	} else {
		VV[0x08] |= 0x02;
		VV[0x06] &= 0xef; /* 1110 1111 */ /* call $06D0 */
		if ((VV[0x07] & 0x40) && (VV[0x11] & DATA_BUFFER_FULL))
			VV[0x07] &= 0xbf; /* 1011 1111 */
	}
	return 0;
}
/* always returns 0 */
/* 0632 */
void func_0632(void)
{
	int (func)(void);

	B = VV[0x04];
	A = print_this_char;
	if (A == '_')
		VV[0x09] |= 0x08;
	if (!(A & 0x80))
		return 0;
	if (!(VV[0x04] & GRAPHICS_20)) {
		if (A & 0x80) {
			VV[0x09] |= 0x80;
			print_this_char &= 0x7f;
		}
		if (print_this_char == '_')
			VV[0x09] |= 0x08;
		return 0;
	}
	B &= 0x07; /* 0000 0111 */
	if (B > 0x04 || B == 0x00)
		goto 0676;
	switch (B) {
	case 1: func = 0x0708; break;
	case 2: func = 0x0712; break;
	case 3: func = 0x071c; break;
	case 4: func = 0x0726; break;
	}
	if (func() && (A > 0xB0)) {
		if (A < 0xE0) {
			VV[0x06] &= 0xef; /* 1110 1111 */ /* call $06D0 */
			if (!(VV[0x0A] & 0x20) && !(VV[0x09] & 0x02) && (VV[0x09] & 0x40))
				VV[0x08] &= 0xDF;
			VV[0x08] &= 0xEF; /* 1110 1111 */
			VV[0x09] &= 0x3F; /* 0011 1111 */
			VV[0x09] |= array_06d8[A - 0xB0];
		} else {
			if (A == 0xF4 || A == 0xF5) {
				if (!(VV[0x0A] & 0x20) && !(VV[0x09] & 0x02) && (VV[0x09] & 0x40))
					VV[0x08] &= 0xDF;
				if (A == 0xF4)
					VV[0x09] |= 0x10;
				VV[0x08] &= 0xEF; /* 1110 1111 */
				VV[0x09] &= 0x3F; /* 0011 1111 */
				VV[0x06] &= 0xef; /* 1110 1111 */ /* call $06D0 */
				if ((VV[0x07] & 0x40) && (VV[0x11] & DATA_BUFFER_FULL))
					VV[0x07] &= 0xbf; /* 1011 1111 */
			} else if (A == 0xFF) {
				print_this_char = ' ';
			}
		}
	}
	return 0;
}
/* 06D8 */
uint8_t array_06d8[0x30] = {
	0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
	0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x10,
	0x08, 0x08, 0x18, 0x18, 0x08, 0x18, 0x18, 0x18,
	0x08, 0x18, 0x08, 0x18, 0x18, 0x08, 0x18, 0x08,
	0x08, 0x18, 0x18, 0x08, 0x08, 0x18, 0x18, 0x18,
	0x18, 0x00, 0x18, 0x18, 0x18, 0x10, 0x18, 0x08,
};

0708:
	HL = 0x0749;
	B = 0x2E;
	C = 0x00;
	D = 0x09;
	goto 0730;
0712:
	HL = 0x07A7;
	B = 0x0F;
	C = 0x00;
	D = 0x01;
	goto 0730;
071C:
	HL = 0x07C7;
	B = 0x14;
	C = 0x00;
	D = 0x05;
	goto 0730;
0726:
	HL = 0x07F1;
	B = 0x02;
	C = 0x00;
	D = 0x04;
0730:
	do {
		C++;
		HL++;
		if (A == [HL++]) {
			HL -= 2;
			A = [HL];
			print_this_char = A;
			A = D;
			if (A <= C) {
				VV[0x08] |= 0x40;
			} else {
				VV[0x07] |= 0x10;
			}
			return 0;
		}
	} while (B--);
	return 1;

00000749  15 9b 14 9d 9b bd 1f be  0b cf 7c dd 10 f5 16 f9  |..........|.....|
00000759  80 9e 81 a9 82 b5 83 b6  84 b7 85 b8 86 c6 87 c7  |................|
00000769  88 d0 89 d1 8a d2 8b d3  8c d4 8d d5 8e d6 8f d7  |................|
00000779  90 d8 91 de 92 e0 93 e2  94 e3 95 e4 96 e5 97 e7  |................|
00000789  98 e8 99 e9 9a ea 9b eb  9c ec 9d ed 9e ee 9f ef  |................|
00000799  a0 f0 a1 f2 a2 f3 a3 f4  a4 f7 a5 fb a6 fc 86 84  |................|
000007a9  82 86 8a 89 8e 8b 93 8c  87 8e 83 8f 84 91 8c 92  |................|
000007b9  95 94 99 96 91 98 96 99  9b 9d 92 9f 94 a9 10 8f  |................|
000007c9  0b 98 7c a0 16 a4 83 84  a3 86 a1 8d 84 8e 8c 91  |..|.............|
000007d9  8a 92 8b 94 90 95 93 99  9b 9d 9a 9e 9f a1 a4 a5  |................|
000007e9  a6 a6 9e a7 8f a8 a2 ad  15 9b 14 9d 0b af        |..............  |

/* always returns 0 */
/* 07F7 */
void swap_special_char(void)
{
	uint8_t ch = print_this_char;
	int i;

	if (!(ch & 0x80) && VV[0x0c] != 0x00) {
		for (i = 0; i < 12; i++) {
			if (ch == special_chars[0][i]) {
				/* VV[0x0C] from 1 to 0x0d */
				print_this_char = special_chars[VV[0x0C]][i];
				break;
			}
		}
	}

	return 0;
}

/* #$@[\]^`{|}~ */
uint8_t special_chars[][] = {
	{ 0x23, 0x24, 0x40, 0x5b, 0x5c, 0x5d, 0x5e, 0x60, 0x7b, 0x7c, 0x7d, 0x7e },
	{ 0x23, 0x24, 0x00, 0x05, 0x0f, 0x10, 0x5e, 0x60, 0x1e, 0x02, 0x01, 0x16 },
	{ 0x23, 0x24, 0x10, 0x17, 0x18, 0x19, 0x5e, 0x60, 0x1a, 0x1b, 0x1c, 0x11 },
	{ 0x06, 0x24, 0x40, 0x5b, 0x5c, 0x5d, 0x5e, 0x60, 0x7b, 0x7c, 0x7d, 0x7e },
	{ 0x23, 0x24, 0x40, 0x12, 0x14, 0x0d, 0x5e, 0x60, 0x13, 0x15, 0x0e, 0x7e },
	{ 0x23, 0x0b, 0x1d, 0x17, 0x18, 0x0d, 0x19, 0x1e, 0x1a, 0x1b, 0x0e, 0x1c },
	{ 0x23, 0x24, 0x40, 0x05, 0x5c, 0x1e, 0x5e, 0x02, 0x00, 0x03, 0x01, 0x04 },
	{ 0x0c, 0x24, 0x40, 0x07, 0x09, 0x08, 0x5e, 0x60, 0x16, 0x0a, 0x7d, 0x7e },
	{ 0x23, 0x24, 0x40, 0x5b, 0x1f, 0x5d, 0x5e, 0x60, 0x7b, 0x7c, 0x7d, 0x7e },
	{ 0x23, 0x0b, 0x1d, 0x12, 0x14, 0x0d, 0x19, 0x1e, 0x13, 0x15, 0x0e, 0x1c },
	{ 0x23, 0x24, 0x1d, 0x12, 0x14, 0x0d, 0x19, 0x1e, 0x13, 0x15, 0x0e, 0x1c },
	{ 0x23, 0x24, 0xa0, 0x07, 0x09, 0x08, 0x1e, 0x60, 0xa1, 0x0a, 0xa2, 0xa3 },
	{ 0x23, 0x24, 0xa0, 0x07, 0x09, 0x08, 0x1e, 0x1c, 0xa1, 0x0a, 0xa2, 0xa3 },
}

/* 08B1 */
int func_08B1(void)
{
	VV[0x11] &= 0xFB; /* 1111 1011 */
	VV[0x05] &= 0xFE; /* 1111 1110 */
	A = print_this_char;
	BC = [0x9808];
	func_22C9(); /* always returns 0 */
	[0x993B] = EA;
	EA += [0x9901];
	if (EA <= [0x993d])
		return 1;
	if (VV[0x05] & 0x80) {
		if (print_this_char == ' ') {
			VV[0x05] |= 0x01; /* 0000 0001 */
			return 0;
		}
		if (EA <= ([0x9947] >> 1) + [0x993d])
			return 1;
		VV[0x11] |= 0x04; /* 0000 0100 */
	}
	return 0;
}

08F4:
	push(HL);
	40 A5 0E           CALL    $0EA5
	HL = pop();
	func_08FE(); /* always returns 0 */
	86                 CALT    ($008C)
	return 0;

/* always returns 0 */
/* 08FE */
void func_08FE(void)
{
	while ((A = [HL++])) {
		print_this_char = A;
		push(HL);
		func_05CD(); /* always returns 0 */
		HL = pop();
	}
	return 0;
}
/* always returns 0 */
/* 090A */
void func_090A(void)
{
	HL = 0x09D5;
	A = VV[DIPSW1];
	[0xFF8A] = A;
	func_0955(); /* always returns 0 */
	func_0955(); /* always returns 0 */
	A = VV[DIPSW1];
	B = A;
	B &= 0x0c;
	B >>= 2;
	func_095E(); /* always returns 0 */
	if (!(VV[0x04] & GRAPHICS_20)) {
		while ([HL++] != 0x02);
		func_0955(); /* always returns 0 */
		A = VV[0x0C];
		B = A;
		func_095E(); /* always returns 0 */
	} else {
		A = VV[0x04];
		B = A;
		B &= 0x07;
		func_095E(); /* always returns 0 */
		while ([HL++] != 0x02);
		while ([HL++] != 0x02);
	}
	A = VV[DIPSW2];
	[0xFF8A] = A;
	func_0955(); /* always returns 0 */
	func_0955(); /* always returns 0 */
	func_0955(); /* always returns 0 */
	func_0955(); /* always returns 0 */
	return 0;
}
/* always returns 0 */
/* 0955 */
void func_0955(void)
{
	A = [0xFF8A];
	B = !(A & 0x01);
	A >>= 1;
	func_095E(); /* always returns 0 */
	return 0;
}
/* always returns 0 */
/* 095E */
void func_095E(void)
{
	push(BC);
	push(HL);
	clear_80_spaces(); /* always returns 0 */
	HL = pop();
	BC = pop();
	DE = 0xFF00;
	strcpy(DE, HL); /* always returns 0 */
	strskip(B); /* always returns 0 */
	DE = 0xFF14; /* 20 */
	strcpy(DE, HL); /* always returns 0 */
	while ([HL++] != 0x01);
	A = [HL];
	if (A != 0xff) {
		DE = 0xFF25; /* 40 */
		func_098E(); /* always returns 0 */
	}
	A = 0x00;
	[DE] = A;
	push(HL);
	HL = 0xFF00;
	40 F4 08           CALL    $08F4
	HL = pop();
	while ([HL++] != 0x02);
	return 0;
}
/* always returns 0 */
/* 098E */
void func_098E(void)
{
	do {
		strcpy(DE, HL); /* always returns 0 */
		DE++;
		[DE++] = 0x4F; /* 'O' */
		A = [0xFF8A];
		EA = 0x4646; /* 'FF' */
		if (A & 0x01)
			EA = 0x204E; /* ' O' */
		A >>= 1;
		[DE++] = EA;
		[0xFF8A] = A;
		DE++;
		A = [HL];
	} while (A != 0x02);
}
/* always returns 0 */
/* 09AD */
void clear_80_spaces(void)
{
	[0xFF50] = 0x00;
	memset(0xFF00, ' ', 0x4E);
}
/* always returns 0 */
/* 09BF */
void strcpy(uint8_t *DE, uint8_t *HL)
{
	while (1) {
		A = [HL++];
		if (A == 0x00)
			return 0;
		[DE++] = A;
	}
}
/* always returns 0 */
/* 09CD */
void strskip(uint8_t B)
{
	while (1) {
		if (!B--)
			return 0;
		while ([HL++]);
	}
}

09D5: DW: 43 68 61 72 61 63 74 65 72 20 50 69 74 63 68 00
          "Character Pitch"
09E5: DW: 31 32 20 43 50 49 00
          "12 CPI"
09EC: DW: 31 32 20 43 50 49 00
          "10 CPI"
09F3: DW: 01 31 2D 31 00
             "1-1"
09F8: DW: 02 53 68 61 70 65 20 6F 66 20 5A 65 72 6F 00
             "Shape of Zero"
0A07: DW: 30 20 28 53 6C 61 73 68 65 64 29 00
          "0 (Slashed)"
0A13: DW: 30 20 28 55 6E 73 6C 61 73 68 65 64 29 00
          "0 (Unslashed)"
0A21: DW: 01 31 2D 32 00
             "1-2"
0A26: DW: 02 50 61 67 65 20 4C 65 6E 67 74 68 00
             "Page Length"
0A33: DW: 37 30 2F 36 20 69 6E 63 68 00
          "70/6 inch"
0A3D: DW: 38 2E 35 20 69 6E 63 68 00
          "8.5 inch"
0A46: DW: 31 32 20 69 6E 63 68 00
          "12 inch"
0A4E: DW: 31 31 20 69 6E 63 68 00
          "11 inch"
0A56: DW: 01 31 2D 33 00
             "1-3"
0A5B: DW: 31 2D 34 00
          "1-4"
0A5F: DW: 02 50 43 20 54 61 62 6C 65 00
             "PC Table"
0A69: DW: 55 6E 69 74 65 64 20 53 74 61 74 65 73 00
          "United States"
0A77: DW: 4D 75 6C 74 69 6C 69 6E 67 75 61 6C 00
          "Multilingual"
0A84: DW: 50 6F 72 74 75 67 61 6C 00
          "Portugal"
0A8D: DW: 43 61 6E 61 64 61 2D 46 72 65 6E 63 68 00
          "Canada-French"
0A9B: DW: 4E 6F 72 77 61 79 00
          "Norway"
0AA2: DW: 55 6E 69 74 65 64 20 53 74 61 74 65 73 00
          "United States"
0AB0: DW: 55 6E 69 74 65 64 20 53 74 61 74 65 73 00
          "United States"
0ABE: DW: 55 6E 69 74 65 64 20 53 74 61 74 65 73 00
          "United States"
0ACC: DW: 01 31 2D 35 00
             "1-5"
0AD1: DW: 31 2D 36 00
          "1-6"
0AD5: DW: 31 2D 37 00
          "1-7"
0AD9: DW: 31 2D 38 00
          "1-8"
0ADD: DW: 02 43 68 61 72 61 63 74 65 72 20 54 61 62 6C 65 00
             "Character Table"
0AEE: DW: 47 72 61 70 68 69 63 73 00
          "Graphics"
0AF7: DW: C9 F4 E1 EC E9 E3 F3 00
0AFF: DW: 01 31 2D 35 00
             "1-5"
0B04: DW: 02 43 6F 75 6E 74 72 79 00
             "Country"
0B0D: DW: 55 2E 53 2E 41 2E 00
          "U.S.A."
0B14: DW: 46 72 61 6E 63 65 00
          "France"
0B1A: DW: 47 65 72 6D 61 6E 79 00
          "Germany"
0B23: DW: 55 2E 4B 2E 00
          "U.K."
0B28: DW: 44 65 6E 6D 61 72 6B 00
          "Denmark"
0B30: DW: 53 77 65 64 65 6E 00
          "Sweden"
0B37: DW: 49 74 61 6C 79 00
          "Italy"
0B3D: DW: 53 70 61 69 6E 00
          "Spain"
0B43: DW: 01 31 2D 36 00
             "1-6"
0B48: DW: 31 2D 37 00
          "1-7"
0B4C: DW: 31 2D 38 00
          "1-8"
0B50: DW: 02 53 68 6F 72 74 20 54 65 61 72 2D 6F 66 66 00
             "Short Tear-off"
0B60: DW: 49 6E 76 61 6C 69 64 00
          "Invalid"
0B68: DW: 56 61 6C 69 64 00
          "Valid"
0B6E: DW: 01 32 2D 31 00
             "2-1"
0B73: DW: 02 43 53 46 20 4D 6F 64 65 00
             "CSF Mode"
0B7D: DW: 56 61 6C 69 64 00
          "Valid"
0B83: DW: 49 6E 76 61 6C 69 64 00
          "Invalid"
0B8B: DW: 01 32 2D 32 00
             "2-2"
0B90: DW: 02 53 6B 69 70 20 50 65 72 66 6F 72 61 74 69 6F 6E 00
             "Skip Perforation"
0BA2: DW: 31 20 69 6E 63 68 00
          "1 inch"
0BA9: DW: 4E 6F 6E 65 00
          "None"
0BAE: DW: 01 32 2D 33 00
             "2-3"
0BB3: DW: 02 41 75 74 6F 20 4C 46 00
             "Auto LF"
0BBC: DW: 56 61 6C 69 64 00
          "Valid"
0BC2: DW: 44 65 70 65 6E 64 20 6F 6E 20 49 2F 46 00
          "Depend on I/F"
0BD0: DW: 01 32 2D 34 00
             "2-4"
0BD5: DW: 02 44 72 61 66 74 20 50 72 69 6E 74 20 53 70 65 65 64 00
             "Draft Print Speed"
0BE8: DW: 4E 6F 72 6D 61 6C 00
          "Normal"
0BEF: DW: 48 69 67 68 00
          "High"

0BF4: 01 FF 02

/* always returns 0 */
/* 0BF7 */
void timer1_reset(void)
{
	TMM |= 0xe0; /* 1110 0000 */
	             /* ff input clock source: upcounter 0 equals tm0 */
	             /* timer0: internal clock /12, count up */
	             /* timer1: upcounter0 = tm0, reset to 0 and stop counting */
	clear_interrupt(FT1); /* clear FT1 interrupt flag */
	TM1  = 0x26;
	timer1_func = timer1_0;
	TMM &= 0x3f; /* 0011 1111 */
	             /* timer1: count up, internal clock / 384 */
	MKL &= 0xfb; /* 1111 1011 */ /* activate INTT1 */
	return 0;
}

/* 0C0F */
void __attribute__((interrupt)) timer1_0(void)
{
	check_voltage(); /* either returns 0 or resets */
	exx();
	exa();
	enable_interrupts();
	return; /* FROM INTERRUPT */
}

/* either returns 0 or resets */
/* 0C16 */
void check_voltage(void)
{
	A = CR1;
	if (VV[VOLTAGE_STATUS] & UNDER_VOLTAGE_2) { /* 0000 0010 */
		if (A <= 0xb8) { /* less than 21.86 V */
			VV[VOLTAGE_STATUS] |= UNDER_VOLTAGE_1; /* 0000 0001 */
			killall(); /* always returns 0 */
			write_all_93c06(); /* always returns 0 */
			[0xC004] = C004_7 | C004_6 | C004_1 | C004_0; /* 1100 0011 */
			reset();
		}
		VV[VOLTAGE_STATUS] &= ~UNDER_VOLTAGE_2; /* 1111 1101 */
		return 0;
	}
	if (A <= 0xb8) /* less than 21.86 V */
		VV[VOLTAGE_STATUS] |= UNDER_VOLTAGE_2; /* 0000 0010 */
	return 0;
}
/* NMI */
/* 0C2A */
void irq_nmi(void)
{
	if (VV != 0x98)
		reset();
	if (!(VV[VOLTAGE_STATUS] & UNDER_VOLTAGE_1)) {
		VV[VOLTAGE_STATUS] |= UNDER_VOLTAGE_1;
		killall(); /* always returns 0 */
		write_all_93c06(); /* always returns 0 */
		[0xC004] = C004_7 | C004_6 | C004_1 | C004_0; /* 1100 0011 */
		reset();
	}
	enable_interrupts();
	return; /* FROM INTERRUPT */
}

/* always returns 0 */
/* 0C48 */
void killall(void)
{
	MKL    = 0xff; /* mask all interrupts */
	MKH    = 0xff; /* mask all interrupts */
	[0xC005] = 0x0000; /* clears all pins of the printhead. */
	[0xC007] = 0x0000; /* Latches the phase data for the CR motor. */
	EOM   = b10011001; /* to set LVx, output LVx */
	VV[0x0f] &= ~0x80; /* 0111 1111 */
	VV[0x0f] &= ~0x40; /* 1011 1111 */
	VV[0x01] &=  0xcf; /* 1100 1111 */
	func_0F9C(); /* always returns 0 */
	return 0;
}
/* always returns 0 */
/* 0C64 */
void read_all_93c06(void)
{
	VV[ADDRESS_93C06] = 0x00;
	do {
		93c06.WEN();
		HL = 0x9847;
		B = 0x00;
		C = 0x07;
		do {
			EA = 93c06.READ();
			[HL++] = EA;
			if (EA != 0xffff)
				93c06.ERASE();
			VV[ADDRESS_93C06]++;
			B += EAL + EAH;
		} while (C--);
		if (B == 0x1d)
			goto cksum_ok;
	} while (VV[ADDRESS_93C06] <= 0x08);
	clear_93c06(); /* always returns 0 */
cksum_ok:
	93c06.WDS();
	return 0;
}
/* always returns 0 */
/* 0C9A */
void write_all_93c06(void)
{
	cksum_93c06(); /* always returns 0 */
	93c06.WEN();
	if (VV[ADDRESS_93C06] >= 0x09)
		VV[ADDRESS_93C06] = 0x00;
	HL = 0x9847;
	C = 0x07;
	do {
		EA = [HL++];
		if (EA != 0xffff)
			93c06.WRITE(EA);
		VV[ADDRESS_93C06]++;
	} while (C--);
	93c06.WDS();
	return 0;
}
/* always returns 0 */
/* 0CBF */
void cksum_93c06(void)
{
	A = 0x00;
	HL = 0x9847;
	B = 0x0e;
	do {
		A += [HL++];
	} while (B--);
	[0x9856] = 0x1d - A; /* CHECKSUM_93c06 */
	return 0;
}
/* always returns 0 */
/* 0CD3 */
void clear_93c06(void)
{
	beep_x_y(1, 2, 1); /* 1054 */
	93c06.WEN();
	93c06.ERAL();
	93c06.WDS();
	memcpy(0x9847, 0x0D18, 0x0e);
	return 0;
}
/* always returns 0 */
/* 0CE9 */
void clear_93c06_partially(void)
{
	uint8_t tmp[5];

	beep_x_y(1, 2, 1); /* 1054 */
	93c06.WEN();
	93c06.ERAL();
	93c06.WDS();
	memcpy(tmp, 0x9850, 5);
	memcpy(0x9847, 0x0D18, 0x0e);
	memcpy(0x9850, tmp, 5);
	return 0;
}

/* 93c06 default values */
0D18: DW: 00 00 00 00 00 00 90 12 00 2D 1F 39 37 23 00

/* 0D27 */
uint16_t 93c06.READ(void)
{
	93c06.instruction_addr(READ);
	93c06.DI = 0;
	93c06.clock();
	EA = 0x0000;

	for (i = 0; i < 0x10; i++) {
		EA = (EA<<1) & 93c06.DO;
		93c06.clock();
	}

	return EA;
}
/* 0D52 */
void 93c06.WRITE(uint16_t EA)
{
	93c06.instruction_addr(WRITE);
	93c06.send(EAH);
	93c06.send(EAL);
	93c06.DI = 0;
	93c06.CS = 0;
	delay(10);
	return;
}
/* 0D67 */
void 93c06.ERASE(void)
{
	93c06.instruction_addr(ERASE);
	93c06.DI = 0;
	93c06.CS = 0;
	delay(10);
	return;
}
/* 0D6B */
void 93c06.ERAL(void)
{
	93c06.instruction(ERAL);
	93c06.DI = 0;
	93c06.CS = 0;
	delay(10);
	return;
}
/* 0D6F */
void 93c06.WEN(void)
{
	93c06.instruction(WEN);
	93c06.DI = 0;
	93c06.CS = 0;
	nop();
	return;
}
/* 0D7A */
void 93c06.WDS(void)
{
	93c06.instruction(WDS);
	93c06.DI = 0;
	93c06.CS = 0;
	nop();
	return;
}

void 93c06.instruction(instruction)
{
	93c06.DI = 0;
	93c06.CS = 1;
	93c06.clock();
	93c06.DI = 1; /* start bit */
	93c06.clock();
	93c06.send(A);
	return;
}
void 93c06.instruction_addr(instruction)
{
	A |= VV[ADDRESS_93C06];
	93c06.instruction(A);
}

void 93c06.send(uint8_t A)
{
	B = 0x80;
	do {
		93c06.DI = 0;
		if (A & B)
			93c06.DI = 1;
		93c06.clock();
		B >>= 1;
	} while (B);
	return;
}

0DB9:
	if (!func_32E5())
		return 0;
	40 47 2D           CALL    $2D47
	if (!func_32E5())
		return 0;
	clear_80_spaces(); /* always returns 0 */
	HL = 0x0E0E;
	40 F4 08           CALL    $08F4
	clear_80_spaces(); /* always returns 0 */
	40 34 0E           CALL    $0E34
	EA = [0x1290];
	HL = [0x9A77];
	EA -= HL;
	HL = 0x0142;
	EA += HL;
	HL = 0x984D;
	[HL] = EA;
	A = VV[0x2C];
	EA = EA / A, A = EA % A; /* simultaneously */
	if (A != 0x00)
		EA++;
	convert_digits_to_base16(EA); /* always returns 0 */
	HL = 0x0E26;
	DE = 0xFF00;
	strcpy(DE, HL); /* always returns 0 */
	printf_2x(B);
	printf_02x(C);
	A = '.';
	[DE] = A;
	HL = 0xFF00;
	40 F4 08           CALL    $08F4
	40 7D 2D           CALL    $2D7D
	return 0;

0E0E: DW: 54 68 69 73 20 69 73 20 74 68 65 20 66 69 72 73 74 20 6C 69 6E 65 2E 00
          "This is the first line."
0E26: DW: 54 68 69 73 20 69 73 20 6C 69 6E 65 20 00
          "This is line "

0E34:
	BC = 0x1290;
	func_313F(); /* always returns 0 */
	BC = 0x011E;
	40 AE 2E           CALL    $2EAE
	goto 2DAE;
	VV[0x13] &= 0xDF;
	return 0;

/* always returns 0 */
/* 0E45 */
void printf_2x(uint8_t A)
{
	/* not really printf("%2x", EA); because it prints nothing on 00 */
	EA = byte_to_char(A);
	if (EAL != '0') [DE++] = A;
	if (EAH != '0') [DE++] = A;
	return 0;
}
/* always returns 0 */
/* 0E51 */
void printf_02x(uint8_t A)
{
	EA = byte_to_char(A);
	[DE++] = EAL;
	[DE++] = EAH;
	return 0;
}
/* takes a byte from 00 to ff and prints it out as '00' to 'FF' */
/* 0E59 */
uint16_t byte_to_char(uint8_t A)
{
	EAL = nibble_to_char(A >>= 4);
	EAH = nibble_to_char(A & 0x0f);
	return EA;
}
/* takes a nibble from 0 to f and prints it out as '0' to 'F' */
/* 0E6E */
char nibble_to_char(uint8_t A)
{
	if (A >= 10)
		A += 7; /* distance from numbers to letters in ASCII */
	A += '0';
	return A;
}

/* Takes EA as a decimal value, and outputs each 10th to a separate
 * hex digit. For example 123 would result in 0x0123 */
/* always returns 0 */
/* 0E75 */
void convert_digits_to_base16(uint16_t EA)
{
	uint8_t result[2] = { 0x00, 0x00 };
	int count = 0x02;
	int val = EA;
	int rem;

	do {
		rem = val % 10;
		val = val / 10;
		switch (count) {
		case 0x02; result[0]  = rem       ; break;
		case 0x01: result[0] += rem * 0x10; break;
		case 0x00: result[1]  = rem       ; break;
		}
	} while (A--);

	EA = result;
	BC = result;
	return 0;
}

0EA2:
	40 09 0F           CALL    $0F09

0EA5:
	if (!func_2E4B) {
		func_0EC2(); /* always returns 0 */
		return 0;
	}
	40 0A 2F           CALL    $2F0A
	goto 2C2B;
	48 44              SKIT    F2 /* ONLINE BUTTON */
	return 0;
	if (VV[0x13] & 0x10) {
		func_2FEF(); /* always returns 0 */
		sw_online_wait();
		return 0;
	}
	if (VV[0x03] & DATA_DUMP_MODE)
		func_0412(); /* always returns 1, already skipped */
	else
		func_1B05(); /* always returns 0 */
	func_0EC2(); /* always returns 0 */
	return 0;

/* always returns 0 */
/* 0EC2 */
void func_0EC2()
{
	func_2FE9(); /* always returns 0 */
/* 0ec5 */
	func_0F9C(); /* always returns 0 */
/* 0ec8 */
	if (!func_2E08())
		func_31D0(); /* always returns 0 */
/* 0ece */
	do {
		sw_online_wait(); /* DEBUG STUCK HERE WAITING FOR ONLINE BUTTON */
		do {
			func_2C37(); /* always returns 0 */
/* 0ed2 */
		} while (!skit(F2));
		if (VV[0x13] & 0x20)
			continue;
		if (!func_2E08())
			break;
		if (func_32EC() || !sensor_paper_end_debounced())
			continue;
		if (!(VV[0x13] & 0x40))
			break;
	} while (func_2CC0() || VV[0x13] & 0x60 || (!func_32E5() && sensor_paper_end_debounced()));
	VV[0x13] &= 0xBB;
	func_0F70(); /* always returns 0 */
	40 0A 2F           CALL    $2F0A
	goto 2C2B;
	sw_online_wait();
	return 0;
}

/* always returns 0 */
/* 0F01 */
void sw_online_wait(void)
{
	while (!sw_online_debounced());
	clear_interrupt(F2); /* ONLINE BUTTON */
	return 0;
}

0F09:
	if (VV[0x13] & 0x10)
		return 0;
	if (!sw_form_feed())
		goto 0F33;
	if (!(VV[0x0b] & 0x02) || VV[0x0a] & 0x01)
		goto 0F22;
	beep_x_y(1, 3, 1); /* 1051 */
	VV[0x4F] |= 0x02; /* 0000 0010 */
	40 C9 15           CALL    $15C9
	goto 0F57
0F22:
	beep_x_y(1, 2, 1); /* 1054 */
	VV[0x4F] &= 0xFD; /* 1111 1101 */
	40 CD 15           CALL    $15CD
	VV[0x4F] |= 0x01; /* 0000 0001 */
	func_152B(); /* always returns 0 */
	goto 0F57
0F33:
	if (!sw_line_feed())
		goto 0F3F;
	one_short_beep(); /* always returns 0 */
	VV[0x4F] &= 0xFE; /* 1111 1110 */
	func_152F(); /* always returns 0 */
	goto 0F57
0F3F:
	if (!sw_load_eject())
		goto 0F5A;
	5A 0B              BIT     2,VV:0B
	goto 0F50
	beep_x_y(1, 2, 1); /* 1054 */
	VV[0x4F] &= 0xFB; /* 1111 1011 */
	func_14FC(); /* always returns 0 */
	goto 0F57
0F50:
	one_short_beep(); /* always returns 0 */
	VV[0x4F] |= 0x04; /* 0000 0010 */
	func_14F8(); /* always returns 0 */
0F57:
	wait_for_button(); /* always returns 0 */
0F5A:
	return 0;

/* always returns 0 */
/* 0F5B */
void func_0F5B()
{
	if (sensor_paper_end_debounced()) {
		func_0F70(); /* always returns 0 */
	} else {
/* 0F5D */
		if (!func_32EC())
			func_2D7D(); /* TODO check return value */
/* 0F66 */
		if (func32E5() || VV[0x01] & 0x04) {
			func_0F70(); /* always returns 0 */
		} else {
/* 0F6A */
			func_32CF(); /* always returns 0 */
/* 0F6D */
			func_0EC2(); /* always returns 0 */ /* DEBUG stuck here 2 */
		}
	}
	return 0;
}

/* always returns 0 */
/* 0F70 */
void func_0F70()
{
	VV[0x14] |= 0x40; /* 0100 0000 */
	[0xC004] &= ~(C004_6 | C004_3 | C004_2); /* 1011 0011 */
	if (VV[0x03] & SELF_TEST_MODE)
		return 0;
	[0xC004] |= C004_4; /* 0001 0000 */
	if (!(VV[0x11] & COMM_SERIAL)) {
		if ([0xC002] & 0x80)
			return 0;
		[0xC004] |=  C004_5; /* 0010 0000 */
		[0xC004] &= ~C004_5; /* 1101 1111 */
	} else {
		if (VV[0x11] & DONT_READ_DATA)
			return 0;
		MKH &= 0xfd; /* 1111 1101 */ /* activate INTSR */
		A = 0x11;
		TXB = A;
	}
	[0xC004] &= ~C004_0; /* 1111 1110 */
	[0xC004] |=  C004_1; /* 0000 0010 */
	return 0;
}

/* always returns 0 */
/* 0F9C */
void func_0F9C(void)
{
	check_gate_array_input(); /* always returns 0 */
	VV[0x14] &= 0xBF; /* 1011 1111 */
	[0xC004] &= ~C004_4; /* 1110 1111 */
	if (!(VV[0x11] & DONT_READ_DATA)) {
		TXB = 0x13;
		[0xC004] |= C004_0; /* 0000 0001 */
		delay(1);
	}
	                    /* 0100 0000 */
	if ((uint16_t)[0xC004] & C004_6) [0xC004] |= C004_2 | C004_3; /* 0000 1100 */
	else                             [0xC004] |= C004_2;          /* 0000 0100 */
	return 0;
}

/* 0FBF */
void read_stable_PA(void)
{
	do {
		B = PA;
		A = PA;
	} while (A != B);
	/* returns PA in A and B */
}

/* always returns 0 */
/* 0FC8 */
void read_debounced_PA(void)
{
	uint8_t pa1, pa2;
	do {
		pa1 = read_stable_PA();
		delay(10);
		pa2 = read_stable_PA();
	} while (pa1 != pa2);
	A = B = pa1;
	return 0;
}

/* 0FD7 */
void read_stable_PC(void)
{
	do {
		B = PC & 0x3c; /* 0011 1100 */
		A = PC & 0x3c; /* 0011 1100 */
	} while (A != B);
	/* returns PC&0x3c in A and B */
}

/*
 * PA0  R   CN7 sensor
 * PA1  R   CN6 sensor
 * PA2  R   CN4 sensor
 * PA3   W  Stepper motor voltage reference (these 3 pins make up one voltage)
 * PA4   W  Stepper motor voltage reference (these 3 pins make up one voltage)
 * PA5   W  Stepper motor voltage reference (these 3 pins make up one voltage)
 * PA6  R   Line Feed SWITCH
 * PA7  R   Form Feed SWITCH
 */
/* 0FE4 */
int sw_line_feed(void)
{
	A, B = read_stable_PA();
	if (A & 0x40)
		return 0;
	return 1;
}
/* 0FEB */
int sw_form_feed(void)
{
	A, B = read_stable_PA();
	if (A & 0x80)
		return 0;
	return 1;
}
/* 0FF2 */
int sw_load_eject(void)
{
	if (CR2 & 0x80)
		return 0;
	wait_for_AD();
	if (CR2 & 0x80)
		return 0;
	return 1;
}
/* 1003 */
int sw_online(void)
{
	A, B = read_stable_PC();
	if (A & 0x08)
		return 0;
	return 1;
}
/* 1016 */
void func_debounced(uint16_t HL)
{
	if ((HL)())
		return 0;
	delay(10);
	if ((HL)())
		return 0;
	return 1;
}
/* virtual */
int sw_line_feed_debounced()
{
	return func_debounced(sw_line_feed);
}
int sw_form_feed_debounced()
{
	return func_debounced(sw_form_feed);
}
int sw_load_eject_debounced()
{
	return func_debounced(sw_load_eject);
}
int sw_online_debounced()
{
	return func_debounced(sw_online);
}
/* always returns 0 */
/* 1026 */
void wait_for_button(void)
{
	while (!sw_form_feed_debounced() || !sw_line_feed_debounced() || !sw_load_eject_debounced());
	return 0;
}

/* HANG, never returns */
/* 1033 */
void beep_endlessly(void)
{
	while (1) {
		ETMM = 0x00; /* 0000 0000 */ /* ECNT stops counting immediately and is set to 0000h */
		EOM  = 0xb0;
		ETM1 = 0x008c; /* 14.7456MHz/140/2 = 4388,571428571 Hz beep */
		ETMM = 0x0c; /* 0000 1100 */ /* Clear when ECNT = ETM1 */
	}
}

void beep_x_y(uint8_t repeat, uint8_t n_beeps, boolean shortbeep)
{
	if (shortbeep)
		VV[FLAGS_1] |= FLAGS_1_SHORTBEEP; /* 0000 0100, bit 2 */
	func_7bb1();
	while (1) {
		for (int i = 0; i <= n_beeps; i++) {
			beep_60ms();
			if (VV[FLAGS_1] & FLAGS_1_SHORTBEEP) delay( 30);
			else                                 delay(100);
		}
		if (!repeat--) {
			VV[10] &= ~FLAGS_1_SHORTBEEP; /* 1111 1011 */
			break;
		}
		if (VV[FLAGS_1] & FLAGS_1_SHORTBEEP) delay(100);
		else                                 delay(200);
	}
	return 0;
}
void one_short_beep(void)
{
	beep_x_y(1, 1, 1); /* 1057 */
}

/* always returns 0 */
/* 1084 */
void beep_60ms(void)
{
	ETMM = 0x00; /* 0000 0000 */ /* ECNT stops counting immediately and is set to 0000h */
	EOM  = 0xb0;
	ETM1 = 0x008c;
	ETMM = 0x0c; /* 0000 1100 */ /* Clear when ECNT = ETM1 */
	delay(60);
	EOM  = 0x99;
	return 0;
}

/* 109B */
{
	[0xC004] &= A;
}
/* 10A1 */
{
	[0xC004] |= A;
}

/* always returns 0 */
/* 10A8 */
void func_10A8(void)
{
	[0x9830] = 0x03;
	[0x982f] = 0x02;
	[0x982e] = 0x01;
	[0x982d] = 0x00;
	return 0;
}

10B1: 8E                 CALT    ($009C)
	HL = 0x10CD;
	B = 0x03;
10B7:
	70 EF              NEAX    (HL-)
	goto 10BE
	52                 DCR     B
	goto 10B7
	8E                 CALT    ($009C)
	return 0;
10BE:
	push(BC);
	8E                 CALT    ($009C)
	BC = pop();
	A &= 0x0f;
	HL = 0x982D;
	27 06              GTI     A,$06
	BD                 STAX    (HL+B)
	return 0;

	4B 4C              MVIX    HL,$4C
	59 5A              BIT     1,VV:5A
10CE:
	A = VV[0x2D];
	goto 10EE;
10D1:
	A = VV[0x2E];
	goto 10EE;
10D4:
	A = VV[0x2F];
	goto 10EE;
10D7:
	A = VV[0x30];
	goto 10EE;
	8E                 CALT    ($009C)
	A &= 0x0f;
	37 08              LTI     A,$08
	return 0;
	67 07              NEI     A,$07
	goto 10EC;
	goto 10EE;
	8E                 CALT    ($009C)
	A &= 0x0f;
	VV[0x12] |= 0x08;
	37 02              LTI     A,$02
10EC:
	goto 1190;
10EE:
	if (A == 0x02 || A == 0x03) VV[0x12] |= 0x04;
	if (A == 0x05)              VV[0x12] |= 0x60;
	if (A == 0x06)              VV[0x12] |= 0x20;
	A <<= 2;
	HL = 0x1309;
	DE = 0x9821;
	EA = [HL + A];
	[DE++] = EA;
	A += 0x02;
	EA = [HL + A];
	[DE] = EA;
	if (!func_1283())
		goto 118C;
	VV[0x13] |= 0x02
	40 FA 11           CALL    $11FA
	86                 CALT    ($008C)
	BC = 0x0000;
	HL = [0x993D];
	EA = HL;
	HL = [0x9901];
	EA -= HL;
	A = VV[0x22];
	EA = EA / A, A = EA % A; /* simultaneously */
	DE = EA;
	EA = [0x9941];
	74 AE              DGT     EA,DE
	goto 1144
	VV[0x12] |= 0x10
	[0x9941] = DE;
	EA -= DE;
	BC = EA;
1144:
	[0x993F] = BC;
	DE = [0x9941];
	EA = DE;
	A = VV[0x22];
	EA = mul24(EA, A);
	HL = 0x993B;
	[HL] = EA;
	HL = [0x9941];
	EA = HL;
	55 12 08           OFFIW   VV:12,$08
	EA <<= 1;
	HL = EA;
	EA = [0x1000];
	EA -= HL;
1165:
	HL = data_buffer_size;
	74 BF              DLT     EA,HL
	goto 1170
	push(EA);
	check_gate_array_input(); /* always returns 0 */
	EA = pop();
	goto 1165
1170:
	HL = [0x9901];
	[0x9955] = HL;
	VV[0x03] |= 0x80;
	VV[0x05] |= 0x02;
	40 A6 11           CALL    $11A6
	VV[0x05] &= 0xFD;
	HL = 0x993F;
	EA = [HL];
1189:
	func_1196(); /* always returns 0 */
118C:
	VV[0x12] = 0x00;
	return 0;
1190:
	func_1283(); /* result skipped */
	EA = HL;
	goto 1189

/* always returns 0 */
/* 1196 */
void func_1196(void)
{
	if (VV[0x12] & 0x08)
		EA <<= 1;
	func_119B();
	return 0;
}
/* always returns 0 */
/* 119B */
void func_119B(void)
{
	for (; EA; EA--) {
		push(EA);
		8E                 CALT    ($009C)
		EA = pop();
	}
}

11A6:
	40 0B 12           CALL    $120B
	return 0;
	func_1B05(); /* always returns 0 */
	func_1F0C(); /* always returns 0 */
	BC = [0x993B];
	HL = 0x9901;
	EA = [HL];
	EA += BC;
	[HL] = EA;
	59 12              BIT     1,VV:12
	goto 11EE
	40 68 2B           CALL    $2B68
	40 13 2C           CALL    $2C13
	VV[0x20] = VV[0x21];
	VV[0x25] = VV[0x22];
	HL = [0x9823];
	[0x9923] = HL;
	if (VV[0x12] & 0x04) A = [0xC006];
	else                 A = [0xC005];
	func_1294(); /* always returns 0 */
	VV[0x12] |= 0x80;
	VV[0x00] &= 0xFB; /* 1111 1011 */
	92                 CALT    ($00A4)
	func_1F2D(); /* always returns 0 */
	func_1F0C(); /* always returns 0 */
11EE:
	HL = [0x993D];
	5C 12              BIT     4,VV:12
	HL = [0x9901];
	func_170F(); /* always returns 0 */
	return 0;
11FA:
	HL = [0x9901];
	EA = HL;
	A = VV[0x22];
	EA += A;
	HL = [0x993D];
	74 AF              DGT     EA,HL
	return 1;
	return 0;

120B:
	VV[0x12] |= 0x02;
	BC = [0x9941];
	DE = data_buffer_rptr;
	do {
		A = [DE++];
		rollover_DE_from_0x9000_to_0x8000(); /* always returns 0 */
		if (A != 0x00)
			goto end_123D;
		if (VV[0x12] & 0x08) {
			A = [DE++];
			rollover_DE_from_0x9000_to_0x8000(); /* always returns 0 */
			if (A & 0x80)
				goto end_123D;
		}
		BC--;
	} while (BC != 0x0000);
	VV[0x12] &= 0xFD;
	if (!(VV[0x12] & 0x10)) {
		DE = [0x993B];
		if (!func_190B()) {
			EA = [0x993F];
			BC = [0x9941];
			EA += BC;
			[0x993F] = EA;
			return 0;
		}
		BC = 0x0000;
	}
end_123D:
	HL = [0x9941];
	EA = HL;
	EA -= BC;
	HL = EA;
	[0x9943] = HL;
	[0x9941] = BC;
	return 1;

/* 1283 */
int func_1283()
{
	8E                 CALT    ($009C)
	L = A;
	push(HL);
	func_1334(); /* always returns 0 */
	HL = pop();
	H = A;
	EA = 0x0000;
	if (EA == HL)
		return 0;
	[0x9941] = HL;
	return 1;
}

/* always returns 0 */
/* 1294 */
void func_1294()
{
	EA = [0x9943];
	func_1196(); /* always returns 0 */
	[0x990B] = mul24([0x9943], VV[0x22]) + [0x9903];
	EA = [0x9941];
	if (VV[0x12] & 0x08)
		EA <<= 1;
	EA = data_buffer_rptr + EA - 1;
	DE = EA;
	int borrow = (EA >= 0x9000);
	EA -= 0x9000;
	if (borrow) {
		EA += 0x8000;
		DE = EA;
	}
	for (BC = 0x0000; ; BC++) {
		if (VV[0x12] & 0x08) {
			A = [DE--];
			rollover_DE_from_0x7fff_to_0x8fff();
			if (A & 0x80)
				break;
		}
		A = [DE--];
		rollover_DE_from_0x7fff_to_0x8fff();
		if (A)
			break;
	}
	[0x9941] -= BC;
	[0x993F] += BC;
	EA = BC;
	A = VV[0x22];
	EA = mul24(EA, A);
	BC = EA;
	EA = [0x9901];
	EA -= BC;
	[0x990D] = EA;
	return 0;
}

1309:
	0x1800, 0x0560, 0x0C01, 0x0560, 0x0C00, 0x02B0, 0x0601,
	0x02B0, 0x1201, 0x0810, 0x1401, 0x08F5, 0x1001, 0x072A,

/* 1325 */
int func_1325()
{
	func_1334(); /* always returns 0 */
	if (A == 0x00 || A == '0') return 0;
	if (A == 0x01 || A == '1') return 1;
	HL = pop();
	return 0;
}

/* always returns 0 */
/* 1334 */
void func_1334()
{
	8E                 CALT    ($009C)
	A &= 0x7f;
	return 0;
}

1338:
	55 02 08           OFFIW   VV:02,$08
	55 02 04           OFFIW   VV:02,$04
	goto 1348
	func_1377(); /* always returns 0 */
	if (A == 0x11)
		VV[0x02] |= 0x04;
	return 0;
1348:
	if (is_printable_char(A))
		return 1;
134D:
	if (A == 0x7f)
		goto 137C;
	36 07              SUINB   A,$07
	return 0;
	HL = 0x13DA;
	48 25              SLL     A
	60 47              ADD     L,A
	74 56 00           ACI     H,$00
	goto [HL];

/* 1363 */
int is_printable_char(uint8_t A)
{
	func_1377(); /* always returns 0 */
	if (A == 0x7f)
		return 0;
	if (A >= 0x20)
		return 1;
	if (!(VV[0x04] & GRAPHICS_20))
		return 0;
	if (A != 0x15) /* NAK */
		return 0;
	A = 0x10;
	print_this_char = A;
	return 1;
}
/* always returns 0 */
/* 1377 */
void func_1377(void)
{
	if (!(VV[0x04] & GRAPHICS_10))
		A &= 0x7f;
	return 0;
}
137C:
	55 05 80           OFFIW   VV:05,$80
	return 0;
	EA = 0x9A79;
	HL = [0x9939];
	if (EA == HL)
		return 0;
	HL--;
	A = [HL];
	57 01              OFFI    A,$01
	return 0;
	HL--;
	HL--;
	[0x9939] = HL;
	func_1D36(); /* always returns 0 */
	DE = EA;
	HL = 0x9901;
	EA = [HL];
	EA -= DE;
	[HL] = EA;
	return 0;
	func_1334(); /* always returns 0 */
	67 19              NEI     A,$19
	goto 13B3
	77 7F              EQI     A,$7F
	27 1F              GTI     A,$1F
	goto 13D2
	27 2F              GTI     A,$2F
	goto 13B3
	27 5A              GTI     A,$5A
	goto 13C2
13B3:
	HL = 0x1462;
	B = A;
	do {
		A = [HL++];
		if (A == 0x00)
			return 0;
		EA = [HL++];
	} while (A != B);
	goto EA;
13C2:
	A -= '0';
	HL = 0x140C + (A<<1);
	goto [HL];
13D2:
	A = print_this_char;
	if (!is_printable_char(A))
		goto 134D;
	return 0;

13DA: 57 10              OFFI    A,$10
13DC: goto 8C16;
13DF: EAH = A;
13E0: goto 13D8
13E1: A ^= 0x2C;
13E3: EAL = A;
13E4: SP++;
13E5: A |= 0xFD;
13E7: A ^= 0xB6;
13E9: VV[0xF8] |= 0x14
13EC: DE = EA;
13ED: BC = 0x14B6;
13F0: goto 13ED
13F1: BC = 0x1729;
13F4: goto 13E1
13F5: BC = 0x14B6;
13F8: DE = EA;
13F9: BC = 0x14B6;
13FC: goto 1402
13FD: A ^= 0xB6;
13FF: BC = 0x14B6;
1402: HL = pop();
1403: BC--;
1404: DE = EA;
1405: BC = 0x14B6;
1408: DE = EA;
1409: BC = 0x14B6;
140C: 43                 INR     C
140D: A |= 0x45;
140F: A |= 0x47;
1411: A |= 0x4A;
1413: A |= 0xBD;
1415: VV[0xC1] |= 0x15
1418: goto 142A
1419: A ^= 0xD5;
141B: A ^= 0x4C;
141D: A |= 0x50;
141F: A |= 0xB1;
1421: EAL = A;
1422: DE = EA;
1423: BC = 0x7875;
1426: DE = EA;
1427: BC = 0x14B6;
142A: push(BC);
142B: exa();
142C: goto 1446
142D: A ^= 0x37;
142F: A |= 0xC9;
1431: A |= 0x6C;
1433: A |= 0xCC;
1435: A |= 0x00;
1437: 
143A: A = EAH;
143B: VV[0x0C] |= 0x15;
143E: BC = EA;
143F: BC = [0x1754];
1442: goto 1451
1443: exa();
1444: goto 1456
1445: exa();
1446: exa();
1447: VV[0xA1] |= 0x17;
144A: DE = EA;
144B: A |= 0x14;
144D: VV[0x89] |= 0x16;
1450: 30 17              DCRW    VV:17
1452: EAH = A;
1453: VV[0x25] |= 0x15;
1456: EAH = A;
1457: A |= 0xB6;
1459: BC = 0x15A5;
145C: DE = EA;
145D: BC = 0x10D4;
1460: goto 1478
1461: exa();
1462: EAL = A;
1463: 5D 17              BIT     5,VV:17
1465: 20 B5              INRW    VV:B5
1467: BC = 0xB721;
146A: BC = 0xB424;
146D: BC = 0xE925;
1470: EAL = A;
1471: 26 F3              ADINC   A,$F3
1473: EAL = A;
1474: 2A                 LDAX    (DE)
1475: goto 1490
1476: exa();
1477: A = [HL++];
1478: goto 148A
1479: VV[0x2F] |= 0xBF
147C: A |= 0x5C;
147E: push(EA);
147F: BC = [0xE45E];
1482: exa();
1483: 61                 DAA     
1484: A = D;
1485: A ^= 0x62;
1487: goto 14A2
1488: A |= 0x65;
148A: EAL = A;
148B: EAH = A;
148C: A -= 0x4f;
148E: EAH = A;
148F: A = 0xB5;
1491: BC = 0xB56A;
1494: BC = 0xC56B;
1497: VV[0x6C] |= 0xAB;
149A: A ^= 0x6D;
149C: BC = EA;
149D: BC = 0xB570;
14A0: BC = 0xB572;
14A3: BC = 0x3473;
14A6: A ^= 0x74;
14A8: SP++;
14A9: A ^= 0x77;
14AB: BC = EA;
14AC: BC = [0x2978];
14AF: VV[0x7C] |= 0xDA;
14B2: 7C 00              CALF    $0C00
14B4: 8E                 CALT    ($009C)
14B5: 8E                 CALT    ($009C)
14B6: return 0;
14B7: 8E                 CALT    ($009C)
14B8: VV[0x0A] &= 0x43;
14BB: VV[0x0B] &= 0x7B;
14BE: VV[0x02] &= 0xFD;
14C1: VV[0x02] &= 0xFE;
14C4: 57 01              OFFI    A,$01
14C6: VV[0x0A] |= 0x80
14C9: 57 04              OFFI    A,$04
14CB: VV[0x0B] |= 0x04
14CE: 57 08              OFFI    A,$08
14D0: VV[0x0A] |= 0x04
14D3: 57 10              OFFI    A,$10
14D5: VV[0x0A] |= 0x20
14D8: 47 20              ONI     A,$20
14DA: goto 14E1
14DB: VV[0x02] |= 0x01
14DE: VV[0x0A] |= 0x08
14E1:
	57 40              OFFI    A,$40
	VV[0x0B] |= 0x80
	57 80              OFFI    A,$80
	VV[0x0A] |= 0x10
	func_1536(); /* always returns 0 */
	return 0;

/* always returns 0 */
/* 14EC */
void func_14EC()
{
	if (!(VV[0x02] & 0x01) && (VV[0x02] & 0x2)) {
		VV[0x02] &= 0xFD; /* 1111 1101 */
		VV[0x0A] &= 0xF7; /* 1111 0111 */
	}
	func_1536(); /* always returns 0 */
	return 0;
}
/* always returns 0 */
/* 14F8 */
void func_14F8()
{
	VV[0x0B] |= 0x04; /* 0000 0100 */
	func_1536(); /* always returns 0 */
	return 0;
}
/* always returns 0 */
/* 14FC */
void func_14FC()
{
	VV[0x0B] &= 0xFB; /* 1111 1011 */
	func_1536(); /* always returns 0 */
	return 0;
}
/* always returns 0 */
/* 1500 */
void func_1500()
{
	VV[0x0A] |= 0x04; /* 0000 0100 */
	func_1536(); /* always returns 0 */
	return 0;
}
1504:
	VV[0x0A] &= 0xFB;
	func_1536(); /* always returns 0 */
	return 0;

	VV[0x0A] |= 0x20;
	func_1536(); /* always returns 0 */
	return 0;

	VV[0x0A] &= 0xDF;
	func_1536(); /* always returns 0 */
	return 0;

/* always returns 0 */
/* 1510 */
void func_1510()
{
	/* 12 cpi */
	VV[0x0A] |= 0x80; /* 1000 0000 */
	func_1536(); /* always returns 0 */
	return 0;
}
/* always returns 0 */
/* 1514 */
void func_1514()
{
	VV[0x0A] &= 0x7F; /* 0111 1111 */
	func_1536(); /* always returns 0 */
	return 0;
}

1518:
	if (func_1325()) {
		VV[0x0B] &= 0xDF; /* 1101 1111 */
	} else {
		VV[0x0B] |= 0x20; /* 0010 0000 */
	}
	VV[0x0B] |= 0x40; /* 0100 0000 */
	func_1536(); /* always returns 0 */
	return 0;

	VV[0x0B] &= 0xBF;
	func_1536(); /* always returns 0 */
	return 0;

	if (!func_1325())
		func_152F(); /* always returns 0 */
	else
		func_152B(); /* always returns 0 */
	return 0;

/* always returns 0 */
/* 152B */
void func_152B()
{
	VV[0x0B] |= 0x02; /* 0000 0010 */
	func_1536(); /* always returns 0 */
	return 0;
}

/* always returns 0 */
/* 152F */
void func_152F()
{
	VV[0x0B] &= 0xFD; /* 1111 0010 */
	func_1536(); /* always returns 0 */
	return 0;
}

	VV[0x07] |= 0x80; /* 1000 0000 */
	func_1536(); /* always returns 0 */
	return 0;

/* always returns 0 */
/* 1536 */
void func_1536()
{
	A = VV[0x07]
	BC = [0x980A];
	A &= 0xbf; /* 1011 1111 */
	if (A & 0x80)
		A |= 0x40;
	if ((B & 0x02) || (C & 0x04))
		B &= 0xfb; /* 1111 1011 */
	if ((C & 0xA4) || (C & 0x46) || (A & 0x20) || (VV[0x05] & 0x80))
		A &= 0xbf; /* 1011 1111 */

	if (!(VV[0x07] & 0x40)) {
		if (A & 0x40)
			goto 1599;
1566:
		if (!(B & 0x06) && !(C & 0x04))
			goto 1577;
		if ((VV[0x08] & 0x04) || (VV[0x09] & 0x06)) goto 157F;
		else                                        goto 1599;
XXXXXX

1577:
		if ((VV[0x08] & 0x04) || (VV[0x09] & 0x06)
			goto 1599;
157F:
		if (!(B & 0x02)) {
			if (VV[0x09] & 0x02)
				goto 1599;
			if (C & 0x04) {
				if (!(VV[0x09] & 0x04)) goto 159E;
				else                    goto 1599;
			}
			if ((B & 0x04) && (VV[0x08] & 0x04)) goto 1599
			else                                 goto 159E
		}
		if (VV[0x09] & 0x02) goto 159E;
		else                 goto 1599;
	} else {
		if (A & 0x40) goto 1566;
		else          goto 1599;
	}
XXXXXX

1599:
	push(VA);
	push(BC);
	func_1B05(); /* always returns 0 */
	BC = pop();
	VA = pop();
159E:
	VV[0x07] = A;
	[0x9808] = BC;
	return 0;
}

15A5:
	if (!func_1325())
		goto 15AE;
15A7: VV[0x02] |= 0x01;
15AA: VV[0x0A] |= 0x08;
15AD: goto 15B4
15AE: VV[0x02] &= 0xFC;
15B1: VV[0x0A] &= 0xF7;
15B4: goto 1536
15B6: VV[0x02] |= 0x02
15B9: BC = 0x0008;
15BC: goto 15CC
15BD: BC = 0x8000;
	goto 15CC
15C1: BC = 0x8000;
	goto 15D0
15C5: BC = 0x0001;
	goto 15D4
15C9:
	BC = 0x0001;
15CC:
	goto 15D6
15CD:
	BC = 0x0001;
15D0:
	goto 15E9
15D1:
	BC = 0x0010;
15D4:
	if (!func_1325())
		goto 15E9;

15D6:
	[0x980A] |= BC;
	[0x9808] |= BC;
	return 0;

15E9: EA = 0xFFFF;
	EA ^= BC;
15EE: BC = EA;
15EF: HL = 0x980A;
15F2: EA = [HL];
15F4: EA &= BC;
15F6: [HL] = EA;
15F8: HL = 0x9808;
15FB: EA = [HL];
15FD: EA &= BC;
15FF: [HL] = EA;
1601: return 0;
1602:
	if (func_1325()) VV[0x04] |=  GRAPHICS_20; /* 0010 0000 */
	else             VV[0x04] &= ~GRAPHICS_20; /* 1101 1111 */
	return 0;

160C: 8E                 CALT    ($009C)
160D: A &= 0x0f;
160F: 37 04              LTI     A,$04
1611: return 0;
1612: C = 0x00;
1614: 67 01              NEI     A,$01
1616: C = 0x10;
1618: 67 02              NEI     A,$02
161A: C = 0x20;
161C: 67 03              NEI     A,$03
161E: C = 0x80;
1620: A = VV[0x05];
1622: A &= 0xb0;
1624: 60 EB              NEA     A,C
1626: return 0;
1627: push(BC);
1628: 86                 CALT    ($008C)
1629: BC = pop();
162A: A = VV[0x05];
162C: A &= 0x4f;
162E: A |= C;
1630: VV[0x05] = A;
1632: goto 15B4
1634:
	if (!func_1325())
		goto 1641;
1636: 55 07 20           OFFIW   VV:07,$20
1639: return 0;
163A: 40 4B 16           CALL    $164B
163D: VV[0x07] |= 0x20
1640: goto 1632
1641: 5D 07              BIT     5,VV:07
1643: return 0;
1644: 40 4B 16           CALL    $164B
1647: VV[0x07] &= 0xDF;
164A: goto 1632
164B: 55 08 04           OFFIW   VV:08,$04
164E: return 0;
164F: 45 09 06           ONIW    VV:09,$06
1652: func_1B05(); /* always returns 0 */
1653: return 0;
1654: 55 05 B0           OFFIW   VV:05,$B0
1657: return 0;
1658: func_1B05(); /* always returns 0 */
1659: 5F 03              BIT     7,VV:03
165B: goto 166B
165C: VV[0x03] &= 0x7F; /* 0111 1111 */
165F: HL = [0x9955];
1663: EA = HL;
1664: HL = [0x9901];
1668: 74 AF              DGT     EA,HL
166A: goto 1675
166B: 97                 CALT    ($00AE)
166C: DE = EA;
166D: HL = 0x9901;
1670: EA = [HL];
	int borrow = (EA >= DE);
	EA -= DE;
	if (!borrow)
		return 0;
1675: BC = [0x9905];
1679: 74 BD              DLT     EA,BC
167B: goto 167D
167C: return 0;
167D: HL = EA;
167E: func_170F(); /* always returns 0 */
167F: return 0;

1680:
	BC = [0x9808];
	func_22C9(); /* always returns 0 */
	HL = EA;
	return 0;
	40 82 18           CALL    $1882
	return 0;
	DE = [0x9905];
	int borrow = (EA >= DE);
	EA -= DE;
	if (!borrow)
		return 0;
	DE = [0x011F];
	74 AE              DGT     EA,DE
	return 0;
	EA = HL;
	DE = [0x4C81];
	if (!(VV[0x4f] & 0x08))
		DE = [0x2D01];
	74 BE              DLT     EA,DE
	return 0;
	[0x993D] = HL;
	goto 16C4
	40 82 18           CALL    $1882
	return 0;
	DE = [0x993D];
	EA = DE;
	int borrow = (EA >= HL);
	EA -= HL;
	if (!borrow)
		return 0;
	DE = 0x011F;
	74 AE              DGT     EA,DE
	return 0;
	[0x9905] = HL;
	VV[0x03] &= 0xEF; /* 1110 1111 */
16C4:
	goto 16C9
	55 05 80           OFFIW   VV:05,$80
	return 0;
16C9:
	func_170B(); /* always returns 0 */
	VV[0x11] &= 0xFE; /* 1111 1110 */
	func_216F(); /* always returns 0 */
	return 0;
	VV[0x04] |=  GRAPHICS_10; /* 0001 0000 */
	return 0;
	VV[0x04] &= ~GRAPHICS_10; /* 1110 1111 */
	return 0;
	func_7875(); /* always returns 0 */
	40 68 2B           CALL    $2B68
	func_7bb1();
	memset(0x9800, 0x00, 0x0d);
	memset(0x9857, 0x00, 0xb2);
	VV[0x14] |= 0x20;
	EA = pop();
	goto 0195;

16F7:
	func_1B02(); /* always returns 0 */
16F8:
	func_14EC(); /* always returns 0 */
	40 82 2B           CALL    $2B82
	func_1707(); /* always returns 0 */
	return 0;

16FD:
	func_1B02(); /* always returns 0 */
	if (!(VV[0x02] & 0x80)) {
		func_1707(); /* always returns 0 */
		return 0;
	}
	goto 16F8;
	func_1B02(); /* always returns 0 */
	40 6F 2B           CALL    $2B6F
	func_14EC(); /* always returns 0 */
	func_1707(); /* always returns 0 */
	return 0;

/* always returns 0 */
/* 1707 */
void func_1707(void)
{
	if (!(VV[0x11] & 0x01))
		func_170B(); /* always returns 0 */
	return 0;
}
/* always returns 0 */
/* 170B */
void func_170B(void)
{
	HL = [0x9905];
	func_170F(); /* always returns 0 */
	return 0;
}
/* always returns 0 */
/* 170F */
void func_170F(void)
{
	[0x9901] = HL;
	[0x9903] = HL;
	return 0;
}

	if (!func_1325())
		goto 1721;
	if (!(VV[0x00] & 0x08)) /* 0000 1000 */
		func_1B05(); /* always returns 0 */
	VV[0x00] |= 0x08; /* 0000 1000 */
	return 0;
1721:
	if (VV[0x00] & 0x08) /* 0000 1000 */
		func_1B05(); /* always returns 0 */
	VV[0x00] &= 0xF7; /* 1111 0111 */
	return 0;

1729: 5B 02              BIT     3,VV:02
172B: return 0;
172C: VV[0x02] &= 0xFB;
172F: return 0;
1730: func_1334(); /* always returns 0 */
1731: 37 0D              LTI     A,$0D
1733: return 0;
1734: VV[0x0C] = A;
1736: return 0;
1737: func_1334(); /* always returns 0 */
1738: 37 56              LTI     A,$56
173A: return 0;
173B: B = 0x03;
173D: EA = A * B;
173F: A = EAL;
1740: VV[0x2C] = A;
1742: return 0;
1743: A = 0x1B;
1745: A = 0x15;
1747: A = 0x24;
1749: goto 1740
174A: 8E                 CALT    ($009C)
174B: goto 1740
174C: VV[0x01] |= 0x04; /* 0000 0100 */
174F: return 0;
1750: VV[0x01] &= 0xFB; /* 1111 1011 */
1753: return 0;
1754: func_1B05(); /* always returns 0 */
1755: 8E                 CALT    ($009C)
1756: BC = 0x0000;
1759: C = A;
175A: goto 2B88;
175D: func_1334(); /* always returns 0 */
175E: 67 30              NEI     A,$30
1760: goto 1768
1761: 77 34              EQI     A,$34
1763: return 0;
1764: VV[0x02] |= 0x20
1767: return 0;
1768: VV[0x02] &= 0xDF;
176B: return 0;
176C: func_1334(); /* always returns 0 */
176D: B = [0x982C];
	if (print_this_char != 0x00)
		goto 177B;
1775: 8E                 CALT    ($009C)
1776: 37 17              LTI     A,$17
1778: return 0;
1779: B = 0xD8;
177B: EA = A * B;
177D: HL = 0x0000;
	if (EA == HL)
		return 0;
1783: func_32F3(); /* always returns 0 */
1786: [HL] = EA;
1788: HL = 0x9931;
178B: EA = [HL];
178D: HL = 0x992F;
1790: [HL] = EA;
1792: HL = 0x0000;
1795: [0x992B] = HL;
1799: [0x9907] = HL;
179D: VV[0x0D] = 0x00;
17A0: return 0;
17A1: func_1334(); /* always returns 0 */
17A2: 67 00              NEI     A,$00
17A4: return 0;
17A5: B = A;
17A6: A = VV[0x2C];
17A8: EA = A * B;
17AA: BC = EA;
17AB: HL = 0x9931;
17AE: EA = [HL];
17B0: 74 FD              DEQ     EA,BC
17B2: 74 B5              DSUBNB  EA,BC
17B4: return 0;
17B5: goto 17B9
17B6: EA = [0xFFFF];
17B9: HL = 0x992F;
17BC: [HL] = EA;
17BE: return 0;
17BF: func_1334(); /* always returns 0 */
17C0: 37 08              LTI     A,$08
17C2: return 0;
17C3: VV[0x03] |= 0x20; /* 0010 0000 */
17C6: VV[0x0E] = A;
17C8: return 0;
17C9: A = 0x00;
17CB: goto 17DE
17CC: VV[0x03] |= 0x30; /* 0011 0000 */
17CF: 97                 CALT    ($00AE)
17D0: HL = 0x9857;
17D3: [HL++] = EA;
17D5: BC = [0x0020];
17D8: goto 17FA
17DA: func_1334(); /* always returns 0 */
17DB: 37 08              LTI     A,$08
17DD: return 0;
17DE: B = 0x11;
17E0: EA = A * B;
17E2: VV[0x03] |= 0x20; /* 0010 0000 */
17E5: bitmask(A); /* always returns 0 */
17E8: A |= VV[0x0d];
17EB: VV[0x0D] = A;
17ED: HL = 0x9879;
17F0: EA += HL;
17F2: HL = EA;
17F3: A = VV[0x2C];
17F5: 3D                 STAX    (HL+)
17F6: C = 0x10;
17F8: B = 0x00;
17FA: push(BC);
17FB: push(HL);
17FC: 8E                 CALT    ($009C)
17FD: HL = pop();
17FE: BC = pop();
17FF: 53                 DCR     C
1800: goto 1802
1801: goto 1811
1802: 67 00              NEI     A,$00
1804: goto 180B
1805: 60 AA              GTA     A,B
1807: goto 180B
1808: 3D                 STAX    (HL+)
1809: B = A;
180A: goto 17FA
180B: 4B 00              MVIX    HL,$00
180D: return 0;
180E: push(BC);
180F: 8E                 CALT    ($009C)
1810: BC = pop();
1811: 67 00              NEI     A,$00
1813: return 0;
1814: 60 AA              GTA     A,B
1816: return 0;

1817: B = A;
1818: goto 180E
1819:
	if (!func_1325())
		goto 1832;
181B: func_1334(); /* always returns 0 */
181C: B = A;
181D: A = VV[0x2C];
181F: EA = A * B;
1821: BC = EA;
1822: func_32F3(); /* always returns 0 */
1825: EA = [HL];
1827: 74 AD              DGT     EA,BC
1829: return 0;
182A: [0x9907] = BC;
182E: VV[0x03] &= 0xDF; /* 1101 1111 */
1831: return 0;
1832: func_1334(); /* always returns 0 */
1833: push(VA);
1834: 97                 CALT    ($00AE)
1835: VA = pop();
1836: EA = mul24(EA, A);
1837: BC = EA;
1838: DE = [0x011F];
183B: 74 AE              DGT     EA,DE
183D: return 0;
183E: DE = [0x0BF5];
1841: 74 BE              DLT     EA,DE
1843: return 0;
1844: [0x9909] = BC;
1848: VV[0x03] &= 0xDF; /* 1101 1111 */
184B: VV[0x03] |= 0x10; /* 0001 0000 */
184E: return 0;
184F:
	if (!func_1325())
		goto 1862;
1851: func_1B05(); /* always returns 0 */
1852: func_1334(); /* always returns 0 */
1853: B = A;
1854: A = VV[0x2C];
1856: EA = A * B;
1858: BC = 0x0000;
	if (EA == BC)
		return 0;
185E: BC = EA;
185F: goto 2B88;
1862: 55 05 80           OFFIW   VV:05,$80
1865: return 0;
1866: func_1334(); /* always returns 0 */
1867: 67 00              NEI     A,$00
1869: return 0;
186A: push(VA);
186B: func_1B05(); /* always returns 0 */
186C: 97                 CALT    ($00AE)
186D: VA = pop();
186E: EA = mul24(EA, A);
186F: DE = [0x9901];
1873: EA += DE;
1875: DE = [0x993D];
1879: 74 BE              DLT     EA,DE
187B: goto 16F7;
187E: HL = EA;
187F: goto 170F;
1882: 97                 CALT    ($00AE)
1883: push(EA);
1884: 8E                 CALT    ($009C)
1885: EA = pop();
1886: EA = mul24(EA, A);
1887: 48 1A              SKN     CY
1889: return 0;
188A: HL = EA;
188B: return 1;
188C: 55 05 80           OFFIW   VV:05,$80
188F: return 0;
1890: 5C 03              BIT     4,VV:03
1892: goto 18E8
1894: 5D 03              BIT     5,VV:03
1896: goto 18C5
1898: HL = 0x9857;
189B: B = 0x01;
189D: 42                 INR     B
189E: 74 3A 23           LTI     B,$23
18A1: return 0;
18A2: AD                 LDAX    (HL+B)
18A3: 67 00              NEI     A,$00
18A5: return 0;
18A6: push(BC);
18A7: EA = [HL];
18A9: EA = mul24(EA, A);
18AA: BC = pop();
18AB: 48 1A              SKN     CY
18AD: return 0;
18AE: DE = [0x9905];
18B2: EA += DE;
18B4: DE = [0x993D];
18B8: 74 BE              DLT     EA,DE
18BA: return 0;
18BB: DE = [0x9901];
18BF: 74 AE              DGT     EA,DE
18C1: goto 189D
18C3: goto 18EE
18C5: BC = [0x9909];
18C9: EA = 0x0000;
18CC: 74 ED              DNE     EA,BC
18CE: return 0;
18CF: HL = 0x9905;
18D2: EA = [HL];
18D4: EA += BC;
18D6: DE = [0x993D];
18DA: DE++;
18DB: 74 BE              DLT     EA,DE
18DD: goto 16F7
18E0: DE = [0x9901];
18E4: 74 AE              DGT     EA,DE
18E6: goto 18D4
18E7: goto 18EE
18E8: 97                 CALT    ($00AE)
18E9: A = 0x08;
18EB: EA = mul24(EA, A);
18EC: BC = EA;
18ED: goto 18CF
18EE: VV[0x03] &= 0x7F; /* 0111 1111 */
18F1: HL = EA;
18F2: BC = [0x9903];
18F6: EA = BC;
18F7: 74 EE              DNE     EA,DE
18F9: goto 1909
18FA: EA = HL;
18FB: EA -= DE;
18FD: DE = EA;
18FE: [0x993B] = DE;
1902: 40 0B 19           CALL    $190B
1905: return 0;
1906: push(HL);
1907: func_1B05(); /* always returns 0 */
1908: HL = pop();
1909: func_170F(); /* always returns 0 */
190A: return 0;
190B: 5E 07              BIT     6,VV:07
190D: goto 191A
190E: EA = DE;
190F: A = 0x10;
1911: EA = EA / A, A = EA % A; /* simultaneously */
1913: 67 00              NEI     A,$00
1915: goto 1929
1916:
	if (VV[0x11] & 0x20)
		return 1;
191A: EA = DE;
191B: 5A 09              BIT     2,VV:09
191D: A = 0x0C;
191F: A = 0x06;
1921: EA = EA / A, A = EA % A; /* simultaneously */
1923: 77 00              EQI     A,$00
1925: return 1;
1926: VV[0x07] &= 0xBF;
1929: goto 2291;
192C: func_1B02(); /* always returns 0 */
192D: func_14EC(); /* always returns 0 */
192E: func_170B(); /* always returns 0 */
1931: 5D 03              BIT     5,VV:03
1933: goto 1979
1935: A = VV[0x0E];
1937: bitmask(A); /* always returns 0 */
193A: 74 C8 0D           ONAW    VV:0D
193D: goto 1983
193F: A = VV[0x0E];
1941: B = 0x11;
1943: EA = A * B;
1945: HL = 0x9879;
1948: EA += HL;
194A: HL = EA;
194B: DE = [0x992B];
194F: A = [HL++];
1950: B = A;
1951: C = 0x10;
1953: 53                 DCR     C
1954: goto 1956
1955: goto 1970
1956: A = [HL++];
1957: 67 00              NEI     A,$00
1959: goto 1970
195A: EA = A * B;
195C: 74 AE              DGT     EA,DE
195E: goto 1953
	if (!func_32EC())
		goto 196A;
1963: BC = [0x992F];
1967: 74 BD              DLT     EA,BC
1969: goto 1976
196A: EA -= DE;
196C: BC = EA;
196D: goto 2B88;
1970: 74 6B 0F           NEI     C,$0F
1973: goto 16FD;
1976: goto 2B6F;
1979: BC = [0x9907];
197D: EA = BC;
197E: BC = 0x0000;
1981: 74 ED              DNE     EA,BC
1983: goto 2B82;
1986: BC = EA;
1987: push(EA);
1988: func_32F3(); /* always returns 0 */
198B: EA = [HL];
198D: DE = EA;
198E: EA = pop();
198F: 74 BE              DLT     EA,DE
1991: goto 1976
1992: DE = [0x992B];
1996: 74 EE              DNE     EA,DE
1998: goto 199D
1999: 74 BE              DLT     EA,DE
199B: goto 196A
199D: EA += BC;
199F: goto 1987

/* always returns 0 */
/* 19A0 */
void clear_0xff00_0xff48(void)
{
	clear_5_lines(0xFF00, 12); /* always returns 0 */
	clear_5_lines(0xFF48, 29); /* always returns 0 */
	return 0;
}

19B1: func_1B05(); /* always returns 0 */
19B2: func_1334(); /* always returns 0 */
19B3: push(VA);
19B4: func_1334(); /* always returns 0 */
19B5: push(VA);
19B6: func_1334(); /* always returns 0 */
19B7: C = A;
19B8: VA = pop();
19B9: B = A;
19BA: VA = pop();
19BB: 51                 DCR     A
19BC: return 0;
19BD: 53                 DCR     C
19BE: return 0;
19BF: 74 3A 02           LTI     B,$02
19C2: return 0;
19C3: VV[0x04] &= 0xF7; /* 1111 0111 */
19C6: 74 6A 01           NEI     B,$01
19C9: VV[0x04] |= 0x08; /* 0000 1000 */
19CC: 59 09              BIT     1,VV:09
19CE: A = 0x0C;
19D0: A = 0x1D;
19D2: B = A;
19D3: 59 09              BIT     1,VV:09
19D5: HL = 0xFF00;
19D8: HL = 0xFF48;
19DB: A = 0xFF;

/* always returns 0 */
/* 19DD */
void clear_5_lines(uint16_t HL, int stride)
{
	[HL + 0 * stride] = 0x00;
	[HL + 1 * stride] = 0x00;
	[HL + 2 * stride] = 0x00;
	[HL + 3 * stride] = 0x00;
	[HL + 4 * stride] = 0x00;
	return 0;
}

19E9:
	if (!func_1325())
		goto 19EF;
19EB: VV[0x04] |= 0x80; /* 1000 0000 */
19EE: return 0;
19EF: VV[0x04] &= 0x7F; /* 0111 1111 */
19F2: return 0;
19F3: func_1B05(); /* always returns 0 */
19F4: func_1334(); /* always returns 0 */
19F5: push(VA);
19F6: 8E                 CALT    ($009C)
19F7: push(VA);
19F8: 8E                 CALT    ($009C)
19F9: C = A;
19FA: VA = pop();
19FB: B = A;
19FC: VA = pop();
19FD: 77 00              EQI     A,$00
19FF: return 0;
1A00: A = C;
1A01: 74 32 3A           SUINB   B,$3A
1A04: goto 1A1F
1A05: 37 40              LTI     A,$40
1A07: goto 1A1F
1A08: 36 3A              SUINB   A,$3A
1A0A: goto 1A1D
1A0B: 60 B2              SUBNB   A,B
1A0D: return 0;
1A0E: C = A;
1A0F: push(BC);
1A10: 59 09              BIT     1,VV:09
1A12: 40 42 1A           CALL    $1A42
1A15: 40 58 1A           CALL    $1A58
1A18: BC = pop();
1A19: 42                 INR     B
1A1A: 53                 DCR     C
1A1B: goto 1A0F
1A1C: return 0;
1A1D: A += 0x3A;
1A1F: B += 0x3A;
1A22: 60 B2              SUBNB   A,B
1A24: return 0;
1A25: 59 09              BIT     1,VV:09
1A27: goto 1A3A
1A28: C = A;
1A29: push(BC);
1A2A: 8E                 CALT    ($009C)
1A2B: 8E                 CALT    ($009C)
1A2C: push(VA);
1A2D: 8E                 CALT    ($009C)
1A2E: VA = pop();
1A2F: B = 0x03;
1A31: EA = A * B;
1A33: func_119B(); /* always returns 0 */
1A36: BC = pop();
1A37: 53                 DCR     C
1A38: goto 1A29
1A39: return 0;
1A3A: 41                 INR     A
1A3B: B = 0x0C;
1A3D: EA = A * B;
1A3F:
	func_119B(); /* always returns 0 */
	return 0;
1A42: func_1AC2(); /* always returns 0 */
1A45: push(HL);
1A46: 8E                 CALT    ($009C)
1A47: A &= 0x80;
1A49: A |= 0x0B;
1A4B: HL = pop();
1A4C: 3D                 STAX    (HL+)
1A4D: C = 0x0A;
1A4F: push(HL);
1A50: push(BC);
1A51: 8E                 CALT    ($009C)
1A52: BC = pop();
1A53: HL = pop();
1A54: 3D                 STAX    (HL+)
1A55: 53                 DCR     C
1A56: goto 1A4F
1A57: return 1;
1A58: func_1AC2(); /* always returns 0 */
1A5B: push(HL);
1A5C: 8E                 CALT    ($009C)
1A5D: 8E                 CALT    ($009C)
1A5E: push(VA);
1A5F: 8E                 CALT    ($009C)
1A60: VA = pop();
1A61: HL = pop();
1A62: 67 00              NEI     A,$00
1A64: return 0;
1A65: 37 0C              LTI     A,$0C
1A67: A = 0x0C;
1A69: 3D                 STAX    (HL+)
1A6A: push(HL);
1A6B: HL++;
1A6C: HL++;
1A6D: C = A;
1A6E: B = 0x10;
1A70: 60 62              SUB     B,A
1A72: goto 1AA0
1A74: push(BC);
1A75: push(HL);
1A76: 8E                 CALT    ($009C)
1A77: EAH = A;
1A78: push(EA);
1A79: 8E                 CALT    ($009C)
1A7A: EA = pop();
1A7B: EAL = A;
1A7C: C = 0x07;
1A7E: EA <<= 1;
1A80: 48 35              RLL     A
1A82: EA <<= 1;
1A84: 48 36              RLL     B
1A86: 53                 DCR     C
1A87: goto 1A7E
1A88: HL = pop();
1A89: 3D                 STAX    (HL+)
1A8A: A = B;
1A8B: BF 0D              STAX    (HL+$0D)
1A8D: push(HL);
1A8E: 8E                 CALT    ($009C)
1A8F: HL = 0x994D;
1A92: C = 0x01;
1A94: EA = [HL];
1A96: 48 25              SLL     A
1A98: 48 B4              DRLL    EA
1A9A: [HL++] = EA;
1A9C: 53                 DCR     C
1A9D: goto 1A94
1A9E: HL = pop();
1A9F: BC = pop();
1AA0: 53                 DCR     C
1AA1: goto 1A74
1AA3: DE = pop();
1AA4: push(BC);
1AA5: HL = 0x994D;
1AA8: EA = [HL++];
1AAA: goto 1AAD
1AAB: EA <<= 1;
1AAD: 52                 DCR     B
1AAE: goto 1AAB
1AAF: A = EAH;
1AB0: [DE++] = A;
1AB1: A = EAL;
1AB2: [DE++] = A;
1AB3: BC = pop();
1AB4: EA = [HL];
1AB6: goto 1AB9
1AB7: EA <<= 1;
1AB9: 52                 DCR     B
1ABA: goto 1AB7
1ABB: A = EAH;
1ABC: BB 0C              STAX    (DE+$0C)
1ABE: A = EAL;
1ABF: BB 0D              STAX    (DE+$0D)
1AC1: return 0;

/* always returns 0 */
void func_1AC2(void)
{
	if (VV[0x09] & 0x02) {
		A  = 0x1D;
		HL = 0xFF48;
	} else {
		A  = 0x0C;
		HL = 0xFF00;
	}
	EA = A * B;
	EA += HL;
	HL = EA;
	return 0;
}

/* 1AD6 */
int func_1AD6(void)
{
	B = [0x9815];
	if (!(VV[0x04] & 0x80))
		return 0;
	if (B < 0x3A || B >= 0x40)
		return 0;
	B -= 0x3a;
	func_1AC2(); /* always returns 0 */
	A = [HL];
	if (A == 0xFF) {
		VV[0x08] &= 0xFE;
		if (VV[0x04] & 0x08)
			VV[0x08] |= 0x01;
	} else {
		VV[0x09] &= 0x7F;
		if (A != 0x00)
			return 1;
		print_this_char = ' ';
	}
	return 0;
}
/* always returns 0 */
/* 1B02 */
void func_1B02(void)
{
	VV[0x05] |= 0x04;
	func_1B05();
	return 0;
}

/* always returns 0 */
/* 1B05 */
void func_1B05(void)
{
	HL = [0x9939];
	EA = 0x9a79;
	if (HL <= EA)
		goto 1BB8;
	func_1F0C(); /* always returns 0 */
	if (!(VV[0x06] & 0x80)) {
		VV[0x06] &= 0xef; /* 1110 1111 */
		if (!(VV[0x06] & 0x40))
			VV[0x06] |= 0x10; /* 0001 0000 */
	}
	func_304E(); /* always returns 0 */
	func_1FAE(); /* always returns 0 */
	func_1BBC(); /* always returns 0 */
	VV[FLAGS_1] &= 0xAF; /* 1010 1111 */
	VV[FLAGS_1] |= 0x01; /* 0000 0001 */
	VV[0x2A] = 0x10;
	VV[0x2B] = 0x00;
	if (!func_1C93())
		goto 1B99;
	40 68 2B           CALL    $2B68
	40 13 2C           CALL    $2C13
	func_7BD5(); /* always returns 0 */
	VV[0x13] |= 0x02;
	func_1ED9(); /* always returns 0 */
	VV[FLAGS_1] &= 0xFE; /* 1111 1110 */
	if (!(VV[0x11] & 0x08))
		goto 1B60;
	VV[FLAGS_1] |= 0x40; /* 0100 0000 */
	VV[0x2A] = 0x20;
	VV[0x2B] = 0x00;
	if (!func_1C93())
		goto 1B60;
	BC = 0x0001;
	func_2EA6(); /* always returns 0 */
	func_1ED9(); /* always returns 0 */
1B60:
	if (!(VV[0x11] & 0x10))
		goto 1B99;
	VV[FLAGS_1] |= 0x10; /* 0001 0000 */
	VV[FLAGS_1] &= 0xBF; /* 1011 1111 */
	VV[0x2A] = 0x00;
	VV[0x2B] = 0x10;
	if (!func_1C93())
		goto 1B99;
	BC = 0x000C;
	if (VV[0x26] != 0x00)
		BC = 0x000B;
	func_2EA6(); /* always returns 0 */
	func_1ED9(); /* always returns 0 */
	if (!(VV[0x11] & 0x08))
		goto 1B99;
	VV[FLAGS_1] |= 0x40; /* 0100 0000 */
	VV[0x2A] = 0x20;
	VV[0x2B] = 0x10;
	if (!func_1C93())
		goto 1B99;
	BC = 0x0001;
	func_2EA6(); /* always returns 0 */
	func_1ED9(); /* always returns 0 */
1B99:
	55 05 08           OFFIW   VV:05,$08
	goto 1BAF
	if (!(VV[0x05] & 0x30) || !(VV[0x05] & 0x04))
		goto 1BB4;
	HL = [0x9901];
	EA = HL;
	HL = [0x9903];
	if (EA == HL)
		goto 1BB4;
1BAF:
	HL = [0x993D];
	func_170F(); /* always returns 0 */
1BB4:
	func_216F(); /* always returns 0 */
	VV[0x06] |= 0x10; /* 0001 0000 */
1BB8:
	VV[0x05] &= 0xFB;
	return 0;
}
/* always returns 0 */
/* 1BBC */
void func_1BBC(void)
{
	VV[0x05] &= 0xF7; /* 1111 0111 */
	VV[0x11] &= 0xFE; /* 1111 1110 */
	if (VV[0x05] & 0x30) {
		if (!(VV[0x05] & 0x04))
			return 0;
		func_1D79(); /* always returns 0 */
		if (!(VV[0x05] & 0x20))
			EA >>= 1;
		DE = EA;
		HL = 0x9903;
		EA = [HL];
		EA += DE;
		[HL] = EA;
		HL = 0x9901;
		EA = [HL];
		EA += DE;
		[HL] = EA;
		return 0;
	}
	if (!(VV[0x05] & 0x80))
		return 0;
	if (VV[0x05] & 0x02)
		return 0;
	if ((VV[0x03] & DATA_DUMP_MODE) || (VV[0x33] == 0x00))
		return 0;
	VV[0x05] &= 0xBF;
	if (VV[0x11] & 0x04)
		goto 1BF9;
	if (!func_1D79())
		goto 1C00;
	EA <<= 1;
	BC = EA;
	HL = [0x993D];
	EA = HL;
	HL = [0x9903];
	EA -= HL;
	74 B5              DSUBNB  EA,BC
	return 0;
	BC++;
	74 B5              DSUBNB  EA,BC
	return 0;
	VV[0x05] |= 0x40
1BF9:
	func_1C2A(); /* always returns 0 */
	if (VV[0x33] == 0x00)
		return 0;
1C00:
	func_1D79(); /* always returns 0 */
	HL = [0x9947];
	EA += HL;
	A = VV[0x25];
	EA = EA / A, A = EA % A; /* simultaneously */
	push(EA);
	HL = [0x993D];
	EA = HL;
	EA -= A;
	HL = EA;
	[0x9901] = HL;
	EA = pop();
	[0x9953] = EA / VV[0x33];
	VV[0x34] = EA % VV[0x33];
	VV[0x05] |= 0x08
	return 0;
}
/* always returns 0 */
/* 1C2A */
void func_1C2A(void)
{
	HL = [0x9939];
	[0x9951] = HL;
	do {
		HL -= 3;
		A = [HL];
		EA = [HL + 1];
		BC = EA;
		func_22C9(); /* always returns 0 */
		BC = EA;
		DE = 0x9901;
		EA = [DE];
		EA -= BC;
		[DE] = EA;
		A = [HL];
		if (A == 0x20) {
			VV[0x05] |= 0x40;
			DE = 0x9947;
			EA = [DE];
			EA -= BC;
			[DE] = EA;
		} else {
			if (VV[0x05] & 0x40)
				break;
			VV[0x11] |= 0x01;
		}
	} while (VV[0x33]--);
	HL += 3;
	[0x9939] = HL;
	DE = 0x9901;
	EA = [DE];
	EA += BC;
	[DE] = EA;
	return 0;
}

/* 1C93 */
int func_1C93(void)
{
	HL = 0x9833;
	EA = [HL++];
	[HL] = EA;
	if (!func_1CB1())
		return 0;
	func_1CDC(); /* always returns 0 */
	if (!(VV[0x07] & 0x40)) {
		B = 0x48;
		HL = 0x990D;
		EA = [HL];
		EA += B;
		[HL] = EA;
	}
	return 1;
}

/* 1CB1 */
int func_1CB1(void)
}
	BC = [0x9903];
	HL = 0x9A79;
	DE = [0x9939];
	while (1) {
		[0x990B] = BC
		[0x9933] = HL;
		EA = HL;
		if (DE <= EA)
			return 0;
		if (!func_1D00())
			return 1;
		push(DE);
		func_1D3E(); /* always returns 0 */
		DE = pop();
		BC = [0x990B];
		EA += BC;
		BC = EA;
		HL += 3;
	}
}

/* always returns 0 */
/* 1CDC */
void func_1CDC(void)
{
	BC = [0x9901];
	HL = [0x9939];
	while (1) {
		[0x990D] = BC;
		[0x9935] = HL;
		HL -= 3;
		if (!func_1D00())
			return 0;
		func_1D51(); /* always returns 0 */
		BC = [0x990D];
		DE = EA;
		EA = BC;
		EA -= DE;
		BC = EA;
	}
}

/* 1D00 */
int func_1D00(void)
{
	BC = [0x982A];
	EA = [HL + 1];
	if (!(VV[0x10] & 0x01)) {
		EA &= BC;
		if (EA != BC)
			return 1;
	} else {
		if (EA & BC)
			return 0;
	}
	A = [HL+0x02];
	if (A & 0x01)
		return 1;
	A = [HL];
	if (A != 0x20)
		return 0;
	A = EAL;
	if (A & 0x10)
		return 0;
	return 1;
}

/* 1D21 */
int func_1D21(void)
{
	if (!(VV[0x05] & 0x08))
		return 0;
	A = [HL + 0x02];
	if (A & 0x01)
		return 0;
	A = [HL];
	if (A != 0x20)
		return 0;
	DE = [0x9945];
	EA = DE;
	if (HL <= EA)
		return 0;
	return 1;
}

/* always returns 0 */
/* 1D36 */
void func_1D36(void)
{
	A = [HL];
	EA = [HL + 1];
	BC = EA;
	func_22C9(); /* always returns 0 */
	return 0;
}
/* always returns 0 */
/* 1D3E */
void func_1D3E(void)
{
	if (!func_1D21()) {
		func_1D36(); /* always returns 0 */
		return 0;
	}
	BC = [0x9953];
	DE = [0x9836];
	EA = 0x0000;
	if (EA != DE)
		func_1D65(); /* always returns 0 */
	func_1D6B(); /* always returns 0 */
	return 0;
}
/* always returns 0 */
/* 1D51 */
void func_1D51(void)
{
	if (!func_1D21()) {
		func_1D36(); /* always returns 0 */
		return 0;
	}
	BC = [0x9953];
	DE = [0x9835];
	EA = DE;
	DE = [0x9836];
	if (EA == DE)
		func_1D65(); /* always returns 0 */
	func_1D6B(); /* always returns 0 */
	return 0;
}

/* always returns 0 */
/* 1D65 */
void func_1D65(void)
{
	DE--;
	[0x9836] = DE;
	BC++;
	return 0;
}
/* always returns 0 */
/* 1D6B */
void func_1D6B(void)
{
	A = VV[0x25];
	EA = BC;
	EA = mul24(EA, A);
	DE = [0x9835];
	DE--;
	[0x9835] = DE;
	return 0;
}
/* always returns 0 */
/* 1D79 */
int func_1D79(void)
{
	int r;
	HL = [0x993D];
	EA = HL;
	HL = [0x9901];
	r = (EA < HL);
	EA -= HL;
	return r;
}

/* 1D85 */
etimer_2:
	[0xC005] = [0x9925]; /* fires all pins of the printhead. */
	EOM = 0x07;
	A = CR1;
	EA = 0x0000 | A;
	EA <<= 1;
	if (A >= 0xDB) {
		if (A >= 0xFB)
			beep_and_hang(5, 1); /* HANG, never returns */
		BC = EA;
		EA = 0x035E;
	} else {
		EA += A;
		BC = EA;
		EA = 0x0434;
	}
	EA -= BC;
	BC = EA;
	EA = ECNT;
	EA += BC;
	BC = [0x9923];
	if (EA >= BC)
		EA -= BC;
	ETM0 = EA;
	if (VV[0x10] & 0x20) {
		ETM1 = [0x9923];
		skit(FE1);
		VV[FLAGS_1] &= 0xDF; /* 1101 1111 */
	}
	exx();
	exa();
	enable_interrupts();
	push(EA);
	push(HL);
	push(VA);
	push(BC);
	push(DE);
	if (!func_2322())
		func_1E46(); /* always returns 0 */
	func_1E5E(); /* always returns 0 */
	DE = pop();
	BC = pop();
	VA = pop();
	HL = pop();
	EA = pop();
	return; /* FROM INTERRUPT */

/* 1DE3 */
etimer_3:
	[0xC005] = [0x9925]; /* fires all pins of the printhead. */
	EOM = 0x07;
	A = CR1;
	EA = 0x0000 | A;
	EA <<= 1;
	if (A >= 0xDB) {
		if (A >= 0xFB)
			beep_and_hang(5, 1); /* HANG, never returns */
		BC = EA;
		EA = 0x0339;
	} else {
		if (A <= 0xD0)
			EA = 0x01A0;
		EA += A;
		BC = EA;
		EA = 0x0410;
	}
	EA -= BC;
	BC = EA;
	EA = ECNT;
	EA += BC;
	BC = [0x9923];
	if (EA >= BC)
		EA -= BC;
	ETM0 = EA;
	if (VV[0x10] & 0x20) {
		ETM1 = [0x9923];
		skit(FE1);
		VV[FLAGS_1] &= 0xDF; /* 1101 1111 */
	}
	exx();
	exa();
	enable_interrupts();
	push(EA);
	push(HL);
	push(VA);
	push(BC);
	push(DE);
	if (!func_2322())
		func_1E46(); /* always returns 0 */
	func_1E5E(); /* always returns 0 */
	DE = pop();
	BC = pop();
	VA = pop();
	HL = pop();
	EA = pop();
	return; /* FROM INTERRUPT */

/* always returns 0 */
/* 1E46 */
void func_1E46(void)
{
	MKL |= 0x40; /* 0100 0000 */ /* mask INTE1 */
	skit(FE0);
	MKL &= 0xdf; /* 1101 1111 */ /* activate INTE0 */
	etimer_func = etimer_1;
	timer1_func = timer1_2;
	return 0;
}
/* always returns 0 */
/* 1E5E */
void func_1E5E(void)
{
	if ((!VV[0x10] & 0x02) || VV[0x29]--)
		return 0;
	VV[0x29] = 0x02;
	EA = [0x9923];
	if (!(VV[0x10] & 0x80)) {
		EA--;
	} else {
		EA++;
		if (!(VV[0x12] & 0x40))
			EA++;
	}
	ETM1 = EA;
	return 0;
}
/* 1E78 */
void __attribute__((interrupt)) etimer_1(void)
{
	MKL |= 0x20; /* 0010 0000 */ /* mask INTE0 */
	EOM = 0x99;
	[0xC005] = 0x0000; /* clears all pins of the printhead. */
	VV[FLAGS_1] &= 0x7D; /* 0111 1101 */
	VV[0x0F] &= 0xFD; /* 1111 1101 */
	exx();
	exa();
	enable_interrupts();
	return; /* FROM INTERRUPT */
}

/* always returns 0 */
/* 1ED9 */
void func_1ED9(void)
{
	func_1F11(); /* always returns 0 */
	[0x995D] = 0x9000;
	[0x995F] = 0x9000;
	[0x9925] = 0x0000;
	if (VV[0x00] & 0x04) /* 0000 0100 */
		func_2AD2(); /* always returns 0 */
	if (VV[0x09] & 0x02) A = 0x1E;
	else                 A = 0x00;
	VV[0x3E] = A;
	92                 CALT    ($00A4)
	func_1F2D(); /* always returns 0 */
	while (func_234C());
	if (!(VV[0x00] & 0x04)) /* 0000 0100 */
		func_2AD2(); /* always returns 0 */
	return 0;
}
/* always returns 0 */
/* 1F0C */
void func_1F0C(void)
{
	while (VV[0x0f] & 0x02) /* 0000 0010 */
		check_gate_array_input(); /* always returns 0 */
	return 0;
}
/* always returns 0 */
/* 1F11 */
void func_1F11(void)
{
	HL = [0x9933];
	if (VV[0x00] & 0x04) { /* 0000 0100 */
		EA = [0x9935];
		HL -= 3;
		[0x9935] = HL;
		HL = EA - 3;
	}
	[0x9937] = HL;
	return 0;
}
/* always returns 0 */
/* 1F2D */
void func_1F2D(void)
{
	func_1F75(); /* always returns 0 */
	if (!(VV[0x00] & 0x04)) /* 0000 0100 */
		goto 1F49;
	HL = [0x990D];
	EA = HL;
	EA -= A;
	A = 0x18;
	EA = EA / A, A = EA % A; /* simultaneously */
	EA = [0x0018];
	77 00              EQI     A,$00
	EA <<= 1;
	EA -= A;
	BC = EA;
	goto 1F57
1F49:
	HL = [0x990B];
	EA = HL;
	EA += A;
	C = 0x18;
	48 3F              DIV     C
	C += 0x18;
1F57:
	40 93 1F           CALL    $1F93
	EA = A * C;
	HL = 0x9927;
	[HL] = EA;
	VV[0x29] = 0x02;
	5F 12              BIT     7,VV:12
	goto 1F6E
	55 12 20           OFFIW   VV:12,$20
	VV[FLAGS_1] |= 0x02; /* 0000 0010 */
	goto 1F74
1F6E:
	55 07 40           OFFIW   VV:07,$40
	VV[FLAGS_1] |= 0x02; /* 0000 0010 */
1F74:
	return 0;
}

/* always returns 0 */
void func_1F75(void)
{
	if (VV[0x00] & CR_IS_HOME) HL = 0x9850; /* 0000 0010 */
	else                       HL = 0x1F89;
	A = [HL+[9820]];
	if (VV[0x00] & 0x04) /* 0000 0100 */
		A += VV[0x25];
	return 0;
}

1F89: DW: 0A 01 10 0A 01 2D 20 39 2D 20 34 9A 1F 01 20 AC
1F99: DW: B8 39 73 24 2B 56

int func_1F9F(void)
{
	if (func_234C())
		return 1;
	if (VV[0x40] & 0x40)
		return 1;
	if (!VV[0x3e]--)
		return 0;
	VV[0x3e] = 0x00;
	return 1;
}

/* always returns 0 */
/* 1FAE */
void func_1FAE(void)
{
	if (VV[0x06] & 0x10) {
		if ((VV[0x09] & 0x02) || (VV[0x09] & 0x04))      HL = 0x201f;
		else if (VV[0x07] & 0x40)                        HL = 0x2013;
		else if ((VV[0x07] & 0x20) || (VV[0x08] & 0x04)) HL = 0x2017;
		else                                             HL = 0x201b;
	}
	else if ((VV[0x09] & 0x02) || VV[0x09] & 0x04)   HL = 0x200f;
	else if (VV[0x07] & 0x40)                        HL = 0x2013;
	else if ((VV[0x07] & 0x20) || (VV[0x08] & 0x04)) HL = 0x200b;
	else                                             HL = 0x2007;

	uint8_t u1 = [HL++];

	VV[0x20] = u1 & 0x7f; /* 0111 1111 */
	VV[0x25] = [HL++];
	[0x9923] = (uint16_t) [HL];

	if (u1 & 0x80) A = [0xC006];
	else           A = [0xC005];

	return 0;
}

2007: DW: 80 0C B0 02
200B: DW: 01 0C 60 05
200F: DW: 81 06 B0 02
2013: DW: 82 10 40 02
2017: DW: 04 0C 00 04
201B: DW: 83 0C 00 02
201F: DW: 84 06 00 02

/* always returns 0 */
/* 2023 */
void reset_data_buffer(void)
{
	data_buffer_wptr = 0x8000;
	data_buffer_rptr = 0x8000;
	data_buffer_size = 0x1000;
	return 0;
}
/* always returns 0 */
/* 2033 */
void configure_serial(void)
{
	if (!(VV[0x11] & COMM_SERIAL))
		return 0;
	while ((A = [0xC001]) != [0xC001]);

	C = 0x4E; /* 0100 1110 */ /* 1 stop bit, x16 */
	if (!(A & 0x01)) C &= 0xfb; /* 1111 1011 */ /* 7 bits */
	if (!(A & 0x10)) C |= 0x10; /* 0001 0000 */ /* parity enable */
	if (!(A & 0x08)) C |= 0x20; /* 0010 0000 */ /* parity even */

	A &= 0x66; /* 0110 0110 */ /* A = x12x x56x */
	A >>= 1; /* A = xx12 xx56 */
	B = A; /* B = xx12 xx56 */
	A &= 0x03;	/* 0000 0011 */ /* A = xxxx xx56 */
	B >>= 2; /* B = xxxx 12xx */
	A |= B; /* A = xxxx 1256 */

	if (A <= 0x03)
		C |= 0x01; /* x64 */
	TM0  = [0x2079+A];
	SML  = C;
	SMH  = 0x0C; /* 0000 1100 */
	TMM  = 0x93; /* 1001 0011 */ /* timer1 reset to 00 and stop counting, internal clock (12),
	                                timer0 reset to 00 and stop counting, internal clock (12),
	                                timer f/f input clock src: timer f/f reset */
	TMM &= 0xec; /* 1110 1100 */ /* timer f/f input clock src: when upcounter 0 equals tm0, timer0 count up */
	skit(ER);
	return 0;
}

2079: DW: 80 57 47 40 C0 80 40 20 15 10 08 04
2085: DW: 80 20 10 04 5F 11

/* unreal */
void data_buffer_fifo_put(uint8_t c)
{
	DE = data_buffer_wptr;
	[DE++] = c;
	rollover_DE_from_0x9000_to_0x8000(); /* always returns 0 */
	data_buffer_wptr = DE;
}
/* unreal */
uint8_t data_buffer_fifo_get(void)
{
	DE = data_buffer_rptr;
	A = [DE++];
	rollover_DE_from_0x9000_to_0x8000(); /* always returns 0 */
	data_buffer_rptr = DE;
	return A;
}

/* always returns 0 */
/* 2089 */
void check_gate_array_input(void)
{
	if ( (VV[0x11] & COMM_SERIAL)) return;
	if (!(VV[0x14] & 0x40)) return;
	if ( (VV[0x11] & 0x02)) return;
	if (!([0xC002] & 0x80)) return;

	disable_interrupts();
	EA = [0xC002];
	A  = [0xC004];
	[0xC004] = (A |=  C004_5); /* 0010 0000 */
	[0xC004] = (A &= ~C004_0); /* 1111 1110 */
	enable_interrupts();
	[0xC004] = (A &= ~C004_5); /* 1101 1111 */

	data_buffer_fifo_put(EAH);

	disable_interrupts();

	data_buffer_size--;

	if (data_buffer_size == 0x0000) {
		VV[0x11] |= DATA_BUFFER_FULL;
		[0xC004] &= ~C004_1; /* 1111 1101 */
	}
	enable_interrupts();
	return 0;
}

/* 20CE */
void __attribute__((interrupt)) irq_serial(void)
{
	uint8_t rxb = RXB;

	MKH |= 0x02; /* 0000 0010 */ /* mask INTSR */

	enable_interrupts();
	if (!(VV[0x11] & DATA_BUFFER_FULL) && !(IRR & INTER)) {
		/* INTER == serial parity or framing error */

		data_buffer_fifo_put(rxb);

		disable_interrupts();

		data_buffer_size--;
		if (data_buffer_size == 0x0000)
			VV[0x11] |= DATA_BUFFER_FULL;

		enable_interrupts();

		if (data_buffer_size == 0x0100) {
			VV[0x11] |= DONT_READ_DATA;
			[0xC004] |= C004_0; /* 0000 0001 */
			TXB = 0x13;
		}
	}

	MKH &= 0xfd; /* 1111 1101 */ /* activate INTSR */

	return; /* FROM INTERRUPT */
}

2112:
	40 A5 0E           CALL    $0EA5
	check_gate_array_input(); /* always returns 0 */

2116:
	if (func_2127())
		return 0;
	goto 2112;

/* 211B */
int data_buffer_empty(void)
{
	return (data_buffer_size == 0x1000);
}

/* 2127 */
int func_2127(void)
{
	MKH |= 0x02; /* 0000 0010 */ /* mask INTSR */

	if (data_buffer_empty()) {
		MKH &= 0xfd; /* 1111 1101 */ /* activate INTSR */
		return 0;
	}

	data_buffer_size++;
	VV[0x11] &= ~DATA_BUFFER_FULL;

	if (!(VV[0x11] & COMM_SERIAL))
		[0xC004] |= C004_1; /* 0000 0010 */

	print_this_char = data_buffer_fifo_get();

	MKH &= 0xfd; /* 1111 1101 */ /* activate INTSR */

	if ((VV[0x11] & DONT_READ_DATA) && data_buffer_size == 0x0210) {
		VV[0x11] &= ~DONT_READ_DATA; /* 1011 1111 */
		TXB = 0x11;
		[0xC004] &= ~C004_0; /* 1111 1110 */
		[0xC004] |=  C004_1; /* 0000 0010 */
	}

	func_2FE9(); /* always returns 0 */
	A = print_this_char;
	return 1;
}

/* always returns 0 */
/* 216F */
void func_216F()
{
	[0x9903] = [0x9901];
	VV[0x03] |= 0x08; /* 0000 1000 */
	VV[0x11] &= 0xC3; /* 1100 0011 */
	[0x9947] = 0x0000;
	VV[0x33] = 0x00;
	HL = 0x9A79;
	[0x9945] = HL;
	if (VV[0x11] & 0x01) {
		EA = [0x9951];
		DE = [0x9939] + 3;
		EA -= DE;
		EA = EA / 3;
		BC = EA;
		HL = 0x9A79;
		EA = 0x0000;
		while (C--) {
			push(BC);
			push(EA);
			A = [DE], DE += 1;
			EA = [DE], DE += 2;
			if (A == 0x20) {
				EA = pop();
				BC = pop();
				continue;
			}
			[HL] = A, HL += 1;
			push(VA);
			if (VV[0x02] & 0x02)
				EAL &= 0xf7; /* 1111 0111 */
			[HL] = EA, HL += 2;
			VV[0x03] &= 0xF7; /* 1111 0111 */
			A = EAH;
			if (A & 0x10) /* 0001 0000 */
				VV[0x11] |= 0x10; /* 0001 0000 */
			A = EAL;
			if (A & 0x20) /* 0010 0000 */
				VV[0x11] |= 0x08; /* 0000 1000 */
			VA = pop();
			BC = EA;
			func_22C9(); /* always returns 0 */
			BC = pop();
			EA += BC;
			BC = pop();
		}
		[0x9903] = [0x9905];
		[0x9901] = [0x9905] + EA;
	}
	[0x9939] = HL;
	return 0;
}

/* 21F3 */
void rollover_DE_from_0x9000_to_0x8000(void)
{
	if (DE == 0x9000)
		DE =  0x8000;
}

/* 21FC */
void rollover_DE_from_0x7fff_to_0x8fff(void)
{
	if (DE == 0x7fff)
		DE =  0x8fff;
}

/* 2205 */
int func_2205(void)
{
	if (0x9DA9 > [0x9939])
		return 1;
	return 0;
}
/* 2210 */
int func_2210(void)
{
	if (0x9A79 >= [0x9939])
		return 1;
	return 0;
}
/* always returns 0 */
/* 221B */
void func_221B(void)
{
	if (!func_2205())
		func_1B05(); /* always returns 0 */
	VV[0x03] &= 0x7F; /* 0111 1111 */
	HL = 0x9901;
	EA = [HL];
	DE = [0x993b];
	EA += DE;
	[HL] = EA;
	if (VV[0x09] & 0x10)
		VV[0x11] |= 0x10;
	if (VV[0x08] & 0x20)
		VV[0x11] |= 0x08;
	HL = 0x9808;
	EA = [HL];
	HL = [0x9939];
	A = print_this_char;
	if (VV[0x05] & 0x80)
		func_2254();
	[HL++] = A;
	[HL++] = EA; /* uint16_t */
	[0x9939] = HL;
	return 0;
}

void func_2254(void)
{
	if (A != 0x20) {
		if (VV[0x03] & 0x08) {
			[0x9945] = HL;
			return 0;
		}
		push(EA);
		push(HL);
		HL = 0x9947;
		EA = [HL];
		EA += DE;
		[HL] = EA;
		VV[0x33]++; /* skip on carry? */
		HL = pop();
		EA = pop();
	}
	VV[0x03] &= 0xf7; /* 1111 0111 */
	return 0;
}

int func_2272(void)
{
	EA = [0x9935];
	HL = [0x9937];
	if (EA == HL)
		return 0;
	if (VV[0x00] & 0x04) { /* 0000 0100 */
		A  = [HL++];
		EA = [HL  ];
		HL -= 4;
	} else {
		A  = [HL++];
		EA = [HL++];
	}
	[0x9937] = HL;
	return 1;
}

2291:
	push(EA);
	if (!func_2205())
		func_1B05(); /* always returns 0 */
	EA = pop();
	55 07 40           OFFIW   VV:07,$40
	VV[0x11] |= 0x20;
	A = VV[0x09];
	A |= 0x01;
	HL = [0x9939];
	[HL++] = EA;
	3D                 STAX    (HL+)
	[0x9939] = HL;
	[0x9945] = HL;
	HL = 0x9901;
	EA = [HL];
	DE = [0x993B];
	EA += DE;
	[HL] = EA;
	HL = 0x0000;
	[0x9833] = HL;
	[0x9947] = HL;
	return 0;

/* always returns 0 */
/* 22C9 */
void func_22C9(void)
{
	push(BC);
	func_22E6(); /* always returns 0 */
	if      (VV[0x07] & 0x40) A = 0x10;
	else if (B        & 0x04) A = 0x0c;
	else                      A = 0x06;
	EA = mul24(EA, A);
	BC = pop();
	if (B & 0x01)
		return 0;
	if (C & 0x08)
		EA <<= 1;
	return 0;
}

/* always returns 0 */
void func_22E6(void)
{
	if (B & 0x01) {
		EAL = A;
		A = C;
		EAH = A;
		return 0;
	}
	if      (VV[0x07] & 0x40) A = 0x09;
	else if (C & 0x80)        A = 0x0A;
	else                      A = 0x0C;
	if (B & 0x04)
		A += 2;
	EA = 0x0000;
	EAL = A;
	return 0;
}
/* always returns 0 */
/* 2313 */
void reset_highmem(void)
{
	[0x995B] = 0x0400;
	memset(0x9000, 0x00, 0x07fe);
	return 0;
}

/* 2322 */
int func_2322(void)
{
	if (VV[0x12] & 0x80) {
		DE = [0x9941];
		if (!DE)
			return 0;
		DE--;
		[0x9941] = DE;
		func_2127(); /* ignore rets, there's a nop after this */
		EA = 0x0000 | (A<<8);
		if (VV[0x12] & 0x08) {
			push(EA);
			func_2127(); /* ignore rets, there's a nop after this */
			EA = pop();
			EAL = A;
		}
		[0x9925] = EA;
	} else {
		DE = [0x995B];
		EA = [DE];
		if (EA == 0x0400)
			return 0;
		EA++;
		[DE] = EA;
		DE = [0x995F];
		[0x9925] = [DE];
		[DE++] = 0x0000;
		func_242B(); /* always returns 0 */
		[0x995F] = DE;
	}
	return 1;
}

234C:
	VV[0x40] &= 0xBF;
	EA = 0x0100;
	DE = [0x995B];
	if (EA > DE) {
		VV[0x40] |= 0x40;
		return 1;
	}
	if (!(VV[0x40] & 0x10)) {
		VV[0x40] = 0x00;
		[0xC000] = 0x00;
		VV[0x3c] = 0x00;
		VV[0x3d] = 0x00;
		if (!func_2272())
			return 0;
		HL = 0x9837;
		[HL++] =  A;
		[HL  ] = EA; /* VV[0x38] */
		BC = EA;
	}
	if (!func_2436())
		goto 23A0;
	if (A >= 0xb0 && A < 0xb3)
		VV[0x40] |= 0x80;
	func_22E6(); /* always returns 0 */
	if (VV[0x39] & 0x02)
		A <<= 1;
	VV[0x3A] = A;
	func_24D0(); /* always returns 0 */
	HL = 0x9965;
	func_2686(); /* always returns 0 */
	func_25EF(); /* always returns 0 */
	func_262A(); /* always returns 0 */

23A0:
	A = VV[0x3A];
	if (!A--)
		return 1;
	A += VV[0x3D];
	VV[0x3A] = A;
	DE = [0x995D];
	if (VV[0x37] == ' ')
		goto 23DE;
	if (!(VV[0x00] & 0x04)) /* 0000 0100 */
		goto 23C7;
	func_2418(); /* always returns 0 */
	HL = [0x9959];
23BD:
	HL--;
	HL--;
	EA = [HL];
	BC = EA;
	40 F1 23           CALL    $23F1
	goto 23BD
	goto 23D9
23C7:
	58 40              BIT     0,VV:40
	HL = 0x9965;
	HL = 0x99ED;
23CF:
	EA = [HL++];
	BC = EA;
	40 F1 23           CALL    $23F1
	goto 23CF
	func_2418(); /* always returns 0 */
23D9:
	[0x995D] = DE;
	return 1;
23DE:
	if (VV[0x00] & 0x04) /* 0000 0100 */
		func_2418(); /* always returns 0 */
23E4:
	do {
		BC = 0x0000;
	} while (!func_23F1());
	if (!(VV[0x00] & 0x04)) /* 0000 0100 */
		func_2418(); /* always returns 0 */
	goto 23D9

/* 23F1 */
int func_23F1(void)
{
	if (!(VV[0x00] & 0x04) && !(E & 0x02) && (VV[0x38] & 0x10)) { /* 0000 0100 */
	}
	if (VV[0x38] & 0x10) {
		if (VV[0x38] & 0x04) {
			C = 0x80;
		} else if (!(VV[0x00] & 0x04)) { /* 0000 0100 */
			if (!(E & 0x02))
				C = 0x80;
		} else if (E & 0x02){
			C = 0x80;
		}
	}
	EA = [DE];
	EA |= BC;
	[DE++] = EA;
	func_242B(); /* always returns 0 */
	push(HL);
	HL = 0x995B;
	disable_interrupts();
	[HL]--;
	enable_interrupts();
	HL = pop();
	if (!VV[0x3A]--)
		return 1;
	return 0;
}

/* always returns 0 */
void func_2418(void)
{
	A = VV[0x3D];
	while (A--) {
		DE--;
		DE--;
		func_242B(); /* always returns 0 */
		HL = 0x995B;
		disable_interrupts();
		EA = [HL];
		EA++;
		[HL] = EA;
		enable_interrupts();
	}
	return 0;
}
/* always returns 0 */
void func_242B(void)
{
	if (D == 0x98) D = 0x90;
	if (D == 0x8F) D = 0x97;
	return 0;
}

2436:
	if (!(VV[0x40] & 0x10))
		goto 243F;
	BC = [0x9961];
	goto 2482;
243F:
	if ((VV[0x39] & 0x01) || (VV[0x10] & 0x50))
		VV[0x38] &= 0xef;
	if (!(VV[0x39] & 0x01))
		goto 2457;
	BC = [0x9837];
	EA = BC;
	if (VV[0x39] & 0x02)
		EA <<= 1;
	BC = EA;
	goto 2482;
2457:
	if (!(VV[0x05] & 0x08) || (A != ' '))
		goto 2462;
	if (!func_24A0())
		goto 2482;
2462:
	if (A == ' ')
		goto 2472;
	5C 10              BIT     4,VV:10
	goto 246B;
	5C 39              BIT     4,VV:39
	goto 2472;
246B:
	55 10 40           OFFIW   VV:10,$40
	55 38 20           OFFIW   VV:38,$20
	return 1;
2472:
	func_22E6(); /* always returns 0 */
	55 39 02           OFFIW   VV:39,$02
	48 25              SLL     A
	55 38 08           OFFIW   VV:38,$08
	48 25              SLL     A
	C = A;
	B = 0x00;
2482:
	if (B == 0x00) {
		VV[0x40] &= 0xEF;
		A = C;
	} else {
		VV[0x40] |= 0x10;
		A = 0xFF;
	}
	60 33              SUBNB   C,A
	52                 DCR     B
	[0x9961] = BC;
	func_2497(); /* always returns 0 */
	return 0;

/* always returns 0 */
void func_2497(void)
{
	VV[0x3A] = A;
	VV[0x3d] = 0x00;
	VV[0x37] = ' ';
	return 0;
}

24A0:
	EA = [0x9937];
	if (VV[0x00] & 0x04) { /* 0000 0100 */
		EA += 3;
	} else {
		EA -= 3;
	}
	HL = [0x9945];
	74 AF              DGT     EA,HL
	return 1;
	HL = 0x9953;
	EA = [HL];
	if (!(VV[0x00] & 0x04)) /* 0000 0100 */
		goto 24C7;
	A = VV[0x35];
	74 A8 36           GTAW    VV:36
	EA++;
	30 35              DCRW    VV:35
	goto 24CE
24C7:
	if (VV[0x36] == 0x00)
		goto 24CE;
	EA++;
	30 36              DCRW    VV:36
24CE:
	BC = EA;
	return 0;

24D0:
	if (VV[0x38] & 0x02) {
		B = [0x9837];
		B -= 0x3a;
		func_1AC2(); /* always returns 0 */
		if (!(VV[0x39] & 0x02)) {
			VV[0x3B] = 0x0B;
			A = [HL++];
			if (!(A & 0x80))
				VV[0x40] |= 0x02;
			EA = [0x2000];
			func_25E2(EA); /* always returns 0 */
			goto 27C9;
		}
		A = [HL++];
		VV[0x3B] = A;
		VV[0x3C] = 0x00;
		EA = 0x000E;
		EA += HL;
		DE = 0x26E9;
		if (!(VV[0x38] & 0x80))
			DE = 0x26E8;
		[0x9963] = DE;
		B = 0x80;
	} else {
		A = VV[0x37];
		EA = 0x3401; /* IMPORTANT */
		if (!(VV[0x38] & 0x40))
			EA = 0x3301;
		HL = EA = [EA + 2*A];
		char_field_1 = [HL++];
		if (!(VV[0x39] & 0x02) || (VV[0x38] & 0x01) || !(char_field_1 & 0x02)) {
			A = [HL];
			if (!(A & 0x80))
				VV[0x40] |= 0x02;
			if (VV[0x39] & 0x02 || !(VV[0x39] & 0x80) || !(char_field_1 & 0x08)) {
				if (VV[0x07] & 0x40 || !(char_field_1 & 0x10)) {
					if (!(char_field_1 & 0x20) || (!(VV[0x07] & 0x40) && (VV[0x38] & 0x80))) {
						HL++;
						if (!(char_field_1 & 0x40)) {
							VV[0x3B] = 0x09;
							HL++;
							A = [HL++];
							func_25E2(A); /* always returns 0 */ /* lower byte only */
						} else {
							VV[0x3B] = 0x0B;
							A = [HL++];
							if (VV[0x40] & 0x80) {
								func_25E2(A); /* always returns 0 */ /* lower byte only */
							} else {
								if (VV[0x38] & 0x80) {
									EA = 0x6000;
									func_25E2(EA); /* always returns 0 */
								} else {
									if (VV[0x38] & 0x04 || !(VV[0x07] & 0x40)) {
										func_25E2(A); /* always returns 0 */ /* lower byte only */
									} else {
										EA = 0x2000;
										EAL = A;
										func_25E2(EA); /* always returns 0 */
									}
								}
							}
						}
					} else {
						VV[0x3B] = 0x09;
						func_25C9(0xC0); /* always returns 0 */
					}
				} else {
					VV[0x3B] = 0x08;
					func_25C9(0xE0); /* always returns 0 */
				}
			} else {
				if (!(char_field_1 & 0x04) || (!(VV[0x07] & 0x40) && !(VV[0x38] & 0x80))) {
					func_25C9(0xF0); /* always returns 0 */
					VV[0x3B] = 0x09;
					HL++;
					A = [HL++];
					func_25E2(A); /* always returns 0 */ /* lower byte only */
				} else {
					VV[0x3B] = 0x08;
					func_25C9(0xF8); /* always returns 0 */
				}
			}
			goto 27C9;
		}
		func_25C9(0xFC); /* always returns 0 */
		func_26A6(); /* always returns 0 */
		func_26B0(); /* always returns 0 */
		EA = HL;
		A = VV[0x3b];
		if (B & 0x80)
			A += 0x03;
		EA += A;
	}
	func_26EC(); /* always returns 0 */
	func_26DB(); /* always returns 0 */
	DE = 0x9965;
	A = VV[0x3C];
	if (C--)
		func_2AEA(); /* always returns 0 */
	HL = 0x99ED;
	A = VV[0x3B];
	48 25              SLL     A
	55 38 02           OFFIW   VV:38,$02
	VV[0x3B] = A;
	BC = [0xFFFF];
	while (VV[0x3b]--) {
		EA = [HL++];
		if ([0xC000] & 0x80)
			continue;
		EA &= BC;
		[DE++] = EA;
		BC = [0xFFFF];
		EA ^= BC;
		BC = EA;
	}
	return 0;

/* always returns 0 */
void func_25C9(uint8_t A)
{
	const uint8_t local_var[6] = { 0x0C, 0x0D, 0x09, 0x08, 0x0B, 0x08 };
	A &= char_field_1;
	A ^= 0xff;
	B = A;
	EA = HL;
	for (int i = 0; i < 6; i++) {
		A = local_var[i];
		if (B & 0x80)
			EA += A;
		B <<= 1;
	}
	HL = EA;
	return 0;
}
/* always returns 0 */
void func_25E2(EA)
{
	if (!(VV[0x07] & 0x40) && !(VV[0x38] & 0x80))
		return 0;
	[0xC001] = EA;
	return 0;
}
/* always returns 0 */
void func_25EF(void)
{
	if (!(VV[0x38] & 0x0c))
		return 0;
	EA = 0x0000;
	DE = [0x9959];
	[DE++] = EA;
	[DE  ] = EA;
	HL = 0x9965;
	DE = [0x99ED];
	push(DE);
	VV[0x40] |= 0x01
	A = VV[0x3a];
	B = A;
	if (VV[0x38] & 0x08)
		A <<= 1, A &= borrow;
	VV[0x3a] = A;
	A = B + VV[0x3d];
	BC = 0x0000;
	if (!(VV[0x39] & 0x02) || !(VV[0x38] & 0x04)) {
		func_28BC(); /* always returns 0 */
	} else {
		func_28BF(); /* always returns 1, already skipped */
	}
	HL = pop();
	func_2686(); /* always returns 0 */
	return 0;
}
/* always returns 0 */
void func_262A(void)
{
	if (!(VV[0x39] & 0x02) || !(VV[0x39] & 0x80))
		return 0;
	if (VV[0x40] & 0x01) {
		DE = 0x9965;
		HL = 0x99ED;
	} else {
		DE = 0x99ED;
		HL = 0x9965;
	}
	push(HL);
	push(HL);
	push(DE);
	A = VV[0x3A] + VV[0x3D];
	51                 DCR     A
	VV[0x3B] = A;
	C = A;
	do {
		HL++;
		[DE++] = [HL++];
	} while (C--);
	HL = pop();
	EA = 0x0044;
	EA += HL;
	memset(EA, 0x00, 0x42);
	push(EA);
	B = 0x01;
	do {
		EA++;
		DE = EA;
		push(HL);
		A = VV[0x3B];
		C = A;
		do {
			A = [HL++];
			A &= B;
			A |= [DE];
			[DE++]  = A;
		} while (C--);
		HL = pop();
	} while (B<<=1);
	HL = pop();
	DE = pop();
	A = VV[0x3B];
	C = A;
	do {
		A = [HL++];
		DE++;
		[DE++] = A;
	} while (C--);
	C = 0x07;
	do {
		[DE++] = 0x00;
		[DE++] = [HL++];
	} while (C--);
	HL = pop();
	func_2686(); /* always returns 0 */
	return 0;
}
/* always returns 0 */
void func_2686(void)
{
	[0xC000] = 0x00;
	EA = DE - HL;
	B = EAL >> 1;
	A = VV[0x3a];
	if (A >= B) {
		A -= B;
		if (A--)
			func_2AEA(); /* always returns 0 */
	} else {
		A -= B;
		A = ~A + 1; /* negate */
		VV[0x3d] = A;
	}
	[0x9959] = DE;
	return 0;
}
/* always returns 0 */
void func_26A6(void)
{
	B = A = [HL++];
	A &= 0x1f; /* 0001 1111 */
	VV[0x3C] = A;
	A = [HL++];
	VV[0x3B] = A;
	return;
}
/* always returns 0 */
void func_26B0(void)
{
	if (!(VV[0x38] & 0x80)) {
		HL += 3;
		[0x9963] = DE;
		return;
	}
	if (!(B & 0x40)) {
		[0x9963] = HL;
		HL += 3;
		return;
	}
	if (B & 0x80)
		A += 0x03;
	A <<= 1;
	A += 0x03;
	EA = HL;
	EA += A;
	HL = EA;
	func_26A6(); /* always returns 0 */
	[0x9963] = DE;
	return;
}
/* always returns 0 */
void func_26DB(void)
{
	uint16_t *p = [0x9963];
	[0xC001] = *p++; /* uint8_t */
	[0xC002] = *p++; /* uint8_t */
	[0xC003] = *p++; /* uint8_t */
	return;
}

26E8: 00                 NOP     
26E9: 00                 NOP     
	00
	1F

/* always returns 0 */
/* 26ec */
void func_26EC(void)
{
	if (VV[0x39] & 0x40)
		goto 2723;
	if (VV[FLAGS_1] & 0x40) /* 0100 0000 */
		HL = EA;
	func_26F8(0x99ED); /* always returns 0 */
	return 0;
}
/* always returns 0 */
/* 26f8 */
void func_26F8(uint16_t EA)
{
	[0xC000] = 0x00;
	if (B & 0x80) {
		[0xC001] = [HL++];
		[0xC002] = [HL++];
		if (!(VV[0x38] & 0x02))
			[0xC003] = [HL++];
	}
	DE = EA;
	C = VV[0x3b];
	do {
		[DE++] = [0xC000];
		[DE++] = [HL++];
		if (VV[0x38] & 0x02)
			[DE++] = 0x0000;
	} while (C--);
	return 0;
}

2723:
	push(BC);
	push(EA);
	func_26F8(0x9965); /* always returns 0 */
	HL = pop();
	BC = pop();
	func_26F8(0x99ED); /* always returns 0 */
	HL = 0x9965;
	DE = 0x99ED;
	C = [0x983B];
	55 38 02           OFFIW   VV:38,$02
	48 27              SLL     C
	5E 10              BIT     6,VV:10
	goto 27B8
	goto 277D
2748:
	do {
		push(BC);
		B = 0x00;
		HL++;
		C = [DE + 0x01];
		A = [HL++];
		if (A & 0x40 || C & 0x80) B |= 0x80;
		if (A & 0x20 || C & 0x20) B |= 0x40;
		if (A & 0x08 || C & 0x10) B |= 0x20;
		if (C & 0x04            ) B |= 0x10;
		if (A & 0x01            ) B |= 0x08;
		A = [DE];
		if (A & 0x80            ) B |= 0x04;
		func_27BC(); /* always returns 0 */
		BC = pop();
277D:
	} while (C--);
	return 0;
	do {
		push(BC);
		B = 0x00;
		A = [HL++];
		if (A & 0x80            ) B |= 0x04;
		A = [DE + 0x01];
		C = A;
		A = [HL++];
		if (A & 0x80            ) B |= 0x80;
		if (C & 0x40            ) B |= 0x40;
		if (A & 0x10            ) B |= 0x20;
		if (A & 0x04 || C & 0x08) B |= 0x10;
		if (A & 0x02 || C & 0x02) B |= 0x08;
		if (C & 0x01            ) B |= 0x04;
		func_27BC(); /* always returns 0 */
		BC = pop();
27B8:
	} while (C--);
	return 0;

/* always returns 0 */
void func_27BC(void)
{
	EA = 0x0000;
	A = B;
	EAH = A;
	if (!(VV[0x39] & 0x40)) /* 0010 0000 */
		EA >>= 3;
	[DE++] = EA;
	return 0;
}

27C9:
	if (VV[0x40] & 0x80 || VV[0x39] & 0x40 || !(VV[0x39] & 0x02) || VV[FLAGS_1] & 0x10 || !(VV[FLAGS_1] & 0x40)) {
		DE = 0x9965;
		B = 0x00;
		func_27E8(); /* always returns 0 */
		if (!func_2803())
			return 0;
		VV[0x3B] = A;
		func_27E8(); /* always returns 0 */
		return 0;
	}
	DE = 0x99ED;
	C = [0x983B];
	if (C--) {
		do {
			[DE++] = [HL++]
		} while (C--);
	}
	if (func_2803()) {
		C = A;
		A += VV[0x3B];
		VV[0x3B] = A;
		if (C--) {
			do {
				[DE++] = [HL++]
			} while (C--);
		}
	}
	HL = 0x99ED;
	DE = [0x9965];
	EA = 0x0000;
	VV[0x3B]--; /* don't do first A = [HL++]; on overflow */
	do {
		A = [HL++];
		B = A;
		C = [0xC000];
		if (!(C & 0x80)) {
			while (1) {
				do {
					if (VV[0x3b] == 0x00) {
						C = 0x00;
						break;
					}
					A = [HL++];
					C = [0xC000];
					if (!(C & 0x80)) {
						C = A;
						break;
					}
				} while (VV[0x3b]--);
				func_2958(); /* always returns 0 */
				func_2909(); /* always returns 0 */
				func_28F4(); /* always returns 0 */
				EAH = A;
				if (!VV[0x3b]--)
					break;
				func_2965(); /* always returns 0 */
				func_2909(); /* always returns 0 */
				func_28F4(); /* always returns 0 */
				EAH = A;
				A = B;
				EAL = A;
				A = C;
				B = A;
			}
		}
	} while (VV[0x3b]--);
	return 0;

/* always returns 0 */
/* 27E8 */
void func_27E8(void)
{
	while (VV[0x3b]--) {
		A = B;
		A ^= 0xff;
		A &= [HL++];
		C = [0xC000];
		if (C & 0x80)
			continue;
		B = A;
		func_28F4(); /* always returns 0 */
		if (!(VV[0x38] & 0x02))
			continue;
		A = 0x00;
		B = A;
		func_28F4(); /* always returns 0 */
	}
	return 0;
}

/* 2803 */
int func_2803(void)
{
	if ((VV[0x07] & 0x40) || !(VV[0x39] & 0x04))
		return 0;
	A = 0x01;
	if (VV[0x39] & 0x04)
		A += 2;
	if (A & 0x80 || A == 0x00)
		return 0;
	HL -= 3;
	return 1;
}

/* always returns 0 */
void func_28BC(void)
{
	while (A--) {
		EA = [HL++];
		push(EA);
		EA |= BC;
		[DE++] = EA;
		if (VV[0x38] & 0x08) {
			if (!(VV[0x38] & 0x04))
				EA = 0x0000;
			[DE++] = EA;
		}
		BC = pop();
	}
	return 0;
}
/* always returns 1 */
void func_28BF(void)
{
	if (++A)
		[0x9957] = BC;
	EA = BC;
	do {
		push(EA);
		EA = [HL++];
		push(EA);
		EA |= BC;
		if (VV[0x38] & 0x08) {
			BC = [0x9957];
			push(BC);
			BC = EA;
			[0x9957] = BC;
			BC = pop();
			EA |= BC;
			[DE++] = EA;
			EA = 0x0000;
		} else {
			push(EA);
			BC = 0xFFFF;
			EA = [HL];
			EA ^= BC;
			BC = pop();
			EA &= BC;
		}
		[DE++] = EA;
		EA = pop();
		BC = pop();
	} while (A--);
	return 1;
}
/* always returns 0 */
/* 28F4 */
void func_28F4(void)
{
	func_2911(); /* always returns 0 */
	EA = 0x0000;
	EAH = A;
	if (VV[0x40] & 0x02)
		EA >>= 1;
	if (VV[0x39] & 0x40)
		func_2925(); /* always returns 0 */
	[DE++] = EA;
	return 0;
}
/* always returns 0 */
/* 2909 */
void func_2909(void)
{
	if (!(VV[0x39] & 0x10))
		return 0;
	if (A & 0x02)
		A |= 0x01;
	return 0;
}

/* always returns 0 */
/* 2911 */
void func_2911(void)
{
	if (VV[0x10] & 0x10 || !(VV[0x39] & 0x10))
		return 0;
	if (VV[0x40] & 0x80) {
		A &= 0x0F;
		return 0;
	}
	if (!(A & 0x01)) A = 0x00;
	else             A = 0x0F;
	return 0;
}
/* always returns 0 */
/* 2925 */
void func_2925(void)
{
	push(BC);
	C = 0x00;
	if (VV[0x10] & 0x40)
		EA <<= 1;
	A = EAH;
	if (A & 0x80) C |= 0x80;
	if (A & 0x20) C |= 0x40;
	if (A & 0x08) C |= 0x20;
	if (A & 0x02) C |= 0x10;
	if (!(VV[0x10] & 0x40)) {
		A = EAL;
		if (A & 0x80)
			C |= 0x08;
	}
	EA = 0x0000;
	A = C;
	EAH = A;
	if (!(VV[0x39] & 0x20))
		EA >>= 4;
	BC = pop();
	return 0;
}
/* always returns 0 */
/* 2958 */
void func_2958(void)
{
	push(DE);
	push(HL);
	func_298C(); /* always returns 0 */
	func_29B8(); /* always returns 0 */
	A |= D;
	HL = pop();
	DE = pop();
	return 0;
}
/* always returns 0 */
/* 2965 */
void func_2965(void)
{
	push(DE);
	push(HL);
	A = B;
	func_29B8(); /* always returns 0 */
	D = A;
	A = C;
	A &= 0x7f;
	A = [HL+A];
	if (!(C & 0x80))
		A &= 0x7f;
	D |= A;
	D ^= 0xff;
	A = B;
	A <<= 1;
	A &= C;
	H = A;
	A = C;
	A <<= 1;
	A &= B;
	A |= H;
	A &= D;
	HL = pop();
	DE = pop();
	return 0;
}

/* always returns 0 */
void func_298C(void)
{
	A = EAL;
	48 25              SLL     A
	A &= C;
	D = A;
	A = EAL;
	E = A;
	A = C;
	48 25              SLL     A
	A &= E;
	D |= A;
	A = B;
	48 25              SLL     A
	A |= B;
	E = A;
	push(BC);
	HL = 0x2A52;
	A = EAL;
	func_29C4(); /* always returns 0 */
	E |= A;
	A = C;
	func_29C4(); /* always returns 0 */
	A |= E;
	A ^= 0xff;
	D &= A;
	BC = pop();
	A = B;
	return;
}
/* always returns 0 */
void func_29B8(void)
{
	HL = 0x29D2;
	A &= 0x7f;
	A = [HL+A];
	if (!(B & 0x80))
		A &= 0x7f; /* 0111 1111 */
	return;
}
/* always returns 0 */
void func_29C4(void)
{
	if (A == 0x7c)
		A = 0xfc;
	B = A;
	A &= 0x7f;
	A = [HL+A];
	if (!(B & 0x80))
		A &= 0xbf; /* 1011 1111 */
	return;
}

29D2: DW: 00 00 00 02 00 00 04 06 00 00 00 02 08 08 0C 0E
29E2: DW: 00 00 00 02 00 00 04 06 10 10 10 12 18 18 1C 1E
29F2: DW: 00 00 00 02 00 00 04 06 00 00 00 02 08 08 0C 0E
2A02: DW: 20 20 20 22 20 20 24 26 30 30 30 32 38 38 3C 3E
2A12: DW: 80 80 80 82 80 80 84 86 80 80 80 82 88 88 8C 8E
2A22: DW: 80 80 80 82 80 80 84 86 90 90 90 92 98 98 9C 9E
2A32: DW: C0 C0 C0 C2 C0 C0 C4 C6 C0 C0 C0 C2 C8 C8 CC CE
2A42: DW: E0 E0 E0 E2 E0 E0 E4 E6 F0 F0 F0 F2 F8 F8 FC FE

2A52: DW: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04
2A62: DW: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 08 0C
2A72: DW: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04
2A82: DW: 00 00 00 00 00 00 00 00 00 00 00 00 18 10 18 1C
2A92: DW: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04
2AA2: DW: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 08 0C
2AB2: DW: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04
2AC2: DW: 40 40 40 40 40 40 40 40 60 60 60 60 78 70 78 7C

/* always returns 0 */
/* 2AD2 */
void func_2AD2(void)
{
	if      (VV[0x07] & 0x40) A = 0x00;
	else if (VV[0x09] & 0x06) A = 0x0C;
	else                      A = 0x06;
	func_2497(); /* always returns 0 */
	VV[0x38] &= 0xef;
	func_23A0(); /* result skipped */
	return 0;
}

void func_2AEA(void)
{
	EA = 0x0000;
	do {
		B = [0xC000];
		if (!(B & 0x80))
			[DE++] = EA;
	} while (A--);
	return 0;
}
/* always returns 0 */
/* 2AFA */
void func_2AFA(void)
{
	if (!sensor_release_x()) B = 0x20;
	else                     B = 0x00;
	C = [0x984F];
	push(BC);
	if (!sensor_paper_end_debounced()) A = 0x00;
	else                               A = 0x10;
	BC = pop();
/* 2b0d */
	A |= B;
	B = A;
	A ^= C;
	if (A & 0x30) {
		VV[0x4F] = B | (C & 0x4f);
		[0x984B] = 0x0000;
		if ((VV[0x4f] & 0x20) && !(VV[0x4f] & 0x10))
			VV[0x14] |= 0x02;
	} else {
		if (VV[0x4f] & 0x10)
			VV[0x14] |= 0x02;
	}
/* 2b33 */
	func_32BF(); /* always returns 0 */
	[0xC007] = 0x05; /* 0000 0101 */
	PC |= 0x04; /* 0000 0100 */ /* ONLINE LED */
	delay(30);
	PC &= 0xfb; /* 1111 1011 */ /* ONLINE LED */
	delay(25);
	if ((VV[0x4f] & 0x10) || (VV[0x4f] & 0x20)) A = 0x0C;
	else                                        A = 0x24;
/* 2b51 */
	func_3012(); /* always returns 0 */
	func_301C(); /* always returns 0 */
/* 2b57 */
	VV[0x13] |= 0x02;
	func_2B5A(); /* always returns 0 */
	return 0;
}
/* always returns 0 */
/* 2B5A */
void func_2B5A(void)
{
	VV[0x2C] = 0x24;
	[0x992B] = 0x0000;
	VV[0x26] = 0x00;
	return 0;
}

2B68:
	if (VV[0x26] == 0x00)
		return 0;
	goto 2BA0
2B6F:
	if (!func_32EC())
		goto 2D79;
	func_32F3(); /* always returns 0 */
	EA = [HL];
	HL = [0x992B];
	EA -= HL;
	BC = EA;
	goto 2B88
2B82:
	C = [0x982C];
	B = 0x00;

2B88:
	push(BC);
	55 14 40           OFFIW   VV:14,$40
	40 13 2C           CALL    $2C13
	func_31B0(); /* always returns 0 */
	BC = pop();
	40 B8 2B           CALL    $2BB8
	A = VV[0x26];
	EA = BC;
	EA -= A;
	48 0A              SK      CY
	goto 2BB2
	60 E3              SUB     A,C
2BA0:
	A += 0x0c;
	if (!(VV[0x4f] & 0x20))
		A += 0x18;
	C = A;
	B = 0x80;
	func_313F(); /* always returns 0 */
	EA = 0x000C;
	if (!(VV[0x4f] & 0x20))
		EA = 0x0024;
2BB2:
	BC = EA;
	func_313F(); /* always returns 0 */
	VV[0x26] = 0x00;
	return 0;
2BB8:
	VV[0x03] &= 0xFE; /* 1111 1110 */
	func_32F3(); /* always returns 0 */
	EA = [HL];
	DE = EA;
	HL = 0x992B;
	EA = [HL];
	EA += BC;
2BC8:
	74 BE              DLT     EA,DE
	goto 2BD9
	if (VV[0x4f] & 0x20)
		goto 2BFE;
	HL = [0x992F];
	74 BF              DLT     EA,HL
	goto 2BF4
	goto 2BFE
2BD9:
	VV[0x13] &= 0xFD;
	[0x9A75] = 0x0000;
	if (!func_32E5())
		goto 2BF0;
	HL = pop();
	VV[0x26] = 0x00;
	goto 2D7D;
2BF0:
	EA -= DE;
	goto 2BC8
2BF4:
	HL = EA;
	EA = DE;
	EA -= HL;
	EA += BC;
	BC = EA;
	EA = 0x0000;
2BFE:
	HL = 0x992B;
	[HL] = EA;
	HL = 0x984B;
	EA = [HL];
	EA += BC;
	A = EAH;
	57 C0              OFFI    A,$C0
	EA = 0x3FFF;
	[HL] = EA;
	return 0;

2C13:
	if (!func_2E08())
		goto 2C27;
	if (!func_32EC())
		goto 2D47;
	if (VV[0x01] & 0x04) /* 0000 0100 */
		goto 2C27;
	40 7D 2D           CALL    $2D7D
	goto 2D07;
2C27:
	VV[0x14] &= 0xFD; /* 1111 1101 */
	return 0;

2C2B:
	func_32CF(); /* always returns 0 */
	if (!(VV[0x14] & 0x40))
		return 0;
	beep_x_y(5, 4, 1); /* 104E */
	goto 0EC2;

/* always returns 0 */
/* 2C37 */
void func_2C37(void)
{
	func_32CF(); /* always returns 0 */
	func_2E4B(); /* result skipped */
	if (sensor_paper_end_debounced()) {
		VV[0x13] |= 0x04;
		if (VV[0x13] & 0x20)
			[0x9929] = 0x0166;
		VV[0x13] &= 0xDF;
	}
/* 2C4C */
	if (!sw_line_feed())
		func_2C79(); /* always returns 0 I DON'T KNOW */
/* 2C53 */
	if (!sw_form_feed())
		func_2CA4(); /* always returns 0 I DON'T KNOW */
/* 2C5A */
	if (!sw_load_eject())
		func_2CB2(); /* always returns 0 I DON'T KNOW */
/* 2C61 */
	func_32B9(); /* always returns 0 */
	return 0; /* from func_32B9() */
}

2C64:
	59 14              BIT     1,VV:14
	goto 2C6D
	if (!(VV[0x4f] & 0x20))
		return 0;
	if (!sensor_paper_end_debounced())
		return 0;
	return 1;

2C6D:
	if (!(VV[0x13] & 0x04))
		return 1;
	if (!sensor_paper_end_debounced())
		return 0;
	if ((VV[0x4f] & 0x20) || !func_2E08())
		return 1;
	return 0;

2C79:
	40 64 2C           CALL    $2C64
	goto 2CD0
	VV[0x13] &= 0xFB;
	VV[0x13] |= 0x01
2C84:
	40 82 2B           CALL    $2B82
	40 7E 30           CALL    $307E
2C8A:
	if (!sw_line_feed())
		return 0;
	BC = [0x990F];
	EA = [0x0006];
	74 AD              DGT     EA,BC
	goto 2C8A
	if (!func_32E5())
		goto 2C84;
	59 14              BIT     1,VV:14
	if (!func_2E08())
		goto 2C84;
	goto 2D7D;

2CA4:
	if (!func_32EC())
		goto 2CB2
	40 64 2C           CALL    $2C64
	goto 2CB5
	VV[0x13] &= 0xFB;
	goto 2B6F;

2CB2:
	55 14 02           OFFIW   VV:14,$02
2CB5:
	goto 2CD0
	5A 13              BIT     2,VV:13
	goto 2CBE
	if (!sensor_paper_end_debounced())
		goto 2CD0;
	5D 4F              BIT     5,VV:4F
	goto 2CDA
2CBE:
	goto 2D79

2CC0:
	if (VV[0x13] & 0x20) {
		if (!func_32EC())
			goto 2D79
		VV[0x13] &= 0xDF;
		return 0;
	}
	if (!func_2E08())
		return 0;
2CD0:
	if (!func_32EC())
		goto 2D47
	if (VV[0x4f] & 0x20)
		goto 2D5B;
2CDA:
	90                 CALT    ($00A0)
	40 91 2D           CALL    $2D91
	90                 CALT    ($00A0)
	goto 2D03
	BC = 0x02D0;
	59 14              BIT     1,VV:14
	40 6F 2D           CALL    $2D6F
	func_313F(); /* always returns 0 */
	BC = 0x02AC;
	40 D2 2E           CALL    $2ED2
	goto 2D07
	func_31D0(); /* always returns 0 */
	BC = 0x80B2;
	func_313F(); /* always returns 0 */
	BC = [0x9847];
	EA = 0x0042;
	EA += BC;
2D01: BC = EA;
	func_313F(); /* always returns 0 */
2D03:
	40 25 2D           CALL    $2D25
	goto 2D1C

2D07:
	[0x9929] = 0x0166;
	59 14              BIT     1,VV:14
	goto 2DA5
	55 14 40           OFFIW   VV:14,$40
	VV[0x13] |= 0x40
	5E 14              BIT     6,VV:14
	VV[0x13] |= 0x80
	goto 2C2B;

2D1C:
	VV[0x13] &= 0x3B;
	5D 4F              BIT     5,VV:4F
	VV[0x14] |= 0x10;
	return 0;
2D25:
	func_32B9(); /* always returns 0 */
	VV[0x14] &= 0xFD; /* 1111 1101 */
	if (!sensor_paper_end_debounced())
		goto 2D2E;
	return 1;
2D2E:
	BC = 0x0000;
	[0x992B] = BC;
	[0x9929] = BC;
	[0x984B] = BC;
	VV[0x26] = 0x00;
	VV[0x13] &= 0xFD; /* 1111 1101 */
	VV[0x14] &= 0xFD; /* 1111 1101 */
	return 0;
2D47:
	59 14              BIT     1,VV:14
	40 79 2D           CALL    $2D79
	if (!sensor_paper_end_debounced())
		goto 2D5B;
	BC = 0x8AB6;
	func_313F(); /* always returns 0 */
	BC = 0x01DE;
	40 D2 2E           CALL    $2ED2
	goto 2D07
	goto 2D5F
2D5B:
	if (!sensor_paper_end_debounced())
		goto 2D5F;
	goto 2D07
2D5F:
	func_31D0(); /* always returns 0 */
	BC = [0x9843];
	EA = 0x0181;
	EA += BC;
	BC = EA;
	func_313F(); /* always returns 0 */
	goto 2D03

2D6F:
	BC = 0x04AE;
	if (!func_32E5())
		BC = 0x0393;
	return 0;
2D79:
	5D 4F              BIT     5,VV:4F
	goto 2D91

2D7D:
	40 08 2E           CALL    $2E08
	func_31D0(); /* always returns 0 */
	BC = 0x2520; /* '% ' */
	if (!func_32E5())
		BC = 0x0BD0;
	func_313F(); /* always returns 0 */
	40 6F 2D           CALL    $2D6F
	goto 2D9E

2D91:
	if (!sensor_paper_end_debounced())
		goto 2D94;
	goto 2D7D
2D94:
	func_31D0(); /* always returns 0 */
	BC = 0x8D80;
	func_313F(); /* always returns 0 */
	BC = 0x0070;
2D9E:
	40 AE 2E           CALL    $2EAE
	goto 2DAE
	VV[0x14] &= 0xEF; /* 1110 1111 */
2DA5:
	VV[0x13] &= 0xDF;
	VV[0x14] |= 0x02; /* 0000 0010 */
	func_32BF(); /* always returns 0 */
	return 0;
2DAE:
	VV[0x13] |= 0x20
	if (!func_32E5())
		goto 2DBC;
	40 25 2D           CALL    $2D25
	VV[0x13] |= 0x02
	goto 2DC2
2DBC:
	func_32B9(); /* always returns 0 */
	40 C5 2D           CALL    $2DC5
2DC2:
	goto 2C2B;
2DC5:
	5D 4F              BIT     5,VV:4F
	goto 2DE4
	EA = 0x0BD0;
	HL = [0x992B];
	EA += HL;
	A = VV[0x26];
	EA += A;
	HL = [0x992D];
	74 BF              DLT     EA,HL
	goto 2DDE
	goto 2DFF
2DDE:
	EA -= HL;
	74 BF              DLT     EA,HL
	goto 2DDE
	goto 2DFF
2DE4:
	HL = [0x992B];
	EA = HL;
	A = VV[0x26];
	EA += A;
	HL = 0x0D80;
	int borrow = (EA >= HL);
	EA -= HL;
	if (!borrow)
		goto 2DF4;
	goto 2DFF
2DF4:
	HL = [0x9931];
	DE = 0x0000;
2DFB:
	74 A7              DADDNC  EA,HL
	goto 2DFF
	goto 2DFB
2DFF:
	HL = EA;
	[0x992B] = HL;
	VV[0x26] = 0x00;
	return 0;

/* 2E08 */
int func_2E08(void)
{
	while (1) {
		disable_interrupts();
		EA = [0x9929];
		HL = [0x990F];
		enable_interrupts();
		if (HL != 0x0000) {
			if (!(VV[0x01] & 0x80)) { /* 1000 0000 */
				EA += HL;
				if (EA > 0x0142) check_gate_array_input(); /* always returns 0 */
				else             return 0;
				continue;
			}
			int borrow = (EA >= HL);
			EA -= HL;
			if (!borrow)
				return 0;
		} else {
			A = VV[0x26];
			int carry = (A > EA);
			EA -= A;
			if (carry)
				return 0;
		}
		if (EA > 0x0142) return 1;
		else             return 0;
	}
}

/* 2E3A */
int sensor_paper_end_debounced(void)
{
	return ckbit_1(read_debounced_PA());
}
/* 2E3E */:
int sensor_paper_end(void)
{
	/* CN6 sensor (Paper-End, PE, active low) */
	return ckbit_1(read_stable_PA());
}

/* 2E41 */
int ckbit_1(uint8_t A)
{
	if (A & 0x02) {
		VV[0x4F] &= 0xEF; /* 1110 1111 */
		return 0;
	} else {
		VV[0x4F] |= 0x10; /* 0001 0000 */
		return 1;
	}
}

2E4B:
	if (!sensor_release_x())
		goto 2E68;
	55 4F 20           OFFIW   VV:4F,$20
	goto 2E60
	5A 13              BIT     2,VV:13
	return 1;
	if (!sensor_paper_end_debounced())
		goto 2E59;
	return 1;
2E59:
	one_short_beep(); /* always returns 0 */
	goto 2E4B
2E5B:
	one_short_beep(); /* always returns 0 */
	if (!sensor_release_x())
		return 1;
2E60:
	40 7D 2E           CALL    $2E7D
	goto 2E5B
	VV[0x4F] &= 0xDF;
	goto 2E7A
2E68:
	55 4F 20           OFFIW   VV:4F,$20
	return 1;
	goto 2E73
2E6D:
	one_short_beep(); /* always returns 0 */
	if (!sensor_release_x())
		goto 2E73;
	return 1;
2E73:
	40 7D 2E           CALL    $2E7D
	goto 2E6D
	VV[0x4F] |= 0x20
2E7A:
	func_32BF(); /* always returns 0 */
	return 0;
2E7D:
	if (!func_2E08())
		goto 2E82;
	return 1;
2E82:
	BC = [0x9929];
	EA = 0x0000;
	if (EA != BC)
		return 0;
	if (!sensor_paper_end_debounced())
		return 0;
	return 1;

/* 2E8F */
int sensor_release_x(void)
{
	if (!sensor_release())
		if (  VV[0x4f] & 0x20 )
			return 0;
	} else {
		if (!(VV[0x4f] & 0x20))
			return 1;
	}
	A, B = read_debounced_PA();
	if (A & 0x04)
		return 0;
	return 1;
}
/* 2E9F */
int sensor_release(void)
{
	/* CN4 sensor (Release, low = tractor) */
	if (read_stable_PA() & 0x04)
		return 0;
	return 1;
}

/* always returns 0 */
/* 2EA6 */
void func_2EA6(void)
{
	A = C;
	A += VV[0x26];
	VV[0x26] = A;
	func_313F(); /* always returns 0 */
	return 0;
}

2EAE:
	check_gate_array_input(); /* always returns 0 */
	HL = 0x990F;
	EA = [HL];
	DE = 0x0000;
	74 AE              DGT     EA,DE
	return 0;
	if (!(VV[0x4f] & 0x10))
		goto 2EAE;
	DE = EA;
2EBE:
	EA = [HL];
	if (EA == DE)
		goto 2EBE;
	if (!(VV[0x4f] & 0x10))
		goto 2EAE;
	HL = [0x990F];
	[0x9A77] = HL;
	40 F0 2E           CALL    $2EF0
	return 1;
2ED2:
	check_gate_array_input(); /* always returns 0 */
	HL = 0x990F;
	EA = [HL];
	DE = 0x0000;
	74 AE              DGT     EA,DE
	return 0;
	if (VV[0x4f] & 0x10)
		goto 2ED2
	DE = EA;
2EE3:
	EA = [HL];
	if (EA == DE)
		goto 2EE3;
	if (VV[0x4f] & 0x10)
		goto 2ED2;
	40 F0 2E           CALL    $2EF0
	return 1;
2EF0:
	disable_interrupts();
	55 01 10           OFFIW   VV:01,$10
	55 01 22           OFFIW   VV:01,$22
	goto 2EFE
	[0x990F] = BC;
	enable_interrupts();
	return 0;
2EFE:
	enable_interrupts();
	func_32B9(); /* always returns 0 */
	55 01 80           OFFIW   VV:01,$80
	B |= 0x80;
	func_313F(); /* always returns 0 */
	return 0;

2F0A:
	59 13              BIT     1,VV:13
	55 03 02           OFFIW   VV:03,$02
	return 1;
	5C 13              BIT     4,VV:13
	goto 2F1A
	40 67 30           CALL    $3067
	func_2FB3(); /* always returns 0 */
	goto 2F34
2F1A:
	45 0F C0           ONIW    VV:0F,$C0
	55 01 30           OFFIW   VV:01,$30
	return 1;
	40 EC 32           CALL    $32EC
	59 14              BIT     1,VV:14
	55 13 02           OFFIW   VV:13,$02
	return 1;
	EA = 0x0000;
	BC = [0x992B];
	74 FD              DEQ     EA,BC
	return 1;
2F34:
	5C 13              BIT     4,VV:13
	if (VV[0x4f] & 0x80)
		goto 2F43;
	if (!func_32EC())
		goto 2F52
	55 01 04           OFFIW   VV:01,$04
	goto 2F52
	goto 2F4C
2F43:
	BC = [0x9A75];
	EA = [0x03FF];
	74 ED              DNE     EA,BC
2F4C:
	if (!sensor_paper_end())
		goto 2F52;
	goto 2FAA
2F52:
	BC = [0x9A75];
	BC++;
	EA = 0x03FF;
	74 BD              DLT     EA,BC
	if (!data_buffer_empty())
		BC = 0x0000;
	if (!func_2210())
		BC = 0x0000;
	[0x9A75] = BC;
	EA = 0x0000;
	if (EA == BC)
		return 1;
	55 13 10           OFFIW   VV:13,$10
	return 1;
	EA = 0x0000;
	BC = [0x984B];
	5F 4F              BIT     7,VV:4F
	74 ED              DNE     EA,BC
	goto 2F96
	5D 4F              BIT     5,VV:4F
	55 14 01           OFFIW   VV:14,$01
	return 1;
	BC = [0x9A75];
	EA = 0x03FF;
	74 FD              DEQ     EA,BC
	return 1;
	if (!func_2FC8())
		goto 2FAA;
2F96:
	BC = 0xC805;
2F99:
	push(BC);
	delay(C);
	if (!sw_online())
		goto 2FA8;
	BC = pop();
	52                 DCR     B
	goto 2F99
	VV[0x13] |= 0x10
	one_short_beep(); /* always returns 0 */
	sw_online_wait();
	return 1;
2FA8:
	BC = pop();
	return 1;
2FAA:
	VV[0x4F] &= 0x7F;
	VV[0x13] &= 0xEF;
	func_32BF(); /* always returns 0 */
	return 0;

/* always returns 0 */
/* 2FB3 */
void func_2FB3(void)
{
	BC = [0x9A75];
	EA = [0x03FF];
	if (EA != BC)
		return 0;
	[0xC004] ^= C004_4; /* 0001 0000 */
	return 0;
}
/* 2FC8 */
int func_2FC8(void)
{
	func_32B9(); /* always returns 0 */
	if (sensor_paper_end_debounced())
		return 0;
	EA = 0x0268;
	BC = [0x9849];
	EA += BC;
	BC = [0x9847];
	EA -= BC;
	BC = EA;
	func_313F(); /* always returns 0 */
	func_32B9(); /* always returns 0 */
	if (!sensor_paper_end_debounced()) {
		VV[0x4F] |= 0x80;
		return 1;
	}
	return 0;
}
/* always returns 0 */
/* 2FE9 */
void func_2FE9(void)
{
	if (VV[0x4f] & 0x80)
		func_301C(); /* always returns 0 */
	func_2FEF(); /* always returns 0 */
	return 0;
}
/* always returns 0 */
/* 2FEF */
void func_2FEF(void)
{
	if (!(VV[0x13] & 0x10))
		return 0;
	VV[0x13] &= 0xEF; /* 1110 1111 */
	[0x9A75] = 0x0000;
	[0xC004] |= C004_4; /* 0001 0000 */
	if (!(VV[0x13] & 0x08))
		return 0;
	VV[0x13] &= 0xF7; /* 1111 0111 */
	if (!(VV[0x4f] & 0x20)) A = 0x24;
	else                    A = 0x0C;
	func_3012(); /* always returns 0 */
	return 0;
}
/* always returns 0 */
/* 3012 */
void func_3012(void)
{
	C = A;
	push(BC);
	B = 0x80;
	func_313F(); /* always returns 0 */
/* 3017 */
	BC = pop();
	B = 0x00;
	func_313F(); /* always returns 0 */
/* 301b */
	return 0;
}
/* always returns 0 */
/* 301C */
void func_301C(void)
{
	if (!(VV[0x4f] & 0x80))
		return 0;
	func_31D0(); /* always returns 0 */
	EA = 0x028C;
	BC = [0x9849];
	EA += BC;
	BC = [0x9847];
	EA -= BC;
	BC = EA;
	B |= 0x80;
	func_313F(); /* always returns 0 */
	VV[0x4F] &= 0x7F;
	BC = 0x0024;
	func_313F(); /* always returns 0 */
	func_32B9(); /* always returns 0 */
	BC = 0x0000;
	[0x984B] = BC;
	VV[0x14] &= 0xEF; /* 1110 1111 */
	VV[0x13] |= 0x02
	return 0;
}

/* always returns 0 */
/* 304E */
void func_304E(void)
{
	if (!(VV[0x14] & 0x10))
		return 0;
	VV[0x14] &= 0xEF; /* 1110 1111 */
	func_32F3(); /* always returns 0 */
	EA = [HL];
	HL = [0x984B];
	HL++;
	if ((VV[0x4f] & 0x20) || (HL <= EA))
		return 0;
	A = 0x24;
	func_3012(); /* always returns 0 */
	return 0;
}

3067:
	VV[0x13] |= 0x01
306A:
	if (!sw_line_feed())
		goto 3072;
	40 D1 30           CALL    $30D1
	goto 3077
3072:
	if (!sw_form_feed())
		return 0;
	40 9C 30           CALL    $309C
3077:
	func_32B9(); /* always returns 0 */
	40 7E 30           CALL    $307E
	goto 306A

307E:
	58 13              BIT     0,VV:13
	return 0;
	func_32B9(); /* always returns 0 */
	BC = 0x8702;
3087:
	push(BC);
	delay(C);
	A, B = read_stable_PA();
	BC = pop();
	A &= 0xc0;
	67 C0              NEI     A,$C0
	goto 3098
	52                 DCR     B
	goto 3087
	VV[0x13] &= 0xFE;
	return 0;
3098:
	VV[0x13] |= 0x01
	return 0;
309C:
	EA = 0x0000;
	HL = [0x984B];
	74 FF              DEQ     EA,HL
	goto 30C2
	HL = [0x9847];
	55 4F 20           OFFIW   VV:4F,$20
	HL = [0x9843];
	EA = 0x01B0;
	74 FF              DEQ     EA,HL
	goto 30BC
30B8:
	one_short_beep(); /* always returns 0 */
	if (!sw_form_feed())
		return 0;
	goto 30B8
30BC:
	5D 4F              BIT     5,VV:4F
	goto 3120
	goto 3123
30C2:
	HL = [0x9849];
	EA = 0x006C;
	74 FF              DEQ     EA,HL
	goto 3126
30CD:
	one_short_beep(); /* always returns 0 */
	if (!sw_form_feed())
		return 0;
	goto 30CD

30D1:
	EA = 0x0000;
	HL = [0x984B];
	74 FF              DEQ     EA,HL
	goto 30F9
	HL = [0x9847];
	55 4F 20           OFFIW   VV:4F,$20
	HL = [0x9843];
	EA = 0xFFFC;
	74 FF              DEQ     EA,HL
	goto 30F3
30ED:
	one_short_beep(); /* always returns 0 */
	if (!sw_line_feed())
		return 0;
	goto 30ED
30F3:
	5D 4F              BIT     5,VV:4F
	goto 310A
	goto 310D
30F9:
	HL = [0x9849];
	EA = [0xFF94];
	74 FF              DEQ     EA,HL
	goto 3110
3104:
	one_short_beep(); /* always returns 0 */
	if (!sw_line_feed())
		return 0;
	goto 3104
310A:
	HL = 0x9847;
310D:
	HL = 0x9843;
3110:
	HL = 0x9849;
	5F 4F              BIT     7,VV:4F
	VV[0x13] |= 0x08
	EA = [HL];
	EA--;
	EA--;
	BC = 0x8002;
	goto 3130
3120:
	HL = 0x9847;
3123:
	HL = 0x9843;
3126:
	HL = 0x9849;
	EA = [HL];
	EA++;
	EA++;
	BC = 0x0002;
3130:
	[HL] = EA;
	push(EA);
	func_313F(); /* always returns 0 */
	EA = pop();
	HL = 0x0000;
	74 FF              DEQ     EA,HL
	return 0;
	one_short_beep(); /* always returns 0 */
	wait_for_button(); /* always returns 0 */
	return 0;

/* always returns 0 */
/* 313F */
void func_313F(void)
{
	EA = 0x7FFF;
	if (!(EA & BC))
		return 0;
	disable_interrupts();
	if (!(VV[0x01] & 0x80) && !(B & 0x80) && !(VV[0x01] & 0x22) && (VV[0x01] & 0x10) && (VV[0x01] & 0x08)) {
		HL = 0x990F;
		EA = [HL];
		EA += BC;
		[HL] = EA;
	} else {
/* 3160 */
		enable_interrupts();
		push(BC);
		do {
			check_gate_array_input(); /* always returns 0 */
		} while ((VV[0x0f] & 0x02) || (VV[0x01] & 0x30));
/* 3169 */
		func_31B0(); /* always returns 0 */
/* 316c */
		BC = pop();
		VV[0x01] |= 0x90; /* 1001 0000 */
		if (!(B & 0x80))
			VV[0x01] &= 0x7F; /* 0111 1111 */
		B &= 0x7f;
		[0x990f] = BC;
		EA = 0x000A;
		if (EA >= BC) {
			VV[0x01] &= 0xB5; /* 1011 0101 */
			A = 0x02;
		} else {
			VV[0x01] |= 0x48; /* 0100 1000 */
			A = 0x0B;
		}
		VV[0x27] = A;
		PC  |= 0x04; /* 0000 0100 */ /* ONLINE LED */
		ETMM = 0x04; /* 0000 0100 */ /* free running, clear at every full count ffffh */
		disable_interrupts();
		ETM0 = ECNT + 100;
/* 31a4 */
		etimer_func = etimer_4;
		IRR &= ~FE0; /* clear FE0 */
		MKL &= 0xdf; /* 1101 1111 */ /* activate INTE0 */
	}
	enable_interrupts();
	return 0;
}
/* always returns 0 */
/* 31B0 */
void func_31B0(void)
{
	BC = [0x984B];
	HL = 0x9843;
	if (!(VV[0x4f] & 0x20))
		HL = 0x9847;
	EA = [HL];
	EA += BC;
	BC = EA;
	if (B & 0x80) {
		func_31D0(); /* always returns 0 */
		return 0;
	}
/* 31c5 */
	EA = 0x0168;
	if (!(VV[0x4f] & 0x20))
		EA = 0x01D4;
/* 31cd */
	if (EA <= BC)
		return 0;
	func_31D0(); /* always returns 0 */
	return 0;
}
/* always returns 0 */
/* 31D0 */
void func_31D0(void)
{
	if (VV[0x4f] & 0x20) func_7888(0x010D); /* always returns 0 */
	else                 func_7888(0x00D1); /* always returns 0 */
	return 0;
}
/* 31D8 */
int func_31D8(void)
{
	BC = [0x984B];
	HL = 0x9843;
	if (!(VV[0x4f] & 0x20))
		HL = 0x9847;
	BC += [HL];
	EA = 0x0168;
	if (!(VV[0x4f] & 0x20))
		EA = 0x01D4;
	if (EA > BC) return 0;
	else         return 1;
}

/* 31F5 */
etimer_4:
	exx();
	exa();
	push(EA);
	push(VA);
	push(BC);
	push(HL);
	EA = ECNT;
	push(EA);
	if (!(VV[0x01] & 0x20)) /* 0010 0000 */
		goto 3214;
	enable_interrupts();
	if (PC & 0x04) {
		PC &= 0xfb; /* 1111 1011 */
		goto 325A;
	}
	MKL |= 0x20; /* 0010 0000 */ /* mask INTE0 */
	VV[0x01] &= 0xDF; /* 1101 1111 */
	EA = pop();
	HL = pop();
	BC = pop();
	VA = pop();
	EA = pop();
	return; /* FROM INTERRUPT */

3214:
	pf_step(); /* always returns 0 */
	enable_interrupts();
	if (!sensor_paper_end()) {
		HL = 0x0000;
		goto 3232;
	}
	HL = [0x9929];
	if (H & 0x80)
		HL = 0x7FFF;
	HL++;
	if (!(VV[0x01] & 0x80)) /* 1000 0000 */
		goto 3232;
	HL--;
	HL--;
	if (H & 0x80)
		HL = 0x0000;
3232:
	[0x9929] = HL;
	[0x990F]--;
	if (EA == 0x0000) {
		VV[0x01] |= 0x20; /* 0010 0000 */
		VV[0x01] &= 0xED; /* 1110 1101 */
	}
	if (!(VV[0x01] & 0x08)) { /* 0000 1000 */
		if (EA == 0x0004)
			VV[0x01] |= 0x02; /* 0000 0010 */
		if (VV[0x27] == 0x06)
			VV[0x01] &= 0xBF; /* 1011 1111 */
	}
	55 01 62           OFFIW   VV:01,$62
325A:
	VV[0x27]--;
	A = VV[0x27] << 1;
	HL = 0x32A3;
	EA = [HL + A];
	HL = pop();
	EA += HL;
	ETM0 = EA;
	HL = pop();
	BC = pop();
	VA = pop();
	EA = pop();
	return; /* FROM INTERRUPT */

/* always returns 0 */
/* 326F */
void pf_step(void)
{
	if (VV[0x01] & 0x80) HL = 0x3289;
	else                 HL = 0x3293;
	A = [HL+[0xC007]];
	[0xC007] = A;
	[0xC007] = [HL+A];
	return 0;
}

fw 9, 1, 5, 4, 6, 2, a, 8, 9
bw 8, a, 2, 6, 4, 5, 1, 9, 8

3289: DW: 09 05 0A 09 06 04 02 09 09 01 08 09 06 09 05 01
3299: DW: 04 09 0A 08 02 09 09 09 09 09 F4 77 F9 47 A7 0F
32A9: DW: 95 0C 0C 0B 47 0A E5 09 47 0A 0C 0B 95 0C A7 0F

/* always returns 0 */
/* 32B9 */
void func_32B9(void)
{
	while (VV[0x01] & 0x30)
		check_gate_array_input(); /* always returns 0 */
	return 0;
}
/* always returns 0 */
/* 32BF */
void func_32BF(void)
{
	func_32B9(); /* always returns 0 */
	if (sensor_paper_end_debounced()) [0x9929] = 0x0166;
	else                              [0x9929] = 0x0000;
	return 0;
}
/* always returns 0 */
/* 32CF */
void func_32CF(void)
{
	if (!func_2E08() || !sensor_paper_end_debounced()) {
		[0xC004] &= ~C004_6; /* 1011 1111 */
		return;
	}
	if (func_32EC()) {
		[0xC004] |= C004_6; /* 0100 0000 */
		return;
	}
	if (!(VV[0x13] & 0xc0)) {
		[0xC004] &= ~C004_6; /* 1011 1111 */
		return;
	}
	[0xC004] |= C004_6; /* 0100 0000 */
	return;
}
/* 32E5 */
int func_32E5(void)
{
	if (VV[0x4f] & 0x20)
		return 0;
	if (VV[0x02] & 0x20)
		return 1;
	return 0;
}
/* 32EC */
int func_32EC(void)
{
	if (VV[0x4f] & 0x20)
		return 1;
	if (VV[0x02] & 0x20)
		return 0;
	return 1;
}
/* always returns 0 */
/* 32F3 */
void func_32F3(void)
{
	if (!(VV[0x02] & 0x20)) HL = 0x992D;
	else                    HL = 0x984D;
	if (!(VV[0x4f] & 0x20)) HL = 0x9931;
	return 0;
}

/* FUCKING IMPORTANT THIS IS 0x3555!!! */
3301: 3555 359a 35d9 3620 3667 36a2 36d1 3722
3311: 374b 378e 3806 3882 38d1 392a 3982 39c7
3321: 3a0c 3a4f 3aca 3b1d 3b6c 3bb7 3bf6 3c2d
3331: 3c85 3d05 3d70 3db5 3dfc 3e43 3e8e 3ecd
3341: 3f38 3f45 3f68 3f99 3fe0 4029 40a3 4123
3351: 4150 4181 41b2 41f9 423c 4269 42a8 42cf
3361: 431a 4361 439c 43e3 442c 446d 44b4 44fd
3371: 4564 45ab 45f2 4619 4646 4685 46c4 4703
3381: 4748 4797 4806 484b 4898 48dd 4920 4965
3391: 49b2 49f9 4a30 4a7b 4aec 4b37 4b86 4bf5
33a1: 4c40 4c8d 4ce0 4d2f 4d70 4db3 4e1e 4e6e
33b1: 4ee9 4f60 4fd7 5016 504b 5096 50cb 50fe
33c1: 510c 5137 517c 51c5 5204 5251 5290 52d1
33d1: 531a 5361 539c 53d9 5444 547f 54c8 550d
33e1: 5554 559f 55ea 562b 566a 56a9 56f0 5768
33f1: 57e3 585a 58dc 5923 5960 5985 59c0 5a0b

3401: 5a52 3dfc 3e8e 5aa3 3d70 3555 3982 39c7
3411: 5b01 5b50 359a 5b8f 5bca 3667 3c2d 392a
3421: 3e43 3b1d 3aca 5c0d 3db5 3620 5c54 35d9
3431: 5c9b 3c85 3d05 5d1d 36d1 3ecd 38d1 5d62
3441: 5dab 5df0 5e2b 5e72 3806 378e 5eb9 5efe
3451: 374b 5f45 5f86 5fc5 6050 3722 60db 6126
3461: 6171 617f 618d 619b 61a9 61b7 61c5 61d3
3471: 61e1 61ef 61fd 620b 6219 6227 6235 6243
3481: 6251 625f 626d 627b 6289 6297 62a5 62b3
3491: 62c1 62cf 62dd 62eb 62f9 6307 6315 6323
34a1: 6331 633f 634d 635b 6369 6377 6385 6393
34b1: 63a1 63af 63bd 63cb 63d9 63e7 63f5 6403
34c1: 6411 3a4f 6456 649b 64de 6525 6576 65c1
34d1: 6604 664f 6696 66e9 6728 677f 67cd 680a
34e1: 6851 6890 68db 691e 6961 6977 698d 69d0
34f1: 36a2 6a17 6a46 6a71 6ab4 6af3 6b32 3f38
3501: 6b65 6ba0 6bdf 6c56 6cae 6d25 6d64 6db8
3511: 6e38 6e75 6eba 6f06 6f51 6f9c 6fd7 700e
3521: 7045 707c 70b3 7107 715a 71ae 71f5 7249
3531: 7294 72d9 734c 73bf 7432 74b4 7533 757a
3541: 75a5 75ec 7639 76c8 771b 774a 777d

/* always returns 0 */
/* 77B1 */
void func_77b1(void)
{
	stepper_vref(0x07);
	[0xC008] = 0x00; /* 0000 0000 */
	[0xC00B] = 0x00; /* 0000 0000 */
	[0xC00A] = 0xba; /* 1011 1010 */
	[0xC009] = 0xb5; /* 1011 0101 */
	[0xC008] = 0x0d; /* 0000 1101 */
	if (sensor_home_position_debounced()) cr_step_array = cr_forward_array;
	else                                  cr_step_array = cr_backward_array;
	stepper_vref(0x06);
	cr_step_ops = 3;
	delay(25);
	do {
		cr_step_check_home(); /* always returns 0 */
	} while (cr_step_ops--);
	stepper_vref(0x07);
	delay(75);
	VV[0x00] |= CR_SEEK_HOME;
/* 77F7: */
	if (!sensor_home_position_debounced()) {
		/* go back home */
		[0x9917] = 0x03E3;
		func_7875(); /* always returns 0 */
	}
/* 7806: */
	[0x9917] = 0x0000;
	func_7888(0x010D); /* always returns 0 */
/* 7810: */
	VV[0x00] &= ~CR_SEEK_HOME;
	cr_step_array = cr_backward_array;
/* 7c5e: */
	stepper_vref(0x06);
	delay(6);

/* 7820: */
	cr_step_ops = 20;
	do {
		cr_step_check_home(); /* always returns 0 */
		if (sensor_home_position() && (VV[0x00] & CR_IS_HOME)) /* 0000 0010 */
			goto got_home;
	} while (cr_step_ops--);
	beep_and_hang(2, 3); /* HANG, never returns */

got_home:
/* 7831 */
	cr_step_check_home(); /* always returns 0 */
/* 7834 */
	cr_step_check_home(); /* always returns 0 */
/* 7837 */
	stepper_vref(0x07);
/* 783c */
	delay(75);
/* 783d: */

	[0x9917] = 0x0003;
	return 0;
}

/* always returns 0 */
/* 7845 */
void cr_step_check_home(void)
{
	VV[0x00] |= CR_IS_HOME; /* 0000 0010 */
	cr_step(); /* always returns 0 */
	delay(3);
	if (!sensor_home_position())
		VV[0x00] &= ~CR_IS_HOME; /* 1111 1101 */
	return 0;
}

/* sets A */
/* 7851 */
int cr_not_full_step(void)
{
	/* there is a bug in this function, it searches 5 items into the array,
	 * which only contains 4 items. */
	uint8_t /* 7860 */ full_steps[4] = { 0x0c, 0x0d, 0x0e, 0x0f };
	uint8_t cur_step = [0xC008];
	for (int i = 0; i < 5; i++)
		if (cur_step == full_steps[i])
			return 0;
	return 1;
}

/* HANG, never returns */
/* 786A */
void beep_and_hang(uint8_t repeat, uint8_t n_beeps)
{
	killall(); /* always returns 0 */
	write_all_93c06(); /* always returns 0 */
	beep_x_y(repeat, n_beeps, 0);
	while(1); /* HANG */
}
/* always returns 0 */
/* 7875 */
void func_7875(void)
{
	if ([0x9917] >= 0x000A)
		func_7888(0x000A); /* always returns 0 */
	return 0;
}
/* always returns 0 */
/* 7888 */
void func_7888(uint16_t val)
{
	do {
		int newval;

		if ([0x9917] == val)
			break;

		main_loop_1(); /* always returns 0 */

		if (VV[0x00] & CR_SEEK_HOME) tm1_array_choice = 1;
		else                         tm1_array_choice = 3;

		VV[0x00] &= 0xBF; /* 1011 1111 */

		newval = val - [0x9917];
		if (newval < 0) {
			VV[0x00] |= 0x40; /* 0100 0000 */
			newval = [0x9917] - val;
		}
		if (newval < 0x001E) {
			newval = 0x001E;
			VV[0x00] ^= 0x40; /* 0100 0000 */
		}
		[0x9949] = newval;

		start_moving_cr(); /* always returns 0 */

/* 78c5 */
		if (!(VV[0x00] & CR_SEEK_HOME))
			VV[0x00] |= 0x01; /* 0000 0001 */

	} while (!(VV[0x00] & CR_SEEK_HOME));

/* jmp 7ba4 */

	main_loop_1(); /* always returns 0 */
	return 0;
}

78D2:
	VV[0x00] |= 0x10; /* 0001 0000 */
	if (VV[0x00] & 0x01) { /* 0000 0001 */
		func_7bb1();
		VV[0x00] &= 0xFE; /* 1111 1110 */
	} else {
		main_loop_1(); /* always returns 0 */
	}
	tm1_array_choice = 3;
	func_1F75(); /* always returns 0 */
	HL = 0x990B;
	DE = [0x9919];
	EA = [HL++];
	BC = [0x02B8];
	EA += BC;
	if (VV[0x00] & 0x04) { /* 0000 0100 */
		EA -= A;
	} else {
		EA += A;
	}
	B = 0x18;
	48 3E              DIV     B
	[DE++] = EA;
	EA = [HL];
	BC = [0x02B8];
	EA += BC;
	if (VV[0x00] & 0x04) { /* 0000 0100 */
		EA -= A;
	} else {
		EA += A;
	}
	A = 0x18;
	EA = EA / A, A = EA % A; /* simultaneously */
	if (!A)
		EA++;
	[DE] = EA;
	func_7BFB(); /* always returns 0 */
	EA = DE;
	int borrow = (EA >= BC);
	EA -= BC;
	if (!borrow)
		goto 7940;
	VV[0x00] |= 0x40; /* 0100 0000 */
	HL = 0x000F;
	int borrow = (EA >= HL);
	EA -= HL;
	if (!borrow)
		goto 7949;
	HL = 0x001E;
	75 20 03           EQIW    VV:20,$03
	74 B7              DSUBNB  EA,HL
	goto 795E
	EA = DE;
	EA -= BC;
	A = 0x0F;
	EA -= A;
	VV[0x00] &= 0xBF; /* 1011 1111 */
	goto 7957
7940:
	HL = 0x0010;
	EA = BC;
	EA -= DE;
	74 BF              DLT     EA,HL
	goto 7950
7949:
	EA = [0x001E];
	VV[0x00] |= 0x40; /* 0100 0000 */
	goto 7957
7950:
	A = 0x0F;
	EA += A;
	VV[0x00] |= 0x40; /* 0100 0000 */
7957:
	HL = 0x9949;
	[HL] = EA;
	start_moving_cr(); /* always returns 0 */
	main_loop_1(); /* always returns 0 */
795E:
	func_1F9F();
	goto 795E
	func_7BFB(); /* always returns 0 */
	A = 0x11;
	EA = HL;
	EA -= BC;
	EA += A;
	HL = EA;
	[0x9949] = HL;
	VV[0x0F] |= 0x02; /* 0000 0010 */
	EA = DE;
	EA -= BC;
	EA--;
	HL = EA;
	[0x994B] = HL;
	tm1_array_choice = VV[0x20];
	VV[0x00] &= 0xBF; /* 1011 1111 */
	start_moving_cr(); /* always returns 0 */
	VV[0x00] &= 0xEF; /* 1110 1111 */
	ETMM = 0x04; /* 0000 0100 */ /* free running, clear at every full count ffffh */
	return 0;

/* always returns 0 */
/* 798D */
void start_moving_cr(void)
{
	func_7BBE(); /* always returns 0 */
	if ((VV[0x00] & 0x10) && (VV[0x00] & 0x04)) /* 0001 0000 */ /* 0000 0100 */
		VV[0x00] ^= 0x40;
	if (VV[0x00] & 0x40) cr_step_array = cr_backward_array; /* 0100 0000 */
	else                 cr_step_array = cr_forward_array;
	switch (tm1_array_choice) {
	case 0: tm1_array = tm1_array_0; break;
	case 1: tm1_array = tm1_array_1; break;
	case 2: tm1_array = tm1_array_2; break;
	case 3: tm1_array = tm1_array_3; break;
	case 4: tm1_array = tm1_array_4; break;
	}
	VV[0x0F] |= 0x90; /* 1001 0000 */
	func_7C1F(); /* always returns 0 */
	if (tm1_array_choice == 4 || tm1_array_choice == 1) {
		VV[0x00] |= CR_HALF_STEP;
		[0x9949] <<= 1;
		[0x994B] <<= 1;
		A = 0x1C;
	}
	cr_step_ops = 14;
	stepper_vref(0x05);
	TMM |= 0xe0; /* 1110 0000 */
	timer1_func = timer1_2;
	VV[0x0F] |= CR_SHOULD_STOP; /* 0000 0001 */
	A = 0xE6;
	TM1 = A;
	clear_interrupt(FT1);
	TMM &= 0x3f; /* 0011 1111 */
	MKL &= 0xfb; /* 1111 1011 */ /* activate INTT1 */
	return 0;
}
/* 7A04 */
void __attribute__((interrupt)) timer1_2(void)
{
	EA = ECNT;
	HL = EA;
	[0x9921] = HL;
	if (!cr_shouldnt_step()) {
		cr_step(); /* always returns 0 */
		exx();
		exa();
		enable_interrupts();
		push(VA);
		push(EA);
		push(BC);
		push(DE);
		push(HL);
		TM1 = tm1_array[cr_step_ops];
		func_7AC4(); /* always returns 0 */
		func_7A99(); /* always returns 0 */
		HL = pop();
		DE = pop();
		BC = pop();
		EA = pop();
		VA = pop();
		return; /* FROM INTERRUPT */
	}
	check_voltage(); /* either returns 0 or resets */
	exx();
	exa();
	enable_interrupts();
	return; /* FROM INTERRUPT */
}
/* 7A34 */
int cr_shouldnt_step(void)
{
	if (!(VV[0x0f] & 0x40) || !(VV[0x0f] & CR_SHOULD_STOP)) /* 0100 0001 */
		return 0; /* cr_step */
	if (VV[0x0f] & CR_SHOULD_STOP) { /* 0000 0001 */
		VV[0x0f] &= ~CR_SHOULD_STOP; /* 1111 1110 */
		if (!(VV[0x0f] & 0x40)) {
			stepper_vref(0x06);
			return 0; /* cr_step */
		}
		stepper_vref(0x07);
		TM1 = 0xc0;
		cr_countdown = 0x0e;
	} else {
		/* VV[0x0f] & 0x40 */
		if (cr_countdown--) {
			VV[0x0f] &= 0xbf; /* 1011 1111 */
			timer1_reset(); /* always returns 0 */
		}
	}
	return 1;
}
/* 7A5A */
void __attribute__((interrupt)) timer1_1(void)
{
	cr_step(); /* always returns 0 */
	exx();
	exa();
	enable_interrupts();
	[0x9949]--;
	return; /* FROM INTERRUPT */
}
/* always returns 0 */
/* 7A6A */
void func_7A6A(void)
{
	VV[0x0f] &= 0xCF; /* 1100 1111 */
	VV[0x0f] |= 0x08; /* 0000 1000 */
	switch (tm1_array_choice) {
	case 0: tm1_array = tm1_array_0+1; break;
	case 1: tm1_array = tm1_array_1+1; break;
	case 2: tm1_array = tm1_array_2+1; break;
	case 3: tm1_array = tm1_array_3+1; break;
	case 4: tm1_array = tm1_array_4+1; break;
	}
	timer1_func = timer1_2;
	if ((VV[0x00] & CR_SEEK_HOME) && (VV[0x00] & 0x40) && (cr_step_ops <= 19)) /* 0100 0000 */
		cr_step_ops = 19;
	return 0;
}
/* always returns 0 */
/* 7A99 */
void func_7A99(void)
{
	if ((VV[0x0f] & CR_SHOULD_STOP) || (VV[0x0f] & 0x40) || (VV[0x0f] & 0x28)) /* 0010 1000 */ /* 08, 20 */
		return 0; /* 7A9C */
	if (!func_7B1D())
		return 0; /* 7AA0 */
	if (VV[0x00] & CR_SEEK_HOME) {
		if (VV[0x00] & 0x40) { /* 0100 0000 */
			if (sensor_home_position()) {
				func_7A6A(); /* always returns 0 */
				return 0;
			} else {
				return 0; /* 7ABD */
			}
		} else {
			if (!sensor_home_position()) {
				func_7A6A(); /* always returns 0 */
				return 0;
			} else {
				return 0; /* 7AC3 */
			}
		}
		return 0;
	}
	if (VV[0x0f] & 0x10)
		return 0; /* 7AA8 */
	if (!sensor_home_position()) {
		VV[0x00] &= ~CR_IS_HOME; /* 1111 1101 */
		return 0; /* 7AB8 */
	}

	if (VV[0x00] & CR_IS_HOME) /* 0000 0010 */
		beep_and_hang(2, 3); /* HANG, never returns */

	VV[0x00] |= CR_IS_HOME; /* 0000 0010 */

	return 0; /* 7AB4 */
}
/* always returns 0 */
/* 7AC4 */
void func_7AC4(void)
{
	if (VV[0x0f] & 0x10) {
		if ((tm1_array_choice == 4 || tm1_array_choice == 1) && (cr_step_ops == 14))
			stepper_vref(0x05);
		cr_step_ops--;
		if (!cr_step_ops) {
			if (tm1_array_choice == 4 || tm1_array_choice == 1) stepper_vref(0x03);
			else                                                stepper_vref(0x05);
			VV[0x0f] &= 0xEF; /* 1110 1111 */
			if (VV[0x0f] & 0x20)
				func_7A6A(); /* always returns 0 */
		}
	} else if (VV[0x0f] & 0x08) {
		cr_step_ops++;
		if (!(VV[0x00] & CR_HALF_STEP)) A = 15;
		else                            A = 29;
		if (cr_step_ops == A) {
			if (!(VV[0x00] & CR_SEEK_HOME) && cr_not_full_step()) {
				cr_step_ops--;
				TM1 = [0x7C9A]; /* 87 */
			} else {
				VV[0x0f] |= CR_SHOULD_STOP; /* 0000 0001 */
				VV[0x0f] |= 0x40; /* 0100 0000 */
				VV[0x0f] &= 0x77; /* 0111 0111 */
				VV[0x00] &= 0xDF; /* 1101 1111 */
			}
		}
	}
	return 0;
}

/* 7B1D */
int func_7B1D(void)
{
	[0x9949]--;

	if (VV[0x00] & CR_SEEK_HOME) {
		if (EA == 0x0000)
			beep_and_hang(2, 3); /* HANG, never returns */
		return 1;
	}

	if (VV[0x0f] & 0x08)
		return 1;

	if (VV[0x00] & CR_HALF_STEP) HL = 0x001D;
	else                         HL = 0x000F;

	if (EA <= HL) {
		if (!(VV[0x0f] & 0x02))
			return 1;
		[0x994B]--;
		if (EA == 0x0000) {
			EA = [0x9921] + [0x9927];
			ETM1 = EA;
			ETM0 = EA + 2;
			if (VV[0x06] & 0x10) {
				etimer_func = etimer_3;
				timer1_func = timer1_1;
			} else {
				etimer_func = etimer_2;
				timer1_func = timer1_1;
			}
			ETMM = 0x0c; /* 0000 1100 */ /* Clear when ECNT = ETM1 */
			VV[FLAGS_1] |= 0x20; /* 0010 0000 */
			skit(FE1);
			skit(FE0);
			func_2322(); /* ignore rets, there's a nop after this */
			MKL &= 0xbf; /* 1011 1111 */ /* activate INTE1 */
			VV[FLAGS_1] |= 0x80; /* 1000 0000 */
			return 0;
		}
		return 1;
	}

	func_7A6A(); /* always returns 0 */

	return 0;
}

/* always returns 0 */
/* 7B4D */
void cr_step(void)
{
	uint8_t cur_step = [0xC008];
	if (!(VV[0x00] & CR_HALF_STEP)) {
		cur_step = cr_step_array[cur_step];
		[0xC008] = cur_step;
	}
	[0xC008] = cr_step_array[cur_step];
	check_voltage(); /* either returns 0 or resets */
	return 0;
}

/* forward */
/* 7B66 */
uint8_t cr_forward_array[0x10] = {
	0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0F, 0x0C, 0x0D,
	0x0D, 0x0D, 0x0D, 0x0E, 0x08, 0x05, 0x06, 0x0B,
	}
/* 1101 1101 1101 1101 1101 1111 1100 1101 1101 1101 1101 1110 1000 0101 0110 1011 */
/* sequence: d, 5, f, b, e, 6, c, 8, d */

/* backward */
/* 7B76 */
uint8_t cr_backward_array[0x10] = {
	0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0E, 0x0D,
	0x0C, 0x0D, 0x0D, 0x0F, 0x06, 0x08, 0x0B, 0x05,
	}
/* 1101 1101 1101 1101 1101 1101 1110 1101 1100 1101 1101 1111 0110 1000 1011 0101 */
/* sequence: d, 8, c, 6, e, b, f, 5, d */

/* 1-2 phase excitation (SLA7020M) */
INA tdA INB tdB
1   0   0   0
1   0   0   1
1   0   1   0
1   1   1   0
0   0   1   0
0   0   1   1
0   0   0   0
0   1   0   0
/* from run dump, invert bits, switch bit0 with bit3 */
/* original */
!tdB!tdA!INB!INA
1   0   1   1
1   1   1   1
0   1   0   1
1   1   0   1
1   0   0   0
1   1   0   0
0   1   1   0
1   1   1   0
/* inverted */
tdB tdA INB INA
0   1   0   0
0   0   0   0
1   0   1   0
0   0   1   0
0   1   1   1
0   0   1   1
1   0   0   1
0   0   0   1
/* switch bits */
INA tdA INB tdB
0   1   0   0
0   0   0   0
0   0   1   1
0   0   1   0
1   1   1   0
1   0   1   0
1   0   0   1
1   0   0   0
/* it's going backwards! it's going back home =D */

/* 7B86 */
int sensor_home_position_debounced(void)
{
	do {
		A = read_stable_PA();
		delay(10);
		B = read_stable_PA();
	} while (A != B);
	if (A & 0x01)
		return 0;
	return 1;
}
/* 7B95 */
int sensor_home_position(void)
{
	/* CN7 (Home Position, HP, active low) */
	if (read_stable_PA() & 0x01)
		return 0;
	return 1;
}

/* THIS SEEMS TO BE THE MAIN LOOP FOR NOW */
/* always returns 0 */
/* 7BA4 */
void main_loop_1(void)
{
	while ((VV[0x0f] & 0x80) || (VV[0x0f] & 0x40)) { /* 1100 0000 */
		if (VV[0x00] & 0x10) /* 0001 0000 */
			func_1F9F(); /* ignore rets, there's a nop after this */
		check_gate_array_input(); /* always returns 0 */
	}
}
/* always returns 0 */
/* 7BB1 */
void func_7bb1(void)
{
	while ((VV[0x0f] & 0x80) || (VV[0x0f] & 0x40) || VV[0x01] & 0x30) {
		if (VV[0x00] & 0x10) /* 0001 0000 */
			func_1F9F(); /* ignore rets, there's a nop after this */
		check_gate_array_input(); /* always returns 0 */
	}
}
/* always returns 0 */
/* 7BBE */
void func_7BBE(void)
{
	while (1) {
		main_loop_1(); /* always returns 0 */
		if (!(VV[0x0f] & 0x02))
			return 0;
		if (!(VV[0x01] & 0x10) && !(PC & 0x04))
			break;
		func_1F9F(); /* ignore rets, there's a nop after this */
		check_gate_array_input(); /* always returns 0 */
	}
	disable_interrupts();
	if (VV[0x01] & 0x20) { /* 0010 0000 */
		MKL |= 0x20; /* 0010 0000 */ /* mask INTE0 */
		VV[0x01] &= 0xDF; /* 1101 1111 */
	}
	enable_interrupts();
	return 0;
}
/* I have assumed DE, EA, HL, and CY are not used after this function returns */
/* always returns 0 */
/* 7BD5 */
void func_7BD5(void)
{
	VV[0x00] &= 0xFB; /* 1111 1011 */
	if (VV[0x00] & 0x08) /* 0000 1000 */
		return 0;
	EA  = ([0x990D] + [0x990B]) >> 1;
	EA /= 0x18; /* 24 */
	EA += 0x1D; /* 29 */
	if (EA < [0x9917])
		VV[0x00] |= 0x04; /* 0000 0100 */
	return 0;
}
/* always returns 0 */
/* 7BFB */
void func_7BFB(void)
{
	if (!(VV[0x00] & 0x04)) { /* 0000 0100 */
		BC = [0x9917];
		DE = [0x9919];
		HL = [0x991b];
	} else {
		BC = 0x0363 - [0x9917];
		DE = 0x0363 - [0x991b];
		HL = 0x0363 - [0x9919];
	}
	return 0;
}
/* always returns 0 */
/* 7C1F */
void func_7C1F(void)
{
	uint16_t val;
	if (!(VV[0x00] & 0x40)) { /* 0100 0000 */
		val = [0x9917] + [0x9949];
		if (val <= 0x01F4) {
			[0x9917] = val;
			return 0;
		}
		[0x9949] = 0x0213 - val + [0x9949];
		[0x9917] = 0x0213;
		return 0;
	}
	val = [0x9917] - [0x9949];
	if (val >= 0x0029) {
		[0x9917] = val;
		return 0;
	}
	[0x9949] = - 0x000A + val + [0x9949];
	[0x9917] =   0x000A;
	return 0;
}

void stepper_vref(int v)
{
	/* v from 0 to 7 */
	PA = v << 3;
	return;
}

/* 0x7C6E */
uint8_t tm1_array_0[] = { 0x2b, 0x2b, 0x2b, 0x2c, 0x2d, 0x2e, 0x30, 0x32,
                          0x35, 0x39, 0x3f, 0x47, 0x52, 0x62, 0x8a, 0xe6, };
/* 0x7C7E */
uint8_t tm1_array_1[] = { 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b,
                          0x2b, 0x2b, 0x2b, 0x2c, 0x2c, 0x2d, 0x2e, 0x2f,
                          0x30, 0x31, 0x32, 0x35, 0x37, 0x3a, 0x3d, 0x41,
                          0x45, 0x4d, 0x59, 0x6c, 0x87, 0xe6, };
/* 0x7C9C */
uint8_t tm1_array_2[] = { 0x1b, 0x1b, 0x1b, 0x1c, 0x1d, 0x1f, 0x21, 0x23,
                          0x26, 0x2a, 0x2f, 0x35, 0x3d, 0x49, 0x60, 0xe6, };
/* 0x7CAC */
uint8_t tm1_array_3[] = { 0x20, 0x20, 0x20, 0x21, 0x22, 0x23, 0x24, 0x26,
                          0x29, 0x2d, 0x31, 0x38, 0x40, 0x4a, 0x60, 0xe6, };
/* 0x7CBC */
uint8_t tm1_array_4[] = { 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x21,
                          0x21, 0x21, 0x21, 0x22, 0x22, 0x23, 0x23, 0x24,
                          0x25, 0x26, 0x27, 0x28, 0x2a, 0x2d, 0x30, 0x35,
                          0x3b, 0x46, 0x52, 0x67, 0x87, 0xe6, 0x8e, };

7CDB:
	77 00              EQI     A,$00
	return 0;
	8E                 CALT    ($009C)
	C = A;
	push(BC);
	8E                 CALT    ($009C)
	BC = pop();
	B = A;
	8E                 CALT    ($009C)
	if (A == 0x00)
		goto 7D32;
	if (A == 0x01) {
		8E                 CALT    ($009C)
		if (A != 0xfe)
			return 0;
		8E                 CALT    ($009C)
		if (A != 0x80)
			return 0;
		A = VV[DIPSW1] ^ 0xff;
		func_7D9B(); /* always returns 0 */
		A = VV[DIPSW2] ^ 0xff;
		A &= 0x0f;
		func_7D9B(); /* always returns 0 */
		func_1B05(); /* always returns 0 */
		return 0;
	}
	if (A == 0x03)
		goto 7D10;
	if (A == 0x04)
		goto 7CFA;
	return 0;
7CFA:
	func_1B05(); /* always returns 0 */
	8E                 CALT    ($009C)
	77 FB              EQI     A,$FB
	return 0;
	8E                 CALT    ($009C)
	77 02              EQI     A,$02
	return 0;
	8E                 CALT    ($009C)
	C = A;
	B = 0x80;
	40 88 2B           CALL    $2B88
	A = 0x0C;
	func_3012(); /* always returns 0 */
	return 0;
7D10:
	40 FD 16           CALL    $16FD
	8E                 CALT    ($009C)
	77 FC              EQI     A,$FC
	return 0;
	8E                 CALT    ($009C)
	77 81              EQI     A,$81
	return 0;
	8E                 CALT    ($009C)
	37 03              LTI     A,$03
	return 0;
	VV[0x06] |= 0x80;
	if (A == 0x00)
		VV[0x06] &= 0x5F;
	if (A == 0x01)
		VV[0x06] |= 0x20;
	if (A == 0x02)
		VV[0x06] &= 0xdf;
	return 0;

7D32:
	8E                 CALT    ($009C)
	if (A != 0xff)
		return 0;
	8E                 CALT    ($009C)
	if (A != 0x00)
		return 0;
	8E                 CALT    ($009C)
	37 02              LTI     A,$02
	return 0;
	if (A != 0x00)
		A = 0x02;
	5D 06              BIT     5,VV:06
	if (++A)
		EA = 0x7D7C;
	EA += A;
	HL = EA;
	A = [HL];
	[9846] = A;
	EA = 0x0D21;
	EA += A;
	HL = EA;
	EA = 0x9850;
	EA += A;
	A = [HL];
	HL = EA;
	B  = A;
	push(HL);
	push(BC);
	8E                 CALT    ($009C)
	BC = pop();
	HL = pop();
	A += B;
	3B                 STAX    (HL)
	8E                 CALT    ($009C)
	return 0;
	40 C9 15           CALL    $15C9
	func_1514(); /* always returns 0 */
	func_152F(); /* always returns 0 */
	goto 7D78;
	func_152B(); /* always returns 0 */
	40 C9 15           CALL    $15C9
7D78:
	40 D6 04           CALL    $04D6
	return 0;

7D7C: DW: 03 00 04 01 00

/* always returns 0 */
void func_7D9B(void)
{
	EA = byte_to_char(A);
	print_this_char = EAL;
	push(EA);
	func_05CD(); /* always returns 0 */
	EA = pop();
	print_this_char = EAH;
	func_05CD(); /* always returns 0 */
	return 0;
}
