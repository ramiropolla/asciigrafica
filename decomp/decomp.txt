/* VV */
#define FLAGS_1           0x10
#define FLAGS_1_SHORTBEEP (1<<2) /* 0x04 */

#define PRINT_THIS_CHAR   0x15
#define DIPSW1            0x31
#define DIPSW2            0x32
#define CHARTABLE_FIELD_1 0x3f
#define ADDRESS_93C06     0x42
#define CHECKSUM_93c06    0x56

/* 99 */
uint16_t *data_buffer_size = 0x9915;
uint16_t *data_buffer_wptr = 0x9911;
uint16_t *data_buffer_rptr = 0x9913;

#define DATA_BUFFER_FULL 0x02

0000: goto _start;                     /* reset */
0004: goto irq_nmi;                    /* IRQ 0 */ /* INTNMI */
0008: exx();                           /* IRQ 1 */ /* INTFT0, INTFT1 */
0009: exa();
000A: goto 9817;
0010: 00                 NOP           /* IRQ 2 */
0018: exx();                           /* IRQ 3 */
0019: exa();
001A: goto 981A;
0020: 00                 NOP           /* IRQ 4 */
0028: goto irq_serial;                 /* IRQ 5 */ /* INTSR, INTST */ /* serial */

002B: void delay(C ms){}
0041: [HL]--; return;

0050: 48 29              CALB    
0052: return 1;
0053: return 0;
0060: 00                 NOP          /* IRQ 6 */

0080: 002B /* DONE */ delay(C ms);
0082: 1057 /* DONE */ one_short_beep();
0084: 1325
0086: 14ec
0088: 00ca /* DONE */ EA = mul24(EA, A);
008A: 170F
008C: 16f7
008E: 0feb /* DONE */ sw_form_feed();
0090: 0f01 /* DONE */ sw_online_wait(); /* always returns 0 */
0092: 10A1 /* DONE */ { [C004] |= A; }
0094: 109B /* DONE */ { [C004] &= A; }
0096: 1b05 /* DONE */ func_1B05(); /* always returns 0 */
0098: 1c93 /* DONE */ func_1C93();
009A: 2089
009C: 2116
009E: 21F3
00A0: 2E3A sw_cn6_debounced();
00A2: 313F /* DONE */ func_313F(); /* always returns 0 */
00A4: 78D2
00A6: 7BA4 /* DONE */ main_loop_1(); /* always returns 0 */
00A8: 7B4D /* DONE */ func_7B4D(); /* always returns 0 */
00AA: 798D /* DONE */ func_798D(); /* always returns 0 */
00AC: 7B95 /* DONE */ sw_cn7();
00AE: 1680
00B0: 1B02 /* DONE */ func_1B02(); /* always returns 0 */
00B2: 0050
00B4: 242B /* DONE */ { if (D > 0x97) D = 0x90; if (D < 0x90) D = 0x97; }
00B6: 28F4 /* DONE */ func_28F4();
00B8: 05A5 /* DONE */ { memset(EA, 0x00, B*255+C); A = 0x00; }
00BA: 216F
00BC: 1334
00BE: 0041 /* DONE */ { [HL]--; }

/* bitmask for bit n, 0 = 00000001, 1 = 00000010, etc */
/* always returns 0 */
/* 00C0 */
uint8_t bitmask(uint8_t A)
{
	B = 0x00;
	carry = 1;
	do {
		B = (B << 1) | carry;
		carry = 0;
	} while (A--);
	A = B;
	return A;
}

/* 00CA */
uint16_t mul24(uint16_t EA, uint8_t A)
{
	/* uses EA, BC, and A */
	uint8_t h = in16 >> 8;
	uint8_t l = in16 & 0xff;
	uint16_t mh = (uint16_t) in8 * h;
	uint16_t ml = (uint16_t) in8 * l;
	uint16_t r = 0;
	if (mh & 0xff00) {
		/* check is wrong, we don't care */
		carry = 1;
	} else {
		r =   mh;
		r <<= 8;
		r +=  ml;
	}
	return r; /* EA */
}

int skit(int interrupt)
{
	int ret = (IRR & interrupt);
	IRR &= ~interrupt;
	return ret;
}

#if 0
Epson LX-800 Technical Manual.pdf

When the printer is initialized, the following operations are performed:
a. Seek to carriage home position.
b. Set to ON-LINE mode.
c. Clear the all buffers.
d. Set the line spacing to 1/6 inches.
e. Set the page length to 11 or 12 inches, according to the DIP switch.
f. Clear all vertical tab positions.
g. Set the horizontal tab position to every 8 columns.
i. Set the print mode according to the DIP switches.
#endif

_start:
	/* 1>>> Clears all port outputs. Executes the program from address OH. */
	/* 2>>> Sets up the I/O ports. Initializes the CR and PF motors. */
	/* 3>>> Clears the memory. Sends the ACK signal to the host computer via the interface. */
	/* 4>>> Detects the HOME signal. Outputs motor phase data. */
	/* 5>>> Initializes the gate array. (Outputs the instructions to the gate array.) */
	/* 6>>> Reads the DIP switch settings on the optional interface board if the board is installed. */
	/* 7>>> Checks whether the paper is set or not. Sends the result to the gate array. */
	/* 8>>> Enters the interface waiting state (main routine for data processing). */
	V     = 0xff;
	SP    = 0x0000; /* set stack pointer to internal ram */
	MM    = 0x0f; /* 64k EPROM | Internal RAM Access */
	PORTA = b00111000;
	MA    = b11000111; /* 0 = output; 1 = input */
	MB    = b11111111; /* 0 = output; 1 = input */
	EOM   = b10011001; /* to set LVx, output LVx */
	MCC   = b11001011; /* 0 = port mode; 1 = control mode; CO1 output, CO0 output, TI Input, RxD, TxD */
	PORTC = b00000000;
	MC    = b00001010; /* 0 = output; 1 = input */

	/* wait for input voltage to be above 24V (Epson LX-800 Technical Manual.pdf, page 44) */
	B = 0x02; /* 0000 0010 */
	do {
		C = 0xff;
		ANM = 0x08; /* scan mode, AN4 - AN7, more than 9MHz */
		while (!skit(FAD) || C--); /* wait for 0x100 AD conversions */

		A = CR1;
		if (!(B & 0x02))
			break;
		if (A >= 0xCA)
			B = 0xfd; /* 1111 1101 */
	} while (1);

	if (A < 0xCA || skit(NMI))
		reset();

	[0xC004] = 0x81;
	memset(0xff00, 0xFF, 0x100);
	memset(0xff00, 0x00, 0x100);
	if ([0xffff] != 0x00)
		beep_endlessly(); /* HANG */

	reset_ram(0xff);
	reset_ram(0x00);

	[9841] = 0x01;
	SP  = 0xa000; /* set stack pointer now that we know the ram is ok */
	VV  = 0x98xx;
	VV' = 0x98xx;
	clear_interrupt(F2); /* ONLINE BUTTON */
	EI(); /* enable interrupts */
	read_dipsw_to_ram();
	/* 0165 */
	MB  = b11111101; /* 0 = output; 1 = input */ /* 93c06.DI = input */
	read_all_93c06(); /* always returns 0 */
	[9817] = 0x54; /* JMP instruction */
	[981a] = 0x54; /* JMP instruction */
	func_0BF7(); /* always returns 0 */
	VV[0x41] &= 0xfe;
	func_02CC(); /* always returns 0 */
	func_2033(); /* always returns 0 */
	func_2023(); /* always returns 0 */
	func_2313(); /* always returns 0 */
	VV[0x4f] &= 0xf7;
	VV[0x4f] |= 0x40;
	40 B1 77           CALL    $77B1
	/* DEBUG DOESN'T REACH HERE */
	func_2AFA(); /* always returns 0 */
	func_19A0(); /* always returns 0 */
0195:
	9D                 CALT    ($00BA)
	5B 4F              BIT     3,VV:4F
	HL = 0x2D00;
	HL = 0x4C80;
	[993D] = HL;
	func_2B5A(); /* always returns 0 */
	func_10A8(); /* always returns 0 */
	40 33 02           CALL    $0233
	55 14 20           OFFIW   VV:14,$20
	goto 01C4;
	40 5B 0F           CALL    $0F5B
	if (VV[0x03] & 0x02) goto 0350;
	if (VV[0x03] & 0x04) goto 0392;
	if (VV[0x14] & 0x04) goto 043E;
01C4:
	40 CF 01           CALL    $01CF
	40 38 13           CALL    $1338
	goto 01C4;
	40 CD 05           CALL    $05CD
	goto 01C4;

01CF:
	40 A2 0E           CALL    $0EA2
	func_2089(); /* always returns 0 */
	if (!func_2127())
		goto 01CF;
	return 0;

/* 01D8 */
void read_dipsw_to_ram()
{
	uint16_t dip;
	do {
		dip = read_dipsw();
	} while (dip != read_dipsw());
	if (!(SW2 & 0x80))
		VV[0x11] |= 0x80;
	VV[DIPSW1] = SW1;
	VV[DIPSW2] = SW2 & 0x7f;
}

/* C = SW1, B = SW2 */
/* 01F1 */
uint16_t read_dipsw(void)
{
	C = PB; /* DIP SW1 */
	B = 0;
	wait_for_ADC(0x00); /* scan mode, AN0 - AN3, more than 9MHz */
	if (CR0 & 0x80)	B |= 0x01;	/* DIP SW2.1 */
	if (CR1 & 0x80)	B |= 0x02;	/* DIP SW2.2 */
	if (CR2 & 0x80)	B |= 0x04;	/* DIP SW2.3 */
	if (CR3 & 0x80)	B |= 0x08;	/* DIP SW2.4 */
	wait_for_ADC(0x08); /* scan mode, AN4 - AN7, more than 9MHz */
	if (CR0 & 0x80)	B |= 0x10; /* bar{SLCT IN} */
	if (CR3 & 0x80)	B |= 0x80; /* don't know */
}

/* 022B */
void wait_for_ADC(uint8_t A)
{
	ANM = A;
	while (!(IIR & FAD));
	return 0;
}

0233:
	A = VV[DIPSW1];
	if (!(A & 0x01)) {
		push(VA);
		40 10 15           CALL    $1510
		VA = pop();
	}
	if (!(A & 0x02))
		VV[0x04] |= 0x40;
	if (!(A & 0x08)) {
		if (A & 0x04) HL = 0x072C;
		else          HL = 0x09D8;
	} else {
		if (A & 0x04) HL = 0x0948;
		else          HL = 0x0A20;
	}
	[0x992D] = HL;
	[0x9931] = HL;
	if (A & 0x10) {
		VV[0x04] &= 0xf8;
		if (A & 0x80) VV[0x0c] |= 0x01;
		if (A & 0x40) VV[0x0c] |= 0x02;
		if (A & 0x20) VV[0x0c] |= 0x04;
	} else {
		VV[0x04] |= 0x30;
		if (A & 0x80) VV[0x04] |= 0x01;
		if (A & 0x40) VV[0x04] |= 0x02;
		if (A & 0x20) VV[0x04] |= 0x04;
		VV[0x0C] = 0x00;
	}
	A = VV[DIPSW2];
	if (!(A & 0x01)) VV[0x14] |= 0x01;
	VV[0x02] &= 0xdf;
	if (!(A & 0x02)) VV[0x02] |= 0x20;
	EA = HL;
	B = 0x00;
	if (!(A & 0x04)) B = 0xD8;
	EA -= B;
	HL = EA;
	[0x992F] = HL;
	if (!(A & 0x08))	VV[0x02] |= 0x80;
	if (A & 0x10)
		VV[0x02] |= 0x0c;
	[0x9806] = 0x10;
	55 4F 04           OFFIW   VV:4F,$04
	40 F8 14           CALL    $14F8
	40 2B 15           CALL    $152B
	58 4F              BIT     0,VV:4F
	40 2F 15           CALL    $152F
	59 4F              BIT     1,VV:4F
	goto 15CD;
	goto 15C9;

/* always returns 0 */
/* 02CC */
void func_02CC(void)
{
	if (!sw_line_feed()) {
		if (!sw_form_feed()) {
			if (!sw_load_eject())
				return 0;
			wait_for_button(); /* always returns 0 */
			return 0;
		}
		if (!sw_load_eject()) {
			VV[0x4F] |= 0x01;
			VV[0x03] |= 0x02;
			VV[0x11] |= 0x40;
			one_short_beep(); /* always returns 0 */
			return 0;
		}
		clear_93c06_partially(); /* always returns 0 */
		wait_for_button(); /* always returns 0 */
		return 0;
	}
	if (!sw_form_feed()) {
		if (!sw_load_eject()) {
			VV[0x4f] &= 0xfe;
			VV[0x03] |= 0x02;
			VV[0x11] |= 0x40;
			one_short_beep(); /* always returns 0 */
			return 0;
		}
		func_0309(); /* always returns 0 */
		one_short_beep(); /* always returns 0 */
		return 0;
	}
	VV[0x03] |= 0x04;
	one_short_beep(); /* always returns 0 */
	return 0;
}

/* always returns 0 */
/* 0309 */
void func_0309(void)
{
	beep_x_y(1, 2, 1); /* 1054 */
	wait_for_button(); /* always returns 0 */
	EA = 0000;
	push(EA);
	do {
		EA = pop();
		if (!func_0348())
			return 0;
		push(EA);
	} while (!sw_form_feed());
	one_short_beep(); /* always returns 0 */
	wait_for_button(); /* always returns 0 */
	do {
		EA = pop();
		if (!func_0348())
			return 0;
		push(EA);
	} while (!sw_line_feed());
	one_short_beep(); /* always returns 0 */
	wait_for_button(); /* always returns 0 */
	do {
		EA = pop();
		if (!func_0348())
			return 0;
		push(EA);
	} while (!sw_load_eject());
	one_short_beep(); /* always returns 0 */
	wait_for_button(); /* always returns 0 */
	do {
		EA = pop();
		if (!func_0348())
			return 0;
		push(EA);
	} while (!sw_form_feed());
	EA = pop();
	VV[0x14] |= 0x04;
	return 0;
}

/* 0348 */
int func_0348(void)
{
	EA++;
	DE = 0xFF00;
	if (EA == DE)
		return 0;
	return 1;
}

0350:
	40 B9 0D           CALL    $0DB9
	HL = 038B;
	40 F4 08           CALL    $08F4
	40 82 2B           CALL    $2B82
	wait_for_button(); /* always returns 0 */
	40 0A 09           CALL    $090A
	A = 0x20;
	VV[0x28] = A;
0366:
	push(VA);
	40 A2 0E           CALL    $0EA2
	VA = pop();
	VV[0x16] = A;
	VV[PRINT_THIS_CHAR] = A;
	40 E4 05           CALL    $05E4
	40 B1 08           CALL    $08B1
	goto 0377
	goto 0381
0377:
	86                 CALT    ($008C)
	A = VV[0x28];
	40 34 04           CALL    $0434
	VV[0x28] = A;
	goto 0366
0381:
	40 1B 22           CALL    $221B
	A = VV[0x16];
	40 34 04           CALL    $0434
	goto 0366

038B: DW: 50 53 32 34 31 34 00
          "PS2414"

0392:
	40 2F 15           CALL    $152F
	40 FC 14           CALL    $14FC
	HL = 0403;
	40 F4 08           CALL    $08F4
	40 82 2B           CALL    $2B82
	wait_for_button(); /* always returns 0 */
	BC = 0000;
03A7:
	push(BC);
	clear_80_spaces(); /* always returns 0 */
	BC = pop();
03AC:
	push(BC);
	40 CF 01           CALL    $01CF
	BC = pop();
	EA = [0x000F];
	EA &= BC;
	DE = EA;
	EA = [0xFF06];
	EA += DE;
	EA += DE;
	EA += DE;
	DE = EA;
	push(VA);
	40 20 04           CALL    $0420
	VA = pop();
	EA = [0x000F];
	EA &= BC;
	DE = EA;
	EA = [0xFF37];
	EA += DE;
	DE = EA;
	push(BC);
	B = A;
	B &= 0x7f;
	74 3A 20           LTI     B,$20
	74 6A 7F           NEI     B,$7F
	A = 0x2e;
	[DE] = A;
	BC = pop();
	55 03 01           OFFIW   VV:03,$01
	goto 03F3
	DE = 0xFF00;
	A = B;
	40 20 04           CALL    $0420
	A = C;
	40 20 04           CALL    $0420
	VV[0x03] |= 0x01
03F3:
	BC++;
	74 5B 0F           OFFI    C,$0F
	goto 03AC
	push(BC);
	HL = 0xFF00;
	40 F4 08           CALL    $08F4
	BC = pop();
	goto 03A7

0403: DW: 44 61 74 61 20 44 75 6D 70 20 4D 6F 64 65 00
          "Data Dump Mode"

0412:
	HL = 0xFF00;
	func_08FE();
	clear_80_spaces(); /* always returns 0 */
	func_1B05(); /* always returns 0 */
	40 07 17           CALL    $1707
	return 1;

0420:
	[0xFF89] = A;
	40 27 04           CALL    $0427
0427:
	HL = 0xFF89;
	A = 0x30;
	48 38              RLD     
	37 3A              LTI     A,$3A
	A += 0x07;
	[DE++] = A;
	return 0;

0434:
	41                 INR     A
	67 7F              NEI     A,$7F
	A = 0xA0;
	67 FF              NEI     A,$FF
	A = 0x20;
	return 0;
043E:
	beep_x_y(1, 2, 1); /* 1054 */
	40 D8 31           CALL    $31D8 /* returns int */
	40 CC 04           CALL    $04CC
	40 2B 15           CALL    $152B
	40 C9 15           CALL    $15C9
	40 FC 14           CALL    $14FC
	40 14 15           CALL    $1514
	VV[0x46] = 0x04;
	goto 046F
0457:
	65 46 02           NEIW    VV:46,$02
	VV[0x46] = 0x01;
	65 46 01           NEIW    VV:46,$01
	goto 0465
	40 2F 15           CALL    $152F
	goto 046B
0465:
	40 2B 15           CALL    $152B
	40 C9 15           CALL    $15C9
046B:
	BC = 0x8288;
	func_313F(); /* always returns 0 */
046F:
	40 D6 04           CALL    $04D6
	BC = 0x0288;
	func_313F(); /* always returns 0 */
0476:
	48 64              SKNIT   F2 /* ONLINE BUTTON */
	goto 0487
	if (!sw_load_eject())
		goto 047E;
	goto 049A
047E:
	if (!sw_line_feed())
		goto 0484;
	goto 04A9
0484:
	if (!sw_form_feed())
		goto 0476;
	goto 046B
0487:
	wait_for_button(); /* always returns 0 */
	30 46              DCRW    VV:46
	goto 0457
	VV[0x14] &= 0xfb;
	func_0C48(); /* always returns 0 */
	write_all_93c06(); /* always returns 0 */
	goto 0000;
	one_short_beep(); /* always returns 0 */
	wait_for_button(); /* always returns 0 */
	40 B8 04           CALL    $04B8
	37 FF              LTI     A,$FF
	goto 0476
	41                 INR     A
	3B                 STAX    (HL)
	goto 0476
04A9:
	one_short_beep(); /* always returns 0 */
	wait_for_button(); /* always returns 0 */
	40 B8 04           CALL    $04B8
	27 00              GTI     A,$00
	goto 0476
	51                 DCR     A
	3B                 STAX    (HL)
	goto 0476
04B8:
	A = VV[0x46];
	EA = [0x9850];
	EA += A;
	HL = EA;
	A = [HL];
	return 0;

04CC:
	EA -= BC;
	BC = EA;
	40 88 2B           CALL    $2B88
	func_32B9(); /* always returns 0 */
	return 0;

04D6:
	VV[0x2C] = 0x24;
	if (VV[0x46] == 0x04) goto 04F2;
	if (VV[0x46] == 0x03) goto 04EF;
	if (VV[0x46] == 0x01) goto 04EC;
	if (VV[0x46] != 0x00) return 0;
	HL = 0x058A;
04EC:
	HL = 0x0578;
04EF:
	HL = 0x0565;
04F2:
	HL = 0x0553;
	40 9C 05           CALL    $059C
	A = [0x0D21[VV[0x46]]];
	B = A;
	40 B8 04           CALL    $04B8
	60 B2              SUBNB   A,B
	int borrow = (A >= B);
	A -= B;
	if (!borrow)
		goto 0503;
	goto 0511
0503:
	48 3A              NEGA    
	67 00              NEI     A,$00
	goto 0511
	push(VA);
	VV[PRINT_THIS_CHAR] = '-';
	40 CD 05           CALL    $05CD
	VA = pop();
0511:
	EA = byte_to_char(A);
	VV[PRINT_THIS_CHAR] = EAL;
	push(EA);
	40 CD 05           CALL    $05CD
	EA = pop();
	VV[PRINT_THIS_CHAR] = EAH;
	40 CD 05           CALL    $05CD
	VV[PRINT_THIS_CHAR] = 'H';
	40 CD 05           CALL    $05CD
	40 4C 05           CALL    $054C
	86                 CALT    ($008C)
	VV[0x2C] = 0x15;
	VV[0x45] = 0x03;
0533:
	VV[PRINT_THIS_CHAR] = 'H';
	40 E4 05           CALL    $05E4
	40 B1 08           CALL    $08B1
	goto 0541
	40 1B 22           CALL    $221B
	goto 0533
0541:
	40 4C 05           CALL    $054C
	86                 CALT    ($008C)
	30 45              DCRW    VV:45
	goto 0533
	VV[0x2C] = 0x24;
	return 0;

054C:
	25 46 02           GTIW    VV:46,$02
	VV[0x06] &= 0xef;
	return 0;

0553: DW: 4E 4C 51 20 20 20 48 20 2F 41 64 6A 75 73 74 3D 20 00
          "NLQ   H /Adjust= "
0565: DW: 44 72 61 66 74 20 48 20 2F 41 64 6A 75 73 74 3D 20 00 00
          "Draft H /Adjust= "
0578: DW: 4E 4C 51 20 20 20 4C 20 2F 41 64 6A 75 73 74 3D 20 00
          "NLQ   L /Adjust= "
058A: DW: 44 72 61 66 74 20 4C 20 2F 41 64 6A 75 73 74 3D 20 00
          "Draft L /Adjust= "

059C:
	push(HL);
	40 A5 0E           CALL    $0EA5
	HL = pop();
	func_08FE();
	return 0;
05A5: A = 0x00;

05A7: memset(EA, A, B*255+C); A = A;

/* 05B3, 05B5 */
void reset_ram(uint8_t c)
{
	uint8_t last;
	memset(0x9800, c, 0x2000);
	A = [0xb7ff];
	if (A != C) { /* C is 0xff */
		func_0C48(); /* always returns 0 */
		beep_x_y(4, 2, 0); /* 1044 */
		while(1); /* HANG */
	}
	return;
}

/* IMPORTANT looks like function to print char */
05CD:
{
	do {
		A = VV[PRINT_THIS_CHAR];
		push(VA);
		40 E4 05           CALL    $05E4
		40 B1 08           CALL    $08B1
		goto 05DC
		VA = pop();
		40 1B 22           CALL    $221B
		return 0;
05DC:
		86                 CALT    ($008C)
		VA = pop();
		VV[PRINT_THIS_CHAR] = A;
	} while (!(VV[0x05] & 0x01));
	return 0;
}

05E4:
	VV[0x08] &= 0x8c;
	VV[0x08] |= VV[0x0a] & 0x73;
	VV[0x09] &= 0x26;
	VV[0x09] |= VV[0x0b] & 0xd9;
	VV[0x07] &= 0xef;
	if (!(VV[0x09] & 0x02))
		goto 060E;
	if (!(VV[0x09] & 0x80))
		goto 0611;
	if ((VV[0x02] & 0x04) || (VV[0x09] & 0x40))
		VV[0x06] &= 0xef;
	goto 0611
060E:
	55 09 40           OFFIW   VV:09,$40
0611:
	VV[0x08] |= 0x20;
	40 D6 1A           CALL    $1AD6
	goto 0620;
	VV[0x08] |= 0x02;
	VV[0x06] &= 0xef;
	goto 06C6;
0620:
	40 32 06           CALL    $0632
	5C 07              BIT     4,VV:07
	func_07F7(); /* always returns 0 */
0628:
	if ((VV[0x04] & 0x40) && VV[PRINT_THIS_CHAR] == '0')
		VV[PRINT_THIS_CHAR] = 0x7F; /* slashed zero */
	return 0;

0632:
	B = VV[0x04];
	A = VV[PRINT_THIS_CHAR];
	if (A == '_')
		VV[0x09] |= 0x08;
	if (!(A & 0x80))
		return 0;
	if (!(VV[0x04] & 0x20)) {
		if (A & 0x80) {
			VV[0x09] |= 0x80;
			VV[PRINT_THIS_CHAR] &= 0x7f;
		}
		if (VV[PRINT_THIS_CHAR] == '_')
			VV[0x09] |= 0x08;
		return 0;
	}
	B &= 0x07; /* 0000 0111 */
	if (B > 0x04 || B == 0x00)
		goto 0676;
	/* 1, 2, 3, 4 */
	HL = 0x065D;
	B <<= 1; /* 0000 111x */ /* 2, 4, 6, 8 */
	B -= 0x02; /* 0, 2, 4, 8 */
	EA = [HL + B];
	BC = EA;
	48 29              CALB    
	return 0;
	goto 0676

065D: 0708, 0712, 071c, 0726

0676:
	27 AF              GTI     A,$AF
	return 0;
	37 E0              LTI     A,$E0
	goto 069F;
	VV[0x06] &= 0xef;
	55 0A 20           OFFIW   VV:0A,$20
	goto 068F
	55 09 02           OFFIW   VV:09,$02
	goto 068F
	55 09 40           OFFIW   VV:09,$40
	VV[0x08] &= 0xDF;
068F:
	VV[0x08] &= 0xEF;
	VV[0x09] &= 0x3F;
	HL = 0x0628;
	A = [HL+A];
	A |= VV[0x09];
	VV[0x09] = A;
	return 0;
069F:
	77 F4              EQI     A,$F4
	67 F5              NEI     A,$F5
	goto 06AA
	67 FF              NEI     A,$FF
	VV[PRINT_THIS_CHAR] = ' ';
	return 0;
06AA:
	55 0A 20           OFFIW   VV:0A,$20
	goto 06B8
	55 09 02           OFFIW   VV:09,$02
	goto 06B8
	55 09 40           OFFIW   VV:09,$40
	VV[0x08] &= 0xdf;
06B8:
	67 F4              NEI     A,$F4
	VV[0x09] |= 0x10;
	VV[0x08] &= 0xef;
	VV[0x09] &= 0x3f;
	VV[0x06] &= 0xef;
06C6:
	5E 07              BIT     6,VV:07
	return;
	if (VV[0x11] & DATA_BUFFER_FULL)
		VV[0x07] &= 0xbf; /* 1011 1111 */
	return;

06D0:
	VV[0x06] &= 0xef; /* 1110 1111 */
	return;
	VV[0x06] |= 0x10; /* 0001 0000 */
	return;

06D8: exa();
06D9: exa();
06DA: exa();
06DB: exa();
06DC: exa();
06DD: exa();
06DE: exa();
06DF: exa();
06E0: exa();
06E1: exa();
06E2: exa();
06E3: exa();
06E4: 00                 NOP     
06E5: 00                 NOP     
06E6: 00                 NOP     
06E7: exa();
06E8: A = EAH;
06E9: A = EAH;
06EA: EAH = A;
06EB: EAH = A;
06EC: A = EAH;
06ED: EAH = A;
06EE: EAH = A;
06EF: EAH = A;
06F0: A = EAH;
06F1: EAH = A;
06F2: A = EAH;
06F3: EAH = A;
06F4: EAH = A;
06F5: A = EAH;
06F6: EAH = A;
06F7: A = EAH;
06F8: A = EAH;
06F9: EAH = A;
06FA: EAH = A;
06FB: A = EAH;
06FC: A = EAH;
06FD: EAH = A;
06FE: EAH = A;
06FF: EAH = A;
0700: EAH = A;
0701: 00                 NOP     
0702: EAH = A;
0703: EAH = A;
0704: EAH = A;
0705: exa();
0706: EAH = A;
0707: A = EAH;

0708:
	HL = 0x0749;
	B = 0x2E;
	C = 0x00;
	D = 0x09;
	goto 0730;
0712:
	HL = 0x07A7;
	B = 0x0F;
	C = 0x00;
	D = 0x01;
	goto 0730;
071C:
	HL = 0x07C7;
	B = 0x14;
	C = 0x00;
	D = 0x05;
	goto 0730;
0726:
	HL = 0x07F1;
	B = 0x02;
	C = 0x00;
	D = 0x04;
0730:
	do {
		C++;
		HL++;
		if (A == [HL++]) {
			HL -= 2;
			A = [HL];
			VV[PRINT_THIS_CHAR] = A;
			A = D;
			if (A <= C) {
				VV[0x08] |= 0x40;
			} else {
				VV[0x07] |= 0x10;
			}
			return 0;
		}
	} while (B--);
	return 1;

00000749  15 9b 14 9d 9b bd 1f be  0b cf 7c dd 10 f5 16 f9  |..........|.....|
00000759  80 9e 81 a9 82 b5 83 b6  84 b7 85 b8 86 c6 87 c7  |................|
00000769  88 d0 89 d1 8a d2 8b d3  8c d4 8d d5 8e d6 8f d7  |................|
00000779  90 d8 91 de 92 e0 93 e2  94 e3 95 e4 96 e5 97 e7  |................|
00000789  98 e8 99 e9 9a ea 9b eb  9c ec 9d ed 9e ee 9f ef  |................|
00000799  a0 f0 a1 f2 a2 f3 a3 f4  a4 f7 a5 fb a6 fc 86 84  |................|
000007a9  82 86 8a 89 8e 8b 93 8c  87 8e 83 8f 84 91 8c 92  |................|
000007b9  95 94 99 96 91 98 96 99  9b 9d 92 9f 94 a9 10 8f  |................|
000007c9  0b 98 7c a0 16 a4 83 84  a3 86 a1 8d 84 8e 8c 91  |..|.............|
000007d9  8a 92 8b 94 90 95 93 99  9b 9d 9a 9e 9f a1 a4 a5  |................|
000007e9  a6 a6 9e a7 8f a8 a2 ad  15 9b 14 9d 0b af        |..............  |

/* always returns 0 */
/* 07F7 */
void func_07F7(void)
{
	A = VV[PRINT_THIS_CHAR];
	if (A & 0x80 || VV[0x0c] == 0x00)
		return 0;
	HL = 0x0815;
	B = 0x0B;
	do {
		if (A == [HL++]) {
			HL--;
			/* VV[0x0C] from 1 to 0x0d */
			VV[PRINT_THIS_CHAR] = [HL + (VV[0x0C] * 0x0C)];
			return 0;
		}
	} while (B--);
	return 0;
}

/* #$@[\]^`{|}~ */
0815 23 24 40 5b 5c 5d 5e 60 7b 7c 7d 7e
     23 24 00 05 0f 10 5e 60 1e 02 01 16
     23 24 10 17 18 19 5e 60 1a 1b 1c 11
     06 24 40 5b 5c 5d 5e 60 7b 7c 7d 7e
     23 24 40 12 14 0d 5e 60 13 15 0e 7e
     23 0b 1d 17 18 0d 19 1e 1a 1b 0e 1c
     23 24 40 05 5c 1e 5e 02 00 03 01 04
     0c 24 40 07 09 08 5e 60 16 0a 7d 7e
     23 24 40 5b 1f 5d 5e 60 7b 7c 7d 7e
     23 0b 1d 12 14 0d 19 1e 13 15 0e 1c
     23 24 1d 12 14 0d 19 1e 13 15 0e 1c
     23 24 a0 07 09 08 1e 60 a1 0a a2 a3
     23 24 a0 07 09 08 1e 1c a1 0a a2 a3

08B1:
	VV[0x11] &= 0xFB;
	VV[0x05] &= 0xFE;
	A = VV[PRINT_THIS_CHAR];
	BC = [0x9808];
	func_22C9(); /* always returns 0 */
	HL = EA;
	[0x993B] = HL;
	HL = [0x9901];
	EA += HL;
	HL = [0x993d];
	74 AF              DGT     EA,HL
	return 1;
	if (!(VV[0x05] & 0x80))
		return 0;
	if (VV[PRINT_THIS_CHAR] == ' ') {
		VV[0x05] |= 0x01;
		return 0;
	}
	push(EA);
	HL = 0x9947;
	EA = [HL];
	48 A0              DSLR    EA
	HL = [0x993d];
	EA += HL;
	HL = EA;
	EA = pop();
	74 AF              DGT     EA,HL
	return 1;
	VV[0x11] |= 0x04
	return 0;

08F4:
	push(HL);
	40 A5 0E           CALL    $0EA5
	HL = pop();
	func_08FE();
	86                 CALT    ($008C)
	return 0;

void func_08FE(void)
{
	while (1) {
		A = [HL++];
		if (!A)
			return 0;
		VV[PRINT_THIS_CHAR] = A;
		push(HL);
		40 CD 05           CALL    $05CD
		HL = pop();
	}
}

090A:
	HL = 0x09D5;
	A = VV[DIPSW1];
	[0xFF8A] = A;
	40 55 09           CALL    $0955
	40 55 09           CALL    $0955
	A = VV[DIPSW1];
	B = A;
	B &= 0x0c;
	B >>= 2;
	40 5E 09           CALL    $095E
	5D 04              BIT     5,VV:04
	goto 0939
	A = VV[0x04];
	B = A;
	B &= 0x07;
	40 5E 09           CALL    $095E
	while ([HL++] != 0x02);
	while ([HL++] != 0x02);
	goto 0945;
0939:
	while ([HL++] != 0x02);
	40 55 09           CALL    $0955
	A = VV[0x0C];
	B = A;
	40 5E 09           CALL    $095E
0945:
	A = VV[DIPSW2];
	[0xFF8A] = A;
	40 55 09           CALL    $0955
	40 55 09           CALL    $0955
	40 55 09           CALL    $0955
	goto 0955

0955:
	A = [0xFF8A];
	B = !(A & 0x01);
	A >>= 1;
095E:
	push(BC);
	push(HL);
	clear_80_spaces(); /* always returns 0 */
	HL = pop();
	BC = pop();
	DE = 0xFF00;
	strcpy(DE, HL); /* always returns 0 */
	strskip(B); /* always returns 0 */
	DE = 0xFF14; /* 20 */
	strcpy(DE, HL); /* always returns 0 */
	while ([HL++] != 0x01);
	A = [HL];
	if (A != 0xff) {
		DE = 0xFF25; /* 40 */
		func_098E(); /* always returns 0 */
	}
	A = 0x00;
	[DE] = A;
	push(HL);
	HL = 0xFF00;
	40 F4 08           CALL    $08F4
	HL = pop();
	while ([HL++] != 0x02);
	return 0;

void func_098E(void)
{
	do {
		strcpy(DE, HL); /* always returns 0 */
		DE++;
		[DE++] = 0x4F; /* 'O' */
		A = [0xFF8A];
		EA = 0x4646; /* 'FF' */
		if (A & 0x01)
			EA = 0x204E; /* ' O' */
		A >>= 1;
		[DE++] = EA;
		[0xFF8A] = A;
		DE++;
		A = [HL];
	} while (A != 0x02);
}
/* always returns 0 */
/* 09AD */
void clear_80_spaces(void)
{
	[0xFF50] = 0x00;
	memset(0xFF00, ' ', 0x4E);
}
/* always returns 0 */
/* 09BF */
void strcpy(uint8_t *DE, uint8_t *HL)
{
	while (1) {
		A = [HL++];
		if (A == 0x00)
			return 0;
		[DE++] = A;
	}
}
/* always returns 0 */
/* 09CD */
void strskip(uint8_t B)
{
	while (1) {
		if (!B--)
			return 0;
		while ([HL++]);
	}
}

09D5: DW: 43 68 61 72 61 63 74 65 72 20 50 69 74 63 68 00
          "Character Pitch"
09E5: DW: 31 32 20 43 50 49 00
          "12 CPI"
09EC: DW: 31 32 20 43 50 49 00
          "10 CPI"
09F3: DW: 01 31 2D 31 00
             "1-1"
09F8: DW: 02 53 68 61 70 65 20 6F 66 20 5A 65 72 6F 00
             "Shape of Zero"
0A07: DW: 30 20 28 53 6C 61 73 68 65 64 29 00
          "0 (Slashed)"
0A13: DW: 30 20 28 55 6E 73 6C 61 73 68 65 64 29 00
          "0 (Unslashed)"
0A21: DW: 01 31 2D 32 00
             "1-2"
0A26: DW: 02 50 61 67 65 20 4C 65 6E 67 74 68 00
             "Page Length"
0A33: DW: 37 30 2F 36 20 69 6E 63 68 00
          "70/6 inch"
0A3D: DW: 38 2E 35 20 69 6E 63 68 00
          "8.5 inch"
0A46: DW: 31 32 20 69 6E 63 68 00
          "12 inch"
0A4E: DW: 31 31 20 69 6E 63 68 00
          "11 inch"
0A56: DW: 01 31 2D 33 00
             "1-3"
0A5B: DW: 31 2D 34 00
          "1-4"
0A5F: DW: 02 50 43 20 54 61 62 6C 65 00
             "PC Table"
0A69: DW: 55 6E 69 74 65 64 20 53 74 61 74 65 73 00
          "United States"
0A77: DW: 4D 75 6C 74 69 6C 69 6E 67 75 61 6C 00
          "Multilingual"
0A84: DW: 50 6F 72 74 75 67 61 6C 00
          "Portugal"
0A8D: DW: 43 61 6E 61 64 61 2D 46 72 65 6E 63 68 00
          "Canada-French"
0A9B: DW: 4E 6F 72 77 61 79 00
          "Norway"
0AA2: DW: 55 6E 69 74 65 64 20 53 74 61 74 65 73 00
          "United States"
0AB0: DW: 55 6E 69 74 65 64 20 53 74 61 74 65 73 00
          "United States"
0ABE: DW: 55 6E 69 74 65 64 20 53 74 61 74 65 73 00
          "United States"
0ACC: DW: 01 31 2D 35 00
             "1-5"
0AD1: DW: 31 2D 36 00
          "1-6"
0AD5: DW: 31 2D 37 00
          "1-7"
0AD9: DW: 31 2D 38 00
          "1-8"
0ADD: DW: 02 43 68 61 72 61 63 74 65 72 20 54 61 62 6C 65 00
             "Character Table"
0AEE: DW: 47 72 61 70 68 69 63 73 00
          "Graphics"
0AF7: DW: C9 F4 E1 EC E9 E3 F3 00
0AFF: DW: 01 31 2D 35 00
             "1-5"
0B04: DW: 02 43 6F 75 6E 74 72 79 00
             "Country"
0B0D: DW: 55 2E 53 2E 41 2E 00
          "U.S.A."
0B14: DW: 46 72 61 6E 63 65 00
          "France"
0B1A: DW: 47 65 72 6D 61 6E 79 00
          "Germany"
0B23: DW: 55 2E 4B 2E 00
          "U.K."
0B28: DW: 44 65 6E 6D 61 72 6B 00
          "Denmark"
0B30: DW: 53 77 65 64 65 6E 00
          "Sweden"
0B37: DW: 49 74 61 6C 79 00
          "Italy"
0B3D: DW: 53 70 61 69 6E 00
          "Spain"
0B43: DW: 01 31 2D 36 00
             "1-6"
0B48: DW: 31 2D 37 00
          "1-7"
0B4C: DW: 31 2D 38 00
          "1-8"
0B50: DW: 02 53 68 6F 72 74 20 54 65 61 72 2D 6F 66 66 00
             "Short Tear-off"
0B60: DW: 49 6E 76 61 6C 69 64 00
          "Invalid"
0B68: DW: 56 61 6C 69 64 00
          "Valid"
0B6E: DW: 01 32 2D 31 00
             "2-1"
0B73: DW: 02 43 53 46 20 4D 6F 64 65 00
             "CSF Mode"
0B7D: DW: 56 61 6C 69 64 00
          "Valid"
0B83: DW: 49 6E 76 61 6C 69 64 00
          "Invalid"
0B8B: DW: 01 32 2D 32 00
             "2-2"
0B90: DW: 02 53 6B 69 70 20 50 65 72 66 6F 72 61 74 69 6F 6E 00
             "Skip Perforation"
0BA2: DW: 31 20 69 6E 63 68 00
          "1 inch"
0BA9: DW: 4E 6F 6E 65 00
          "None"
0BAE: DW: 01 32 2D 33 00
             "2-3"
0BB3: DW: 02 41 75 74 6F 20 4C 46 00
             "Auto LF"
0BBC: DW: 56 61 6C 69 64 00
          "Valid"
0BC2: DW: 44 65 70 65 6E 64 20 6F 6E 20 49 2F 46 00
          "Depend on I/F"
0BD0: DW: 01 32 2D 34 00
             "2-4"
0BD5: DW: 02 44 72 61 66 74 20 50 72 69 6E 74 20 53 70 65 65 64 00
             "Draft Print Speed"
0BE8: DW: 4E 6F 72 6D 61 6C 00
          "Normal"
0BEF: DW: 48 69 67 68 00
          "High"

0BF4: 01 FF 02

/* always returns 0 */
void func_0BF7(void)
{
	TMM |= 0xe0; /* 1110 0000 */
	             /* ff input clock source: upcounter 0 equals tm0 */
	             /* timer0: internal clock /12, count up */
	             /* timer1: upcounter0 = tm0, reset to 0 and stop counting */
	clear_interrupt(FT1); /* clear FT1 interrupt flag */
	TM1  = 0x26;
	[0x9818] = timer1_0;
	TMM &= 0x3f; /* 0011 1111 */
	             /* timer1: count up, internal clock / 384 */
	MKL &= 0xfb; /* 1111 1011 */ /* activate INTT1 */
	return 0;
}

/* 0C0F */
void __attribute__((interrupt)) timer1_0(void)
{
	check_voltage(); /* either returns 0 or resets */
	exx();
	exa();
	enable_interrupts();
	return; /* FROM INTERRUPT */
}

/* either returns 0 or resets */
/* 0C16 */
void check_voltage(void)
{
	A = CR1;
	if (VV[0x41] & 0x02) { /* 0000 0010 */
		if (A <= 0xb8) { /* less than 21.86 V */
			VV[0x41] |= 0x01; /* 0000 0001 */
			func_0C48(); /* always returns 0 */
			write_all_93c06(); /* always returns 0 */
			[0xC004] = 0xC3;
			reset();
		}
		VV[0x41] &= 0xfd; /* 1111 1101 */
		return 0;
	}
	if (A <= 0xb8) /* less than 21.86 V */
		VV[0x41] |= 0x02; /* 0000 0010 */
	return 0;
}
/* NMI */
/* 0C2A */
void irq_nmi(void)
{
	if (VV != 0x98)
		reset();
	if (!(VV[0x41] & 0x01)) {
		VV[0x41] |= 0x01;
		func_0C48(); /* always returns 0 */
		write_all_93c06(); /* always returns 0 */
		[0xC004] = 0xC3;
		reset();
	}
	enable_interrupts();
	return; /* FROM INTERRUPT */
}

/* always returns 0 */
/* 0C48 */
void func_0C48(void)
{
	MKL    = 0xff; /* mask all interrupts */
	MKH    = 0xff; /* mask all interrupts */
	[0xc005] = 0x0000; /* Latches (and inverts) the data for pin 9 of the printhead. */
	[0xc007] = 0x0000; /* Latches the phase data for the CR motor. */
	EOM   = b10011001; /* to set LVx, output LVx */
	[VV:0x0f] &= 0x3f; /* 0011 1111 */
	[VV:0x01] &= 0xcf; /* 1100 1111 */
	func_0F9C(); /* always returns 0 */
	return 0;
}
/* always returns 0 */
/* 0C64 */
void read_all_93c06(void)
{
	VV[ADDRESS_93C06] = 0x00;
	do {
		93c06.WEN();
		HL = 0x9847;
		B = 0x00;
		C = 0x07;
		do {
			EA = 93c06.READ();
			[HL++] = EA;
			if (EA != 0xffff)
				93c06.ERASE();
			VV[ADDRESS_93C06]++;
			B += EAL + EAH;
		} while (C--);
		if (B == 0x1d)
			goto cksum_ok;
	} while (VV[ADDRESS_93C06] <= 0x08);
	clear_93c06(); /* always returns 0 */
cksum_ok:
	93c06.WDS();
	return 0;
}
/* always returns 0 */
/* 0C9A */
void write_all_93c06(void)
{
	cksum_93c06(); /* always returns 0 */
	93c06.WEN();
	if (VV[ADDRESS_93C06] >= 0x09)
		VV[ADDRESS_93C06] = 0x00;
	HL = 0x9847;
	C = 0x07;
	do {
		EA = [HL++];
		if (EA != 0xffff)
			93c06.WRITE(EA);
		VV[ADDRESS_93C06]++;
	} while (C--);
	93c06.WDS();
	return 0;
}
/* always returns 0 */
/* 0CBF */
void cksum_93c06(void)
{
	A = 0x00;
	HL = 0x9847;
	B = 0x0e;
	do {
		A += [HL++];
	} while (B--);
	[0x9856] = 0x1d - A; /* CHECKSUM_93c06 */
	return 0;
}
/* always returns 0 */
/* 0CD3 */
void clear_93c06(void)
{
	beep_x_y(1, 2, 1); /* 1054 */
	93c06.WEN();
	93c06.ERAL();
	93c06.WDS();
	memcpy(0x9847, 0x0D18, 0x0e);
	return 0;
}
/* always returns 0 */
/* 0CE9 */
void clear_93c06_partially(void)
{
	uint8_t tmp[5];

	beep_x_y(1, 2, 1); /* 1054 */
	93c06.WEN();
	93c06.ERAL();
	93c06.WDS();
	memcpy(tmp, 0x9850, 5);
	memcpy(0x9847, 0x0D18, 0x0e);
	memcpy(0x9850, tmp, 5);
	return 0;
}

/* 93c06 default values */
0D18: DW: 00 00 00 00 00 00 90 12 00 2D 1F 39 37 23 00

/* 0D27 */
uint16_t 93c06.READ(void)
{
	93c06.instruction_addr(READ);
	93c06.DI = 0;
	93c06.clock();
	EA = 0x0000;

	for (i = 0; i < 0x10; i++) {
		EA = (EA<<1) & 93c06.DO;
		93c06.clock();
	}

	return EA;
}
/* 0D52 */
void 93c06.WRITE(uint16_t EA)
{
	93c06.instruction_addr(WRITE);
	93c06.send(EAH);
	93c06.send(EAL);
	93c06.DI = 0;
	93c06.CS = 0;
	delay(10);
	return;
}
/* 0D67 */
void 93c06.ERASE(void)
{
	93c06.instruction_addr(ERASE);
	93c06.DI = 0;
	93c06.CS = 0;
	delay(10);
	return;
}
/* 0D6B */
void 93c06.ERAL(void)
{
	93c06.instruction(ERAL);
	93c06.DI = 0;
	93c06.CS = 0;
	delay(10);
	return;
}
/* 0D6F */
void 93c06.WEN(void)
{
	93c06.instruction(WEN);
	93c06.DI = 0;
	93c06.CS = 0;
	nop();
	return;
}
/* 0D7A */
void 93c06.WDS(void)
{
	93c06.instruction(WDS);
	93c06.DI = 0;
	93c06.CS = 0;
	nop();
	return;
}

void 93c06.instruction(instruction)
{
	93c06.DI = 0;
	93c06.CS = 1;
	93c06.clock();
	93c06.DI = 1; /* start bit */
	93c06.clock();
	93c06.send(A);
	return;
}
void 93c06.instruction_addr(instruction)
{
	A |= VV[ADDRESS_93C06];
	93c06.instruction(A);
}

void 93c06.send(uint8_t A)
{
	B = 0x80;
	do {
		93c06.DI = 0;
		if (A & B)
			93c06.DI = 1;
		93c06.clock();
		B >>= 1;
	} while (B);
	return;
}

0DB9:
	if (!func_32E5())
		return 0;
	40 47 2D           CALL    $2D47
	if (!func_32E5())
		return 0;
	clear_80_spaces(); /* always returns 0 */
	HL = 0x0E0E;
	40 F4 08           CALL    $08F4
	clear_80_spaces(); /* always returns 0 */
	40 34 0E           CALL    $0E34
	EA = [0x1290];
	HL = [0x9A77];
	EA -= HL;
	HL = 0x0142;
	EA += HL;
	HL = 0x984D;
	[HL] = EA;
	A = VV[0x2C];
	EA = EA / A, A = EA % A; /* simultaneously */
	77 00              EQI     A,$00
	EA++;
	40 75 0E           CALL    $0E75
	HL = 0x0E26;
	DE = 0xFF00;
	strcpy(DE, HL); /* always returns 0 */
	printf_2x(B);
	printf_02x(C);
	A = '.';
	[DE] = A;
	HL = 0xFF00;
	40 F4 08           CALL    $08F4
	40 7D 2D           CALL    $2D7D
	return 0;

0E0E: DW: 54 68 69 73 20 69 73 20 74 68 65 20 66 69 72 73 74 20 6C 69 6E 65 2E 00
          "This is the first line."
0E26: DW: 54 68 69 73 20 69 73 20 6C 69 6E 65 20 00
          "This is line "

0E34:
	BC = 0x1290;
	func_313F(); /* always returns 0 */
	BC = 0x011E;
	40 AE 2E           CALL    $2EAE
	goto 2DAE;
	VV[0x13] &= 0xDF;
	return 0;

/* always returns 0 */
/* 0E45 */
void printf_2x(uint8_t A)
{
	/* not really printf("%2x", EA); because it prints nothing on 00 */
	EA = byte_to_char(A);
	if (EAL != '0') [DE++] = A;
	if (EAH != '0') [DE++] = A;
	return 0;
}
/* always returns 0 */
/* 0E51 */
void printf_02x(uint8_t A)
{
	EA = byte_to_char(A);
	[DE++] = EAL;
	[DE++] = EAH;
	return 0;
}
/* takes a byte from 00 to ff and prints it out as '00' to 'FF' */
/* 0E59 */
uint16_t byte_to_char(uint8_t A)
{
	EAL = nibble_to_char(A >>= 4);
	EAH = nibble_to_char(A & 0x0f);
	return EA;
}
/* takes a nibble from 0 to f and prints it out as '0' to 'F' */
/* 0E6E */
char nibble_to_char(uint8_t A)
{
	if (A >= 10)
		A += 7; /* distance from numbers to letters in ASCII */
	A += '0';
	return A;
}

0E75:
	DE = 0x0000;
	A = 0x02;
0E7A:
	B = 0x0A;
	48 3E              DIV     B
	77 02              EQI     A,$02
	goto 0E86
	push(VA);
	A = B;
	E = A;
	VA = pop();
	goto 0E9C
0E86:
	77 01              EQI     A,$01
	goto 0E95
	push(VA);
	push(EA);
	A = 0x10;
	EA = A * B;
	EA += DE;
	DE = EA;
	EA = pop();
	VA = pop();
	goto 0E9C
0E95:
	77 00              EQI     A,$00
	goto 0E9C
	push(VA);
	A = B;
	D = A;
	VA = pop();
0E9C:
	51                 DCR     A
	goto 0E7A
	EA = DE;
	BC = EA;
	return 0;

0EA2:
	40 09 0F           CALL    $0F09

0EA5:
	40 4B 2E           CALL    $2E4B
	goto 0EC2
	40 0A 2F           CALL    $2F0A
	goto 2C2B;
	48 44              SKIT    F2 /* ONLINE BUTTON */
	return 0;
	5C 13              BIT     4,VV:13
	goto 0EBB
	func_2FEF(); /* always returns 0 */
	sw_online_wait();
	return 0;
0EBB:
	55 03 04           OFFIW   VV:03,$04
	40 12 04           CALL    $0412
	func_1B05(); /* always returns 0 */
0EC2:
	func_2FE9(); /* always returns 0 */
	func_0F9C(); /* always returns 0 */
	40 08 2E           CALL    $2E08
	func_31D0(); /* always returns 0 */
0ECE:
	sw_online_wait();
0ECF:
	40 37 2C           CALL    $2C37
	48 44              SKIT    F2 /* ONLINE BUTTON */
	goto 0ECF
	55 13 20           OFFIW   VV:13,$20
	goto 0EE5
	if (!func_2E08())
		goto 0EF3;
	if (func_32EC() || !sw_cn6_debounced())
		goto 0EE5;
	5E 13              BIT     6,VV:13
	goto 0EF3
0EE5:
	40 C0 2C           CALL    $2CC0
	if (VV[0x13] & 0x60)
		goto 0ECE;
	if (func_32E5() || !sw_cn6_debounced())
		goto 0EF3;
	goto 0ECE
0EF3:
	VV[0x13] &= 0xBB;
	40 70 0F           CALL    $0F70
	40 0A 2F           CALL    $2F0A
	goto 2C2B;
	sw_online_wait();
	return 0;

/* always returns 0 */
/* 0F01 */
void sw_online_wait(void)
{
	while (!sw_online_debounced());
	clear_interrupt(F2); /* ONLINE BUTTON */
	return 0;
}

0F09:
	if (VV[0x13] & 0x10)
		return 0;
	if (!sw_form_feed())
		goto 0F33;
	if (!(VV[0x0b] & 0x02) || VV[0x0a] & 0x01)
		goto 0F22;
	beep_x_y(1, 3, 1); /* 1051 */
	VV[0x4F] |= 0x02;
	40 C9 15           CALL    $15C9
	goto 0F57
0F22:
	beep_x_y(1, 2, 1); /* 1054 */
	VV[0x4F] &= 0xFD;
	40 CD 15           CALL    $15CD
	VV[0x4F] |= 0x01
	40 2B 15           CALL    $152B
	goto 0F57
0F33:
	if (!sw_line_feed())
		goto 0F3F;
	one_short_beep(); /* always returns 0 */
	VV[0x4F] &= 0xFE;
	40 2F 15           CALL    $152F
	goto 0F57
0F3F:
	if (!sw_load_eject())
		goto 0F5A;
	5A 0B              BIT     2,VV:0B
	goto 0F50
	beep_x_y(1, 2, 1); /* 1054 */
	VV[0x4F] &= 0xFB;
	40 FC 14           CALL    $14FC
	goto 0F57
0F50:
	one_short_beep(); /* always returns 0 */
	VV[0x4F] |= 0x04
	40 F8 14           CALL    $14F8
0F57:
	wait_for_button(); /* always returns 0 */
0F5A:
	return 0;

0F5B:
	if (!sw_cn6_debounced())
		goto 0F70;
	40 EC 32           CALL    $32EC
	40 7D 2D           CALL    $2D7D
	40 E5 32           CALL    $32E5
	55 01 04           OFFIW   VV:01,$04
	goto 0F70
	func_32CF(); /* always returns 0 */
	goto 0EC2;
0F70:
	VV[0x14] |= 0x40
	[0xC004] &= 0xB3;
	if (VV[0x03] & 0x02)
		return 0;
	[0xC004] |= 0x10;
	if (!(VV[0x11] & 0x80)) {
		if ([0xC002] & 0x80)
			return 0;
		[0xC004] |= 0x20;
		[0xC004] &= 0xDF;
	} else {
		if (VV[0x11] & 0x40)
			return 0;
		MKH &= 0xfd; /* 1111 1101 */ /* activate INTSR */
		A = 0x11;
		TXB = A;
	}
	[0xC004] &= 0xFE;
	[0xC004] |= 0x02;
	return 0;

/* always returns 0 */
void func_0F9C(void)
{
	func_2089(); /* always returns 0 */
	VV[0x14] &= 0xBF;
	[0xC004] &= 0xEF;
	if (!(VV[0x11] & 0x40)) {
		TXB = 0x13;
		[0xC004] |= 0x01;
		delay(1);
	}
	if ((uint16_t)[0xC004] & 0x40) A = 0x0c;
	else                           A = 0x04;
	[0xC004] |= A;
	return 0;
}

/* 0FBF */
void read_stable_PA(void)
{
	do {
		B = PA;
		A = PA;
	} while (A != B);
	/* returns PA in A and B */
}

/* always returns 0 */
/* 0FC8 */
void read_debounced_PA(void)
{
	uint8_t pa1, pa2;
	do {
		pa1 = read_stable_PA();
		delay(10);
		pa2 = read_stable_PA();
	} while (pa1 != pa2);
	A = B = pa1;
	return 0;
}

/* 0FD7 */
void read_stable_PC(void)
{
	do {
		B = PC & 0x3c; /* 0011 1100 */
		A = PC & 0x3c; /* 0011 1100 */
	} while (A != B);
	/* returns PC&0x3c in A and B */
}

/*
 * PA0  R   CN7 sensor
 * PA1  R   CN6 sensor
 * PA2  R   CN4 sensor
 * PA3   W  Stepper motor voltage reference (these 3 pins make up one voltage)
 * PA4   W  Stepper motor voltage reference (these 3 pins make up one voltage)
 * PA5   W  Stepper motor voltage reference (these 3 pins make up one voltage)
 * PA6  R   Line Feed SWITCH
 * PA7  R   Form Feed SWITCH
 */
/* 0FE4 */
int sw_line_feed(void)
{
	A, B = read_stable_PA();
	if (A & 0x40)
		return 0;
	return 1;
}
/* 0FEB */
int sw_form_feed(void)
{
	A, B = read_stable_PA();
	if (A & 0x80)
		return 0;
	return 1;
}
/* 0FF2 */
int sw_load_eject(void)
{
	if (CR2 & 0x80)
		return 0;
	wait_for_AD();
	if (CR2 & 0x80)
		return 0;
	return 1;
}
/* 1003 */
int sw_online(void)
{
	A, B = read_stable_PC();
	if (A & 0x08)
		return 0;
	return 1;
}
/* 1016 */
void func_debounced(uint16_t HL)
{
	if ((HL)())
		return 0;
	delay(10);
	if ((HL)())
		return 0;
	return 1;
}
/* virtual */
int sw_line_feed_debounced()
{
	return func_debounced(0x0FE4);
}
int sw_form_feed_debounced()
{
	return func_debounced(0x0FEB);
}
int sw_load_eject_debounced()
{
	return func_debounced(0x0FF2);
}
int sw_online_debounced()
{
	return func_debounced(0x1003);
}
/* always returns 0 */
/* 1026 */
void wait_for_button(void)
{
	while (!sw_form_feed_debounced() || !sw_line_feed_debounced() || !sw_load_eject_debounced());
	return 0;
}

/* HANG, never returns */
/* 1033 */
void beep_endlessly(void)
{
	while (1) {
		ETMM = 0x00;
		EOM  = 0xb0;
		ETM1 = 0x008c;
		ETMM = 0x0c;
	}
}

void beep_x_y(uint8_t repeat, uint8_t n_beeps, boolean shortbeep)
{
	if (shortbeep)
		VV[FLAGS_1] |= FLAGS_1_SHORTBEEP; /* 0000 0100, bit 2 */
	func_7bb1();
	while (1) {
		for (int i = 0; i <= n_beeps; i++) {
			beep_60ms();
			if (VV[FLAGS_1] & FLAGS_1_SHORTBEEP) delay( 30);
			else                                 delay(100);
		}
		if (!repeat--) {
			VV[10] &= ~FLAGS_1_SHORTBEEP; /* 1111 1011 */
			break;
		}
		if (VV[FLAGS_1] & FLAGS_1_SHORTBEEP) delay(100);
		else                                 delay(200);
	}
	return 0;
}
void one_short_beep(void)
{
	beep_x_y(1, 1, 1); /* 1057 */
}

/* always returns 0 */
/* 1084 */
void beep_60ms(void)
{
	ETMM = 0x00;
	EOM  = 0xb0;
	ETM1 = 0x008c;
	ETMM = 0x0c;
	delay(60);
	EOM  = 0x99;
	return 0;
}

109B:
	HL = 0xC004;
	A &= [HL];
	goto 10A6;
10A1: HL = 0xC004;
	A |= [HL];
10A6:
	[HL] = A;
	return;

/* always returns 0 */
/* 10A8 */
void func_10A8(void)
{
	[0x9830] = 0x03;
	[0x982f] = 0x02;
	[0x982e] = 0x01;
	[0x982d] = 0x00;
	return 0;
}

10B1: 8E                 CALT    ($009C)
	HL = 0x10CD;
	B = 0x03;
10B7:
	70 EF              NEAX    (HL-)
	goto 10BE
	52                 DCR     B
	goto 10B7
	8E                 CALT    ($009C)
	return 0;
10BE:
	push(BC);
	8E                 CALT    ($009C)
	BC = pop();
	A &= 0x0f;
	HL = 0x982D;
	27 06              GTI     A,$06
	BD                 STAX    (HL+B)
	return 0;

	4B 4C              MVIX    HL,$4C
	59 5A              BIT     1,VV:5A
10CE:
	A = VV[0x2D];
	goto 10EE;
10D1:
	A = VV[0x2E];
	goto 10EE;
10D4:
	A = VV[0x2F];
	goto 10EE;
10D7:
	A = VV[0x30];
	goto 10EE;
	8E                 CALT    ($009C)
	A &= 0x0f;
	37 08              LTI     A,$08
	return 0;
	67 07              NEI     A,$07
	goto 10EC;
	goto 10EE;
	8E                 CALT    ($009C)
	A &= 0x0f;
	VV[0x12] |= 0x08;
	37 02              LTI     A,$02
10EC:
	goto 1190;
10EE:
	if (A == 0x02 || A == 0x03) VV[0x12] |= 0x04;
	if (A == 0x05)              VV[0x12] |= 0x60;
	if (A == 0x06)              VV[0x12] |= 0x20;
	A <<= 2;
	HL = 0x1309;
	DE = 0x9821;
	EA = [HL + A];
	[DE++] = EA;
	A += 0x02;
	EA = [HL + A];
	[DE] = EA;
	40 83 12           CALL    $1283
	goto 118C
	VV[0x13] |= 0x02
	40 FA 11           CALL    $11FA
	86                 CALT    ($008C)
	BC = 0x0000;
	HL = [0x993D];
	EA = HL;
	HL = [0x9901];
	EA -= HL;
	A = VV[0x22];
	EA = EA / A, A = EA % A; /* simultaneously */
	DE = EA;
	EA = [0x9941];
	74 AE              DGT     EA,DE
	goto 1144
	VV[0x12] |= 0x10
	[0x9941] = DE;
	EA -= DE;
	BC = EA;
1144:
	[0x993F] = BC;
	DE = [0x9941];
	EA = DE;
	A = VV[0x22];
	EA = mul24(EA, A);
	HL = 0x993B;
	[HL] = EA;
	HL = [0x9941];
	EA = HL;
	55 12 08           OFFIW   VV:12,$08
	EA <<= 1;
	HL = EA;
	EA = [0x1000];
	EA -= HL;
1165:
	HL = *data_buffer_size;
	74 BF              DLT     EA,HL
	goto 1170
	push(EA);
	func_2089(); /* always returns 0 */
	EA = pop();
	goto 1165
1170:
	HL = [0x9901];
	[0x9955] = HL;
	VV[0x03] |= 0x80
	VV[0x05] |= 0x02
	40 A6 11           CALL    $11A6
	VV[0x05] &= 0xFD;
	HL = 0x993F;
	EA = [HL];
1189:
	40 96 11           CALL    $1196
118C:
	VV[0x12] = 0x00;
	return 0;
1190:
	40 83 12           CALL    $1283
	00                 NOP     
	EA = HL;
	goto 1189

1196:
	55 12 08           OFFIW   VV:12,$08
	EA <<= 1;
119B:
	HL = 0x0000;
	74 EF              DNE     EA,HL
	return 0;
	push(EA);
	8E                 CALT    ($009C)
	EA = pop();
	EA--;
	goto 119B

11A6:
	40 0B 12           CALL    $120B
	return 0;
	func_1B05(); /* always returns 0 */
	func_1F0C(); /* always returns 0 */
	BC = [0x993B];
	HL = 0x9901;
	EA = [HL];
	EA += BC;
	[HL] = EA;
	59 12              BIT     1,VV:12
	goto 11EE
	40 68 2B           CALL    $2B68
	40 13 2C           CALL    $2C13
	A = VV[0x21];
	VV[0x20] = A;
	A = VV[0x22];
	VV[0x25] = A;
	HL = [0x9823];
	[0x9923] = HL;
	5A 12              BIT     2,VV:12
	HL = 0xC005;
	HL = 0xC006;
	A = [HL];
	40 94 12           CALL    $1294
	VV[0x12] |= 0x80
	VV[0x00] &= 0xFB;
	92                 CALT    ($00A4)
	func_1F2D(); /* always returns 0 */
	func_1F0C(); /* always returns 0 */
11EE:
	HL = [0x993D];
	5C 12              BIT     4,VV:12
	HL = [0x9901];
	85                 CALT    ($008A)
	return 0;
11FA:
	HL = [0x9901];
	EA = HL;
	A = VV[0x22];
	EA += A;
	HL = [0x993D];
	74 AF              DGT     EA,HL
	return 1;
	return 0;

120B:
	VV[0x12] |= 0x02;
	BC = [0x9941];
	DE = *data_buffer_rptr;
	do {
		A = [DE++];
		rollover_DE_from_0x9000_to_0x8000(); /* always returns 0 */
		if (A != 0x00)
			goto end_123D;
		if (VV[0x12] & 0x08) {
			A = [DE++];
			rollover_DE_from_0x9000_to_0x8000(); /* always returns 0 */
			if (A & 0x80)
				goto end_123D;
		}
		BC--;
	} while (BC != 0x0000);
	VV[0x12] &= 0xFD;
	if (!(VV[0x12] & 0x10)) {
		DE = [0x993B];
		if (!func_190B()) {
			EA = [0x993F];
			BC = [0x9941];
			EA += BC;
			[0x993F] = EA;
			return 0;
		}
		BC = 0x0000;
	}
end_123D:
	HL = [0x9941];
	EA = HL;
	EA -= BC;
	HL = EA;
	[0x9943] = HL;
	[0x9941] = BC;
	return 1;

1283:
	8E                 CALT    ($009C)
	L = A;
	push(HL);
	9E                 CALT    ($00BC)
	HL = pop();
	H = A;
	EA = 0x0000;
	if (EA == HL)
		return 0;
	[0x9941] = HL;
	return 1;

1294:
	HL = 0x9943;
	EA = [HL];
	40 96 11           CALL    $1196
	HL = 0x9943;
	EA = [HL];
	A = VV[0x22];
	EA = mul24(EA, A);
	HL = [0x9903];
	EA += HL;
	BC = EA;
	[0x990B] = BC;
	HL = 0x9941;
	EA = [HL];
	55 12 08           OFFIW   VV:12,$08
	EA <<= 1;
	BC = EA;
	BC--;
	DE = *data_buffer_rptr;
	EA = DE;
	EA += BC;
	DE = EA;
	BC = 0x9000;
	int borrow = (EA >= BC);
	EA -= BC;
	if (!borrow)
		goto 12CF;
	BC = 0x8000;
	EA += BC;
	DE = EA;
12CF:
	BC = 0x0000;
12D2:
	5B 12              BIT     3,VV:12
	goto 12DC
	2E                 LDAX    (DE-)
	rollover_DE_from_0x7fff_to_0x8fff();
	57 80              OFFI    A,$80
	goto 12E5
12DC:
	2E                 LDAX    (DE-)
	rollover_DE_from_0x7fff_to_0x8fff();
	77 00              EQI     A,$00
	goto 12E5
	BC++;
	goto 12D2
12E5:
	HL = 0x9941;
	EA = [HL];
	EA -= BC;
	[HL] = EA;
	HL = 0x993F;
	EA = [HL];
	EA += BC;
	[HL] = EA;
	EA = BC;
	A = VV[0x22];
	EA = mul24(EA, A);
	BC = EA;
	HL = 0x9901;
	EA = [HL];
	EA -= BC;
	HL = 0x990D;
	[HL] = EA;
	return 0;

1309: 00                 NOP     
130A: EAH = A;
130B: 60 05              illegal 
130D: A = VV[0x0C];
130F: 60 05              illegal 
1311: 00                 NOP     
1312: A = D;
1313: push(VA);
1314: SP++;
1315: A = VV[0x06];
1317: push(VA);
1318: SP++;
1319: A = VV[0x12];
131B: exa();
131C: A = EAH;
131D: A = VV[0x14];
131F: goto 1315
1320: A = EAH;
1321: A = VV[FLAGS_1];
1323: 2A                 LDAX    (DE)
1324: A &= 0xb1;

1325:
	push(BC);
	9E                 CALT    ($00BC)
	BC = pop();
	if (A == 0x00 || A == '0') return 0;
	if (A == 0x01 || A == '1') return 1;
	HL = pop();
	return 0;

1334:
	8E                 CALT    ($009C)
	A &= 0x7f;
	return 0;

1338:
	55 02 08           OFFIW   VV:02,$08
	55 02 04           OFFIW   VV:02,$04
	goto 1348
	func_1377(); /* always returns 0 */
	if (A == 0x11)
		VV[0x02] |= 0x04;
	return 0;
1348:
	if (!is_printable_char(A))
		goto 134D;
	return 1;
134D:
	if (A == 0x7f)
		goto 137C;
	36 07              SUINB   A,$07
	return 0;
	HL = 0x13DA;
	48 25              SLL     A
	60 47              ADD     L,A
	74 56 00           ACI     H,$00
	goto [HL];

/* 1363 */
int is_printable_char(uint8_t A)
{
	func_1377(); /* always returns 0 */
	if (A == 0x7f)
		return 0;
	if (A >= 0x20)
		return 1;
	if (!(VV[0x04] & 0x20))
		return 0;
	if (A != 0x15) /* NAK */
		return 0;
	A = 0x10;
	VV[PRINT_THIS_CHAR] = A;
	return 1;
}
/* always returns 0 */
/* 1377 */
void func_1377(void)
{
	if (!(VV[0x04] & 0x10))
		A &= 0x7f;
	return 0;
}
137C:
	55 05 80           OFFIW   VV:05,$80
	return 0;
	EA = 0x9A79;
	HL = [0x9939];
	74 EF              DNE     EA,HL
	return 0;
	HL--;
	A = [HL];
	57 01              OFFI    A,$01
	return 0;
	HL--;
	HL--;
	[0x9939] = HL;
	func_1D36(); /* always returns 0 */
	DE = EA;
	HL = 0x9901;
	EA = [HL];
	EA -= DE;
	[HL] = EA;
	return 0;
	9E                 CALT    ($00BC)
	67 19              NEI     A,$19
	goto 13B3
	77 7F              EQI     A,$7F
	27 1F              GTI     A,$1F
	goto 13D2
	27 2F              GTI     A,$2F
	goto 13B3
	27 5A              GTI     A,$5A
	goto 13C2
13B3:
	HL = 0x1462;
	B = A;
	do {
		A = [HL++];
		if (A == 0x00)
			return 0;
		EA = [HL++];
	} while (A != B);
	goto EA;
13C2:
	A -= '0';
	HL = 0x140C + (A<<1);
	goto [HL];
13D2:
	A = VV[PRINT_THIS_CHAR];
	if (!is_printable_char(A))
		goto 134D;
	return 0;

13DA: 57 10              OFFI    A,$10
13DC: goto 8C16;
13DF: EAH = A;
13E0: goto 13D8
13E1: A ^= 0x2C;
13E3: EAL = A;
13E4: SP++;
13E5: A |= 0xFD;
13E7: A ^= 0xB6;
13E9: VV[0xF8] |= 0x14
13EC: DE = EA;
13ED: BC = 0x14B6;
13F0: goto 13ED
13F1: BC = 0x1729;
13F4: goto 13E1
13F5: BC = 0x14B6;
13F8: DE = EA;
13F9: BC = 0x14B6;
13FC: goto 1402
13FD: A ^= 0xB6;
13FF: BC = 0x14B6;
1402: HL = pop();
1403: BC--;
1404: DE = EA;
1405: BC = 0x14B6;
1408: DE = EA;
1409: BC = 0x14B6;
140C: 43                 INR     C
140D: A |= 0x45;
140F: A |= 0x47;
1411: A |= 0x4A;
1413: A |= 0xBD;
1415: VV[0xC1] |= 0x15
1418: goto 142A
1419: A ^= 0xD5;
141B: A ^= 0x4C;
141D: A |= 0x50;
141F: A |= 0xB1;
1421: EAL = A;
1422: DE = EA;
1423: BC = 0x7875;
1426: DE = EA;
1427: BC = 0x14B6;
142A: push(BC);
142B: exa();
142C: goto 1446
142D: A ^= 0x37;
142F: A |= 0xC9;
1431: A |= 0x6C;
1433: A |= 0xCC;
1435: A |= 0x00;
1437: VV[0x04] |= 0x15;
143A: A = EAH;
143B: VV[0x0C] |= 0x15;
143E: BC = EA;
143F: BC = [0x1754];
1442: goto 1451
1443: exa();
1444: goto 1456
1445: exa();
1446: exa();
1447: VV[0xA1] |= 0x17
144A: DE = EA;
144B: A |= 0x14;
144D: VV[0x89] |= 0x16
1450: 30 17              DCRW    VV:17
1452: EAH = A;
1453: VV[0x25] |= 0x15
1456: EAH = A;
1457: A |= 0xB6;
1459: BC = 0x15A5;
145C: DE = EA;
145D: BC = 0x10D4;
1460: goto 1478
1461: exa();
1462: EAL = A;
1463: 5D 17              BIT     5,VV:17
1465: 20 B5              INRW    VV:B5
1467: BC = 0xB721;
146A: BC = 0xB424;
146D: BC = 0xE925;
1470: EAL = A;
1471: 26 F3              ADINC   A,$F3
1473: EAL = A;
1474: 2A                 LDAX    (DE)
1475: goto 1490
1476: exa();
1477: A = [HL++];
1478: goto 148A
1479: VV[0x2F] |= 0xBF
147C: A |= 0x5C;
147E: push(EA);
147F: BC = [0xE45E];
1482: exa();
1483: 61                 DAA     
1484: A = D;
1485: A ^= 0x62;
1487: goto 14A2
1488: A |= 0x65;
148A: EAL = A;
148B: EAH = A;
148C: A -= 0x4f;
148E: EAH = A;
148F: A = 0xB5;
1491: BC = 0xB56A;
1494: BC = 0xC56B;
1497: VV[0x6C] |= 0xAB;
149A: A ^= 0x6D;
149C: BC = EA;
149D: BC = 0xB570;
14A0: BC = 0xB572;
14A3: BC = 0x3473;
14A6: A ^= 0x74;
14A8: SP++;
14A9: A ^= 0x77;
14AB: BC = EA;
14AC: BC = [0x2978];
14AF: VV[0x7C] |= 0xDA;
14B2: 7C 00              CALF    $0C00
14B4: 8E                 CALT    ($009C)
14B5: 8E                 CALT    ($009C)
14B6: return 0;
14B7: 8E                 CALT    ($009C)
14B8: VV[0x0A] &= 0x43;
14BB: VV[0x0B] &= 0x7B;
14BE: VV[0x02] &= 0xFD;
14C1: VV[0x02] &= 0xFE;
14C4: 57 01              OFFI    A,$01
14C6: VV[0x0A] |= 0x80
14C9: 57 04              OFFI    A,$04
14CB: VV[0x0B] |= 0x04
14CE: 57 08              OFFI    A,$08
14D0: VV[0x0A] |= 0x04
14D3: 57 10              OFFI    A,$10
14D5: VV[0x0A] |= 0x20
14D8: 47 20              ONI     A,$20
14DA: goto 14E1
14DB: VV[0x02] |= 0x01
14DE: VV[0x0A] |= 0x08
14E1:
	57 40              OFFI    A,$40
	VV[0x0B] |= 0x80
	57 80              OFFI    A,$80
	VV[0x0A] |= 0x10
	goto 1536

14EC:
	if (!(VV[0x02] & 0x01) && (VV[0x02] & 0x2)) {
		VV[0x02] &= 0xFD;
		VV[0x0A] &= 0xF7;
	}
	goto 1536

14F8:
	VV[0x0B] |= 0x04;
	goto 1536

14FC:
	VV[0x0B] &= 0xFB;
	goto 1536
1500:
	VV[0x0A] |= 0x04;
	goto 1536
1504:
	VV[0x0A] &= 0xFB;
	goto 1536
	VV[0x0A] |= 0x20;
	goto 1536
	VV[0x0A] &= 0xDF;
	goto 1536

1510:
	VV[0x0A] |= 0x80;
	goto 1536

1514:
	VV[0x0A] &= 0x7F;
	goto 1536

1518:
	82                 CALT    ($0084)
	goto 151E
	VV[0x0B] &= 0xDF;
	goto 1521
151E:
	VV[0x0B] |= 0x20;
1521:
	VV[0x0B] |= 0x40;
	goto 1536
	VV[0x0B] &= 0xBF;
	goto 1536
	82                 CALT    ($0084)
	goto 152F

152B:
	VV[0x0B] |= 0x02;
	goto 1536;

152F:
	VV[0x0B] &= 0xFD;
	goto 1536;
	VV[0x07] |= 0x80;
	goto 1536;

1536:
	A = VV[0x07]
	BC = [0x980A];
	A &= 0xbf; /* 1011 1111 */
	if (A & 0x80)
		A |= 0x40;
	if ((B & 0x02) || (C & 0x04))
		B &= 0xfb; /* 1111 1011 */
	if ((C & 0xA4) || (C & 0x46) || (A & 0x20) || (VV[0x05] & 0x80))
		A &= 0xbf; /* 1011 1111 */

	if (!(VV[0x07] & 0x40)) {
		if (A & 0x40)
			goto 1599;
1566:
		if (!(B & 0x06) && !(C & 0x04))
			goto 1577;
		if ((VV[0x08] & 0x04) || (VV[0x09] & 0x06)) goto 157F;
		else                                        goto 1599;
XXXXXX

1577:
		if ((VV[0x08] & 0x04) || (VV[0x09] & 0x06)
			goto 1599;
157F:
		if (!(B & 0x02)) {
			if (VV[0x09] & 0x02)
				goto 1599;
			if (C & 0x04) {
				if (!(VV[0x09] & 0x04)) goto 159E;
				else                    goto 1599;
			}
			if ((B & 0x04) && (VV[0x08] & 0x04)) goto 1599
			else                                 goto 159E
		}
		if (VV[0x09] & 0x02) goto 159E;
		else                 goto 1599;
	} else {
		if (A & 0x40) goto 1566;
		else          goto 1599;
	}
XXXXXX

1599:
	push(VA);
	push(BC);
	func_1B05(); /* always returns 0 */
	BC = pop();
	VA = pop();
159E:
	VV[0x07] = A;
	[0x9808] = BC;
	return 0;

15A5: 82                 CALT    ($0084)
15A6: goto 15AE
15A7: VV[0x02] |= 0x01;
15AA: VV[0x0A] |= 0x08;
15AD: goto 15B4
15AE: VV[0x02] &= 0xFC;
15B1: VV[0x0A] &= 0xF7;
15B4: goto 1536
15B6: VV[0x02] |= 0x02
15B9: BC = 0x0008;
15BC: goto 15CC
15BD: BC = 0x8000;
	goto 15CC
15C1: BC = 0x8000;
	goto 15D0
15C5: BC = 0x0001;
	goto 15D4
15C9:
	BC = 0x0001;
15CC:
	goto 15D6
15CD: BC = 0x0001;
15D0: goto 15E9
15D1: BC = 0x0010;
15D4: 82                 CALT    ($0084)
15D5: goto 15E9
15D6: HL = 0x980A;
15D9: EA = [HL];
15DB: EA |= BC;
15DD: [HL] = EA;
15DF: HL = 0x9808;
15E2: EA = [HL];
15E4: EA |= BC;
15E6: [HL] = EA;
15E8: return 0;
15E9: EA = 0xFFFF;
	EA ^= BC;
15EE: BC = EA;
15EF: HL = 0x980A;
15F2: EA = [HL];
15F4: EA &= BC;
15F6: [HL] = EA;
15F8: HL = 0x9808;
15FB: EA = [HL];
15FD: EA &= BC;
15FF: [HL] = EA;
1601: return 0;
1602: 82                 CALT    ($0084)
1603: goto 1608
1604: VV[0x04] |= 0x20
1607: return 0;
1608: VV[0x04] &= 0xDF;
160B: return 0;
160C: 8E                 CALT    ($009C)
160D: A &= 0x0f;
160F: 37 04              LTI     A,$04
1611: return 0;
1612: C = 0x00;
1614: 67 01              NEI     A,$01
1616: C = 0x10;
1618: 67 02              NEI     A,$02
161A: C = 0x20;
161C: 67 03              NEI     A,$03
161E: C = 0x80;
1620: A = VV[0x05];
1622: A &= 0xb0;
1624: 60 EB              NEA     A,C
1626: return 0;
1627: push(BC);
1628: 86                 CALT    ($008C)
1629: BC = pop();
162A: A = VV[0x05];
162C: A &= 0x4f;
162E: A |= C;
1630: VV[0x05] = A;
1632: goto 15B4
1634: 82                 CALT    ($0084)
1635: goto 1641
1636: 55 07 20           OFFIW   VV:07,$20
1639: return 0;
163A: 40 4B 16           CALL    $164B
163D: VV[0x07] |= 0x20
1640: goto 1632
1641: 5D 07              BIT     5,VV:07
1643: return 0;
1644: 40 4B 16           CALL    $164B
1647: VV[0x07] &= 0xDF;
164A: goto 1632
164B: 55 08 04           OFFIW   VV:08,$04
164E: return 0;
164F: 45 09 06           ONIW    VV:09,$06
1652: func_1B05(); /* always returns 0 */
1653: return 0;
1654: 55 05 B0           OFFIW   VV:05,$B0
1657: return 0;
1658: func_1B05(); /* always returns 0 */
1659: 5F 03              BIT     7,VV:03
165B: goto 166B
165C: VV[0x03] &= 0x7F;
165F: HL = [0x9955];
1663: EA = HL;
1664: HL = [0x9901];
1668: 74 AF              DGT     EA,HL
166A: goto 1675
166B: 97                 CALT    ($00AE)
166C: DE = EA;
166D: HL = 0x9901;
1670: EA = [HL];
	int borrow = (EA >= DE);
	EA -= DE;
	if (!borrow)
		return 0;
1675: BC = [0x9905];
1679: 74 BD              DLT     EA,BC
167B: goto 167D
167C: return 0;
167D: HL = EA;
167E: 85                 CALT    ($008A)
167F: return 0;

1680:
	BC = [0x9808];
	func_22C9(); /* always returns 0 */
	HL = EA;
	return 0;
	40 82 18           CALL    $1882
	return 0;
	DE = [0x9905];
	int borrow = (EA >= DE);
	EA -= DE;
	if (!borrow)
		return 0;
	DE = [0x011F];
	74 AE              DGT     EA,DE
	return 0;
	EA = HL;
	DE = [0x4C81];
	5B 4F              BIT     3,VV:4F
	DE = [0x2D01];
	74 BE              DLT     EA,DE
	return 0;
	[0x993D] = HL;
	goto 16C4
	40 82 18           CALL    $1882
	return 0;
	DE = [0x993D];
	EA = DE;
	int borrow = (EA >= HL);
	EA -= HL;
	if (!borrow)
		return 0;
	DE = 0x011F;
	74 AE              DGT     EA,DE
	return 0;
	[0x9905] = HL;
	VV[0x03] &= 0xEF;
16C4:
	goto 16C9
	55 05 80           OFFIW   VV:05,$80
	return 0;
16C9:
	40 0B 17           CALL    $170B
	VV[0x11] &= 0xFE;
	9D                 CALT    ($00BA)
	return 0;
	VV[0x04] |= 0x10
	return 0;
	VV[0x04] &= 0xEF;
	return 0;
	func_7875(); /* always returns 0 */
	40 68 2B           CALL    $2B68
	func_7bb1();
	memset(0x9800, 0x00, 0x0d);
	memset(0x9857, 0x00, 0xb2);
	VV[0x14] |= 0x20;
	EA = pop();
	goto 0195;

16F7:
	func_1B02(); /* always returns 0 */
16F8:
	83                 CALT    ($0086)
	40 82 2B           CALL    $2B82
	goto 1707;
16FD:
	func_1B02(); /* always returns 0 */
	5F 02              BIT     7,VV:02
	goto 1707
	goto 16F8
	func_1B02(); /* always returns 0 */
	40 6F 2B           CALL    $2B6F
	83                 CALT    ($0086)
1707:
	if (VV[0x11] & 0x01)
		return 0;
170B:
	HL = [0x9905];
170F:
	[0x9901] = HL;
	[0x9903] = HL;
	return 0;
	82                 CALT    ($0084)
	goto 1721
	5B 00              BIT     3,VV:00
	func_1B05(); /* always returns 0 */
	VV[0x00] |= 0x08
	return 0;
1721:
	55 00 08           OFFIW   VV:00,$08
	func_1B05(); /* always returns 0 */
	VV[0x00] &= 0xF7;
	return 0;

1729: 5B 02              BIT     3,VV:02
172B: return 0;
172C: VV[0x02] &= 0xFB;
172F: return 0;
1730: 9E                 CALT    ($00BC)
1731: 37 0D              LTI     A,$0D
1733: return 0;
1734: VV[0x0C] = A;
1736: return 0;
1737: 9E                 CALT    ($00BC)
1738: 37 56              LTI     A,$56
173A: return 0;
173B: B = 0x03;
173D: EA = A * B;
173F: A = EAL;
1740: VV[0x2C] = A;
1742: return 0;
1743: A = 0x1B;
1745: A = 0x15;
1747: A = 0x24;
1749: goto 1740
174A: 8E                 CALT    ($009C)
174B: goto 1740
174C: VV[0x01] |= 0x04
174F: return 0;
1750: VV[0x01] &= 0xFB;
1753: return 0;
1754: func_1B05(); /* always returns 0 */
1755: 8E                 CALT    ($009C)
1756: BC = 0x0000;
1759: C = A;
175A: goto 2B88;
175D: 9E                 CALT    ($00BC)
175E: 67 30              NEI     A,$30
1760: goto 1768
1761: 77 34              EQI     A,$34
1763: return 0;
1764: VV[0x02] |= 0x20
1767: return 0;
1768: VV[0x02] &= 0xDF;
176B: return 0;
176C: 9E                 CALT    ($00BC)
176D: B = [0x982C];
	if (VV[PRINT_THIS_CHAR] != 0x00)
		goto 177B;
1775: 8E                 CALT    ($009C)
1776: 37 17              LTI     A,$17
1778: return 0;
1779: B = 0xD8;
177B: EA = A * B;
177D: HL = 0x0000;
1780: 74 EF              DNE     EA,HL
1782: return 0;
1783: func_32F3(); /* always returns 0 */
1786: [HL] = EA;
1788: HL = 0x9931;
178B: EA = [HL];
178D: HL = 0x992F;
1790: [HL] = EA;
1792: HL = 0x0000;
1795: [0x992B] = HL;
1799: [0x9907] = HL;
179D: VV[0x0D] = 0x00;
17A0: return 0;
17A1: 9E                 CALT    ($00BC)
17A2: 67 00              NEI     A,$00
17A4: return 0;
17A5: B = A;
17A6: A = VV[0x2C];
17A8: EA = A * B;
17AA: BC = EA;
17AB: HL = 0x9931;
17AE: EA = [HL];
17B0: 74 FD              DEQ     EA,BC
17B2: 74 B5              DSUBNB  EA,BC
17B4: return 0;
17B5: goto 17B9
17B6: EA = [0xFFFF];
17B9: HL = 0x992F;
17BC: [HL] = EA;
17BE: return 0;
17BF: 9E                 CALT    ($00BC)
17C0: 37 08              LTI     A,$08
17C2: return 0;
17C3: VV[0x03] |= 0x20
17C6: VV[0x0E] = A;
17C8: return 0;
17C9: A = 0x00;
17CB: goto 17DE
17CC: VV[0x03] |= 0x30
17CF: 97                 CALT    ($00AE)
17D0: HL = 0x9857;
17D3: [HL++] = EA;
17D5: BC = [0x0020];
17D8: goto 17FA
17DA: 9E                 CALT    ($00BC)
17DB: 37 08              LTI     A,$08
17DD: return 0;
17DE: B = 0x11;
17E0: EA = A * B;
17E2: VV[0x03] |= 0x20;
17E5: bitmask(A); /* always returns 0 */
17E8: A |= VV[0x0d];
17EB: VV[0x0D] = A;
17ED: HL = 0x9879;
17F0: EA += HL;
17F2: HL = EA;
17F3: A = VV[0x2C];
17F5: 3D                 STAX    (HL+)
17F6: C = 0x10;
17F8: B = 0x00;
17FA: push(BC);
17FB: push(HL);
17FC: 8E                 CALT    ($009C)
17FD: HL = pop();
17FE: BC = pop();
17FF: 53                 DCR     C
1800: goto 1802
1801: goto 1811
1802: 67 00              NEI     A,$00
1804: goto 180B
1805: 60 AA              GTA     A,B
1807: goto 180B
1808: 3D                 STAX    (HL+)
1809: B = A;
180A: goto 17FA
180B: 4B 00              MVIX    HL,$00
180D: return 0;
180E: push(BC);
180F: 8E                 CALT    ($009C)
1810: BC = pop();
1811: 67 00              NEI     A,$00
1813: return 0;
1814: 60 AA              GTA     A,B
1816: return 0;

1817: B = A;
1818: goto 180E
1819: 82                 CALT    ($0084)
181A: goto 1832
181B: 9E                 CALT    ($00BC)
181C: B = A;
181D: A = VV[0x2C];
181F: EA = A * B;
1821: BC = EA;
1822: func_32F3(); /* always returns 0 */
1825: EA = [HL];
1827: 74 AD              DGT     EA,BC
1829: return 0;
182A: [0x9907] = BC;
182E: VV[0x03] &= 0xDF;
1831: return 0;
1832: 9E                 CALT    ($00BC)
1833: push(VA);
1834: 97                 CALT    ($00AE)
1835: VA = pop();
1836: EA = mul24(EA, A);
1837: BC = EA;
1838: DE = [0x011F];
183B: 74 AE              DGT     EA,DE
183D: return 0;
183E: DE = [0x0BF5];
1841: 74 BE              DLT     EA,DE
1843: return 0;
1844: [0x9909] = BC;
1848: VV[0x03] &= 0xDF;
184B: VV[0x03] |= 0x10
184E: return 0;
184F: 82                 CALT    ($0084)
1850: goto 1862
1851: func_1B05(); /* always returns 0 */
1852: 9E                 CALT    ($00BC)
1853: B = A;
1854: A = VV[0x2C];
1856: EA = A * B;
1858: BC = 0x0000;
185B: 74 ED              DNE     EA,BC
185D: return 0;
185E: BC = EA;
185F: goto 2B88;
1862: 55 05 80           OFFIW   VV:05,$80
1865: return 0;
1866: 9E                 CALT    ($00BC)
1867: 67 00              NEI     A,$00
1869: return 0;
186A: push(VA);
186B: func_1B05(); /* always returns 0 */
186C: 97                 CALT    ($00AE)
186D: VA = pop();
186E: EA = mul24(EA, A);
186F: DE = [0x9901];
1873: EA += DE;
1875: DE = [0x993D];
1879: 74 BE              DLT     EA,DE
187B: goto 16F7;
187E: HL = EA;
187F: goto 170F;
1882: 97                 CALT    ($00AE)
1883: push(EA);
1884: 8E                 CALT    ($009C)
1885: EA = pop();
1886: EA = mul24(EA, A);
1887: 48 1A              SKN     CY
1889: return 0;
188A: HL = EA;
188B: return 1;
188C: 55 05 80           OFFIW   VV:05,$80
188F: return 0;
1890: 5C 03              BIT     4,VV:03
1892: goto 18E8
1894: 5D 03              BIT     5,VV:03
1896: goto 18C5
1898: HL = 0x9857;
189B: B = 0x01;
189D: 42                 INR     B
189E: 74 3A 23           LTI     B,$23
18A1: return 0;
18A2: AD                 LDAX    (HL+B)
18A3: 67 00              NEI     A,$00
18A5: return 0;
18A6: push(BC);
18A7: EA = [HL];
18A9: EA = mul24(EA, A);
18AA: BC = pop();
18AB: 48 1A              SKN     CY
18AD: return 0;
18AE: DE = [0x9905];
18B2: EA += DE;
18B4: DE = [0x993D];
18B8: 74 BE              DLT     EA,DE
18BA: return 0;
18BB: DE = [0x9901];
18BF: 74 AE              DGT     EA,DE
18C1: goto 189D
18C3: goto 18EE
18C5: BC = [0x9909];
18C9: EA = 0x0000;
18CC: 74 ED              DNE     EA,BC
18CE: return 0;
18CF: HL = 0x9905;
18D2: EA = [HL];
18D4: EA += BC;
18D6: DE = [0x993D];
18DA: DE++;
18DB: 74 BE              DLT     EA,DE
18DD: goto 16F7
18E0: DE = [0x9901];
18E4: 74 AE              DGT     EA,DE
18E6: goto 18D4
18E7: goto 18EE
18E8: 97                 CALT    ($00AE)
18E9: A = 0x08;
18EB: EA = mul24(EA, A);
18EC: BC = EA;
18ED: goto 18CF
18EE: VV[0x03] &= 0x7F;
18F1: HL = EA;
18F2: BC = [0x9903];
18F6: EA = BC;
18F7: 74 EE              DNE     EA,DE
18F9: goto 1909
18FA: EA = HL;
18FB: EA -= DE;
18FD: DE = EA;
18FE: [0x993B] = DE;
1902: 40 0B 19           CALL    $190B
1905: return 0;
1906: push(HL);
1907: func_1B05(); /* always returns 0 */
1908: HL = pop();
1909: 85                 CALT    ($008A)
190A: return 0;
190B: 5E 07              BIT     6,VV:07
190D: goto 191A
190E: EA = DE;
190F: A = 0x10;
1911: EA = EA / A, A = EA % A; /* simultaneously */
1913: 67 00              NEI     A,$00
1915: goto 1929
1916:
	if (VV[0x11] & 0x20)
		return 1;
191A: EA = DE;
191B: 5A 09              BIT     2,VV:09
191D: A = 0x0C;
191F: A = 0x06;
1921: EA = EA / A, A = EA % A; /* simultaneously */
1923: 77 00              EQI     A,$00
1925: return 1;
1926: VV[0x07] &= 0xBF;
1929: goto 2291;
192C: func_1B02(); /* always returns 0 */
192D: 83                 CALT    ($0086)
192E: 40 0B 17           CALL    $170B
1931: 5D 03              BIT     5,VV:03
1933: goto 1979
1935: A = VV[0x0E];
1937: bitmask(A); /* always returns 0 */
193A: 74 C8 0D           ONAW    VV:0D
193D: goto 1983
193F: A = VV[0x0E];
1941: B = 0x11;
1943: EA = A * B;
1945: HL = 0x9879;
1948: EA += HL;
194A: HL = EA;
194B: DE = [0x992B];
194F: A = [HL++];
1950: B = A;
1951: C = 0x10;
1953: 53                 DCR     C
1954: goto 1956
1955: goto 1970
1956: A = [HL++];
1957: 67 00              NEI     A,$00
1959: goto 1970
195A: EA = A * B;
195C: 74 AE              DGT     EA,DE
195E: goto 1953
	if (!func_32EC())
		goto 196A;
1963: BC = [0x992F];
1967: 74 BD              DLT     EA,BC
1969: goto 1976
196A: EA -= DE;
196C: BC = EA;
196D: goto 2B88;
1970: 74 6B 0F           NEI     C,$0F
1973: goto 16FD;
1976: goto 2B6F;
1979: BC = [0x9907];
197D: EA = BC;
197E: BC = 0x0000;
1981: 74 ED              DNE     EA,BC
1983: goto 2B82;
1986: BC = EA;
1987: push(EA);
1988: func_32F3(); /* always returns 0 */
198B: EA = [HL];
198D: DE = EA;
198E: EA = pop();
198F: 74 BE              DLT     EA,DE
1991: goto 1976
1992: DE = [0x992B];
1996: 74 EE              DNE     EA,DE
1998: goto 199D
1999: 74 BE              DLT     EA,DE
199B: goto 196A
199D: EA += BC;
199F: goto 1987

/* always returns 0 */
/* 19A0 */
void func_19A0(void)
{
	HL = 0xFF00;
	B  = 0x0c;
	func_19DD(); /* always returns 0 */
	HL = 0xFF48;
	B  = 0x1d;
	func_19DD(); /* always returns 0 */
	return 0;
}

19B1: func_1B05(); /* always returns 0 */
19B2: 9E                 CALT    ($00BC)
19B3: push(VA);
19B4: 9E                 CALT    ($00BC)
19B5: push(VA);
19B6: 9E                 CALT    ($00BC)
19B7: C = A;
19B8: VA = pop();
19B9: B = A;
19BA: VA = pop();
19BB: 51                 DCR     A
19BC: return 0;
19BD: 53                 DCR     C
19BE: return 0;
19BF: 74 3A 02           LTI     B,$02
19C2: return 0;
19C3: VV[0x04] &= 0xF7;
19C6: 74 6A 01           NEI     B,$01
19C9: VV[0x04] |= 0x08
19CC: 59 09              BIT     1,VV:09
19CE: A = 0x0C;
19D0: A = 0x1D;
19D2: B = A;
19D3: 59 09              BIT     1,VV:09
19D5: HL = 0xFF00;
19D8: HL = 0xFF48;
19DB: A = 0xFF;

/* always returns 0 */
/* 19DD */
void func_19DD(void)
{
	A = 0x00;
	C = 0x05;
	do {
		[HL] = A;
		HL += B;
	} while (C--);
	return 0;
}

19E9: 82                 CALT    ($0084)
19EA: goto 19EF
19EB: VV[0x04] |= 0x80
19EE: return 0;
19EF: VV[0x04] &= 0x7F;
19F2: return 0;
19F3: func_1B05(); /* always returns 0 */
19F4: 9E                 CALT    ($00BC)
19F5: push(VA);
19F6: 8E                 CALT    ($009C)
19F7: push(VA);
19F8: 8E                 CALT    ($009C)
19F9: C = A;
19FA: VA = pop();
19FB: B = A;
19FC: VA = pop();
19FD: 77 00              EQI     A,$00
19FF: return 0;
1A00: A = C;
1A01: 74 32 3A           SUINB   B,$3A
1A04: goto 1A1F
1A05: 37 40              LTI     A,$40
1A07: goto 1A1F
1A08: 36 3A              SUINB   A,$3A
1A0A: goto 1A1D
1A0B: 60 B2              SUBNB   A,B
1A0D: return 0;
1A0E: C = A;
1A0F: push(BC);
1A10: 59 09              BIT     1,VV:09
1A12: 40 42 1A           CALL    $1A42
1A15: 40 58 1A           CALL    $1A58
1A18: BC = pop();
1A19: 42                 INR     B
1A1A: 53                 DCR     C
1A1B: goto 1A0F
1A1C: return 0;
1A1D: A += 0x3A;
1A1F: B += 0x3A;
1A22: 60 B2              SUBNB   A,B
1A24: return 0;
1A25: 59 09              BIT     1,VV:09
1A27: goto 1A3A
1A28: C = A;
1A29: push(BC);
1A2A: 8E                 CALT    ($009C)
1A2B: 8E                 CALT    ($009C)
1A2C: push(VA);
1A2D: 8E                 CALT    ($009C)
1A2E: VA = pop();
1A2F: B = 0x03;
1A31: EA = A * B;
1A33: 40 9B 11           CALL    $119B
1A36: BC = pop();
1A37: 53                 DCR     C
1A38: goto 1A29
1A39: return 0;
1A3A: 41                 INR     A
1A3B: B = 0x0C;
1A3D: EA = A * B;
1A3F: goto 119B;
1A42: func_1AC2(); /* always returns 0 */
1A45: push(HL);
1A46: 8E                 CALT    ($009C)
1A47: A &= 0x80;
1A49: A |= 0x0B;
1A4B: HL = pop();
1A4C: 3D                 STAX    (HL+)
1A4D: C = 0x0A;
1A4F: push(HL);
1A50: push(BC);
1A51: 8E                 CALT    ($009C)
1A52: BC = pop();
1A53: HL = pop();
1A54: 3D                 STAX    (HL+)
1A55: 53                 DCR     C
1A56: goto 1A4F
1A57: return 1;
1A58: func_1AC2(); /* always returns 0 */
1A5B: push(HL);
1A5C: 8E                 CALT    ($009C)
1A5D: 8E                 CALT    ($009C)
1A5E: push(VA);
1A5F: 8E                 CALT    ($009C)
1A60: VA = pop();
1A61: HL = pop();
1A62: 67 00              NEI     A,$00
1A64: return 0;
1A65: 37 0C              LTI     A,$0C
1A67: A = 0x0C;
1A69: 3D                 STAX    (HL+)
1A6A: push(HL);
1A6B: HL++;
1A6C: HL++;
1A6D: C = A;
1A6E: B = 0x10;
1A70: 60 62              SUB     B,A
1A72: goto 1AA0
1A74: push(BC);
1A75: push(HL);
1A76: 8E                 CALT    ($009C)
1A77: EAH = A;
1A78: push(EA);
1A79: 8E                 CALT    ($009C)
1A7A: EA = pop();
1A7B: EAL = A;
1A7C: C = 0x07;
1A7E: EA <<= 1;
1A80: 48 35              RLL     A
1A82: EA <<= 1;
1A84: 48 36              RLL     B
1A86: 53                 DCR     C
1A87: goto 1A7E
1A88: HL = pop();
1A89: 3D                 STAX    (HL+)
1A8A: A = B;
1A8B: BF 0D              STAX    (HL+$0D)
1A8D: push(HL);
1A8E: 8E                 CALT    ($009C)
1A8F: HL = 0x994D;
1A92: C = 0x01;
1A94: EA = [HL];
1A96: 48 25              SLL     A
1A98: 48 B4              DRLL    EA
1A9A: [HL++] = EA;
1A9C: 53                 DCR     C
1A9D: goto 1A94
1A9E: HL = pop();
1A9F: BC = pop();
1AA0: 53                 DCR     C
1AA1: goto 1A74
1AA3: DE = pop();
1AA4: push(BC);
1AA5: HL = 0x994D;
1AA8: EA = [HL++];
1AAA: goto 1AAD
1AAB: EA <<= 1;
1AAD: 52                 DCR     B
1AAE: goto 1AAB
1AAF: A = EAH;
1AB0: [DE++] = A;
1AB1: A = EAL;
1AB2: [DE++] = A;
1AB3: BC = pop();
1AB4: EA = [HL];
1AB6: goto 1AB9
1AB7: EA <<= 1;
1AB9: 52                 DCR     B
1ABA: goto 1AB7
1ABB: A = EAH;
1ABC: BB 0C              STAX    (DE+$0C)
1ABE: A = EAL;
1ABF: BB 0D              STAX    (DE+$0D)
1AC1: return 0;

/* always returns 0 */
void func_1AC2(void)
{
	if (VV[0x09] & 0x02) {
		A  = 0x1D;
		HL = 0xFF48;
	} else {
		A  = 0x0C;
		HL = 0xFF00;
	}
	EA = A * B;
	EA += HL;
	HL = EA;
	return 0;
}

1AD6:
	B = [0x9815];
	5F 04              BIT     7,VV:04
	return 0;
	74 3A 3A           LTI     B,$3A
	74 3A 40           LTI     B,$40
	return 0;
	B -= 0x3a;
	func_1AC2(); /* always returns 0 */
	A = [HL];
	67 FF              NEI     A,$FF
	goto 1AF8
	VV[0x09] &= 0x7F;
	77 00              EQI     A,$00
	return 1;
	VV[PRINT_THIS_CHAR] = ' ';
	return 0;
1AF8:
	VV[0x08] &= 0xFE;
	55 04 08           OFFIW   VV:04,$08
	VV[0x08] |= 0x01
	return 0;

/* always returns 0 */
/* 1B02 */
void func_1B02(void)
{
	VV[0x05] |= 0x04;
	func_1B05();
	return 0;
}

/* always returns 0 */
/* 1B05 */
void func_1B05(void)
{
	HL = [0x9939];
	EA = 0x9a79;
	if (HL <= EA)
		goto 1BB8;
	func_1F0C(); /* always returns 0 */
	if (!(VV[0x06] & 0x80)) {
		VV[0x06] &= 0xef; /* 1110 1111 */
		if (!(VV[0x06] & 0x40))
			VV[0x06] |= 0x10; /* 0001 0000 */
	}
	func_304E(); /* always returns 0 */
	func_1FAE(); /* always returns 0 */
	func_1BBC(); /* always returns 0 */
	VV[FLAGS_1] &= 0xAF; /* 1010 1111 */
	VV[FLAGS_1] |= 0x01; /* 0000 0001 */
	VV[0x2A] = 0x10;
	VV[0x2B] = 0x00;
	if (!func_1C93())
		goto 1B99;
	40 68 2B           CALL    $2B68
	40 13 2C           CALL    $2C13
	40 D5 7B           CALL    $7BD5
	VV[0x13] |= 0x02;
	func_1ED9(); /* always returns 0 */
	VV[FLAGS_1] &= 0xFE; /* 1111 1110 */
	if (!(VV[0x11] & 0x08))
		goto 1B60;
	VV[FLAGS_1] |= 0x40; /* 0100 0000 */
	VV[0x2A] = 0x20;
	VV[0x2B] = 0x00;
	if (!func_1C93())
		goto 1B60;
	BC = 0x0001;
	func_2EA6(); /* always returns 0 */
	func_1ED9(); /* always returns 0 */
1B60:
	if (!(VV[0x11] & 0x10))
		goto 1B99;
	VV[FLAGS_1] |= 0x10; /* 0001 0000 */
	VV[FLAGS_1] &= 0xBF; /* 1011 1111 */
	VV[0x2A] = 0x00;
	VV[0x2B] = 0x10;
	if (!func_1C93())
		goto 1B99;
	BC = 0x000C;
	if (VV[0x26] != 0x00)
		BC = 0x000B;
	func_2EA6(); /* always returns 0 */
	func_1ED9(); /* always returns 0 */
	if (!(VV[0x11] & 0x08))
		goto 1B99;
	VV[FLAGS_1] |= 0x40; /* 0100 0000 */
	VV[0x2A] = 0x20;
	VV[0x2B] = 0x10;
	if (!func_1C93())
		goto 1B99;
	BC = [0x0001];
	func_2EA6(); /* always returns 0 */
	func_1ED9(); /* always returns 0 */
1B99:
	55 05 08           OFFIW   VV:05,$08
	goto 1BAF
	if (!(VV[0x05] & 0x30) || !(VV[0x05] & 0x04))
		goto 1BB4;
	HL = [0x9901];
	EA = HL;
	HL = [0x9903];
	if (EA == HL)
		goto 1BB4;
1BAF:
	HL = [0x993D];
	85                 CALT    ($008A)
1BB4:
	9D                 CALT    ($00BA)
	VV[0x06] |= 0x10; /* 0001 0000 */
1BB8:
	VV[0x05] &= 0xFB;
	return 0;
}
/* always returns 0 */
/* 1BBC */
void func_1BBC(void)
{
	VV[0x05] &= 0xF7;
	VV[0x11] &= 0xFE;
	if (VV[0x05] & 0x30) {
		if (!(VV[0x05] & 0x04))
			return 0;
		func_1D79(); /* always returns 0 */
		if (!(VV[0x05] & 0x20))
			EA >>= 1;
		DE = EA;
		HL = 0x9903;
		EA = [HL];
		EA += DE;
		[HL] = EA;
		HL = 0x9901;
		EA = [HL];
		EA += DE;
		[HL] = EA;
		return 0;
	}
	if (!(VV[0x05] & 0x80))
		return 0;
	if (VV[0x05] & 0x02)
		return 0;
	if ((VV[0x03] & 0x04) || (VV[0x33] == 0x00))
		return 0;
	VV[0x05] &= 0xBF;
	if (VV[0x11] & 0x04)
		goto 1BF9;
	if (!func_1D79())
		goto 1C00;
	EA <<= 1;
	BC = EA;
	HL = [0x993D];
	EA = HL;
	HL = [0x9903];
	EA -= HL;
	74 B5              DSUBNB  EA,BC
	return 0;
	BC++;
	74 B5              DSUBNB  EA,BC
	return 0;
	VV[0x05] |= 0x40
1BF9:
	func_1C2A(); /* always returns 0 */
	if (VV[0x33] == 0x00)
		return 0;
1C00:
	func_1D79(); /* always returns 0 */
	HL = [0x9947];
	EA += HL;
	A = VV[0x25];
	EA = EA / A, A = EA % A; /* simultaneously */
	push(EA);
	HL = [0x993D];
	EA = HL;
	EA -= A;
	HL = EA;
	[0x9901] = HL;
	EA = pop();
	[0x9953] = EA / VV[0x33];
	VV[0x34] = EA % VV[0x33];
	VV[0x05] |= 0x08
	return 0;
}
/* always returns 0 */
/* 1C2A */
void func_1C2A(void)
{
	HL = [0x9939];
	[0x9951] = HL;
	do {
		HL -= 3;
		A = [HL];
		EA = [HL + 1];
		BC = EA;
		func_22C9(); /* always returns 0 */
		BC = EA;
		DE = 0x9901;
		EA = [DE];
		EA -= BC;
		[DE] = EA;
		A = [HL];
		if (A == 0x20) {
			VV[0x05] |= 0x40;
			DE = 0x9947;
			EA = [DE];
			EA -= BC;
			[DE] = EA;
		} else {
			if (VV[0x05] & 0x40)
				break;
			VV[0x11] |= 0x01;
		}
	} while (VV[0x33]--);
	HL += 3;
	[0x9939] = HL;
	DE = 0x9901;
	EA = [DE];
	EA += BC;
	[DE] = EA;
	return 0;
}

/* 1C93 */
int func_1C93(void)
{
	HL = 0x9833;
	EA = [HL++];
	[HL] = EA;
	if (!func_1CB1())
		return 0;
	func_1CDC(); /* always returns 0 */
	if (!(VV[0x07] & 0x40)) {
		B = 0x48;
		HL = 0x990D;
		EA = [HL];
		EA += B;
		[HL] = EA;
	}
	return 1;
}

/* 1CB1 */
int func_1CB1(void)
}
	BC = [0x9903];
	HL = 0x9A79;
	DE = [0x9939];
	while (1) {
		[0x990B] = BC
		[0x9933] = HL;
		EA = HL;
		if (DE <= EA)
			return 0;
		if (!func_1D00())
			return 1;
		push(DE);
		func_1D3E(); /* always returns 0 */
		DE = pop();
		BC = [0x990B];
		EA += BC;
		BC = EA;
		HL += 3;
	}
}

/* always returns 0 */
/* 1CDC */
void func_1CDC(void)
{
	BC = [0x9901];
	HL = [0x9939];
	while (1) {
		[0x990D] = BC;
		[0x9935] = HL;
		HL -= 3;
		if (!func_1D00())
			return 0;
		func_1D51(); /* always returns 0 */
		BC = [0x990D];
		DE = EA;
		EA = BC;
		EA -= DE;
		BC = EA;
	}
}

/* 1D00 */
int func_1D00(void)
{
	BC = [0x982A];
	EA = [HL + 1];
	if (!(VV[0x10] & 0x01)) {
		EA &= BC;
		if (EA != BC)
			return 1;
	} else {
		if (EA & BC)
			return 0;
	}
	A = [HL+0x02];
	if (A & 0x01)
		return 1;
	A = [HL];
	if (A != 0x20)
		return 0;
	A = EAL;
	if (A & 0x10)
		return 0;
	return 1;
}

/* 1D21 */
int func_1D21(void)
{
	if (!(VV[0x05] & 0x08))
		return 0;
	A = [HL + 0x02];
	if (A & 0x01)
		return 0;
	A = [HL];
	if (A != 0x20)
		return 0;
	DE = [0x9945];
	EA = DE;
	if (HL <= EA)
		return 0;
	return 1;
}

/* always returns 0 */
/* 1D36 */
void func_1D36(void)
{
	A = [HL];
	EA = [HL + 1];
	BC = EA;
	func_22C9(); /* always returns 0 */
	return 0;
}
/* always returns 0 */
/* 1D3E */
void func_1D3E(void)
{
	if (!func_1D21()) {
		func_1D36(); /* always returns 0 */
		return 0;
	}
	BC = [0x9953];
	DE = [0x9836];
	EA = 0x0000;
	if (EA != DE)
		func_1D65(); /* always returns 0 */
	func_1D6B(); /* always returns 0 */
	return 0;
}
/* always returns 0 */
/* 1D51 */
void func_1D51(void)
{
	if (!func_1D21()) {
		func_1D36(); /* always returns 0 */
		return 0;
	}
	BC = [0x9953];
	DE = [0x9835];
	EA = DE;
	DE = [0x9836];
	if (EA == DE)
		func_1D65(); /* always returns 0 */
	func_1D6B(); /* always returns 0 */
	return 0;
}

/* always returns 0 */
/* 1D65 */
void func_1D65(void)
{
	DE--;
	[0x9836] = DE;
	BC++;
	return 0;
}
/* always returns 0 */
/* 1D6B */
void func_1D6B(void)
{
	A = VV[0x25];
	EA = BC;
	EA = mul24(EA, A);
	DE = [0x9835];
	DE--;
	[0x9835] = DE;
	return 0;
}
/* always returns 0 */
/* 1D79 */
int func_1D79(void)
{
	int r;
	HL = [0x993D];
	EA = HL;
	HL = [0x9901];
	r = (EA < HL);
	EA -= HL;
	return r;
}

1D85:
	HL = [0x9925];
	[0xC005] = HL;
	64 83 07           MVI     EOM,$07
	A = CR1;
	EA = 0x0000;
	EAL = A;
	EA <<= 1;
	37 DB              LTI     A,$DB
	goto 1DA2
	EA += A;
	BC = EA;
	EA = 0x0434;
	goto 1DAB
1DA2:
	37 FB              LTI     A,$FB
	beep_and_hang(5, 1); /* HANG, never returns */

	BC = EA;
	EA = 0x035E;
1DAB:
	EA -= BC;
	BC = EA;
	EA = ECNT;
	EA += BC;
	BC = [0x9923];
	74 BD              DLT     EA,BC
	EA -= BC;
	ETM0 = EA;
	5D 10              BIT     5,VV:10
	goto 1DCC
	HL = [0x9923];
	EA = HL;
	ETM1 = EA;
	48 46              SKIT    FE1
	00                 NOP     
	VV[FLAGS_1] &= 0xDF; /* 1101 1111 */

1DCC:
	exx();
	exa();
	enable_interrupts();
	push(EA);
	push(HL);
	push(VA);
	push(BC);
	push(DE);
	40 22 23           CALL    $2322
	40 46 1E           CALL    $1E46
	40 5E 1E           CALL    $1E5E
	DE = pop();
	BC = pop();
	VA = pop();
	HL = pop();
	EA = pop();
	return; /* FROM INTERRUPT */

1DE3:
	HL = [0x9925];
	[0xC005] = HL;
	64 83 07           MVI     EOM,$07
	A = CR1;
	EA = 0x0000;
	EAL = A;
	EA <<= 1;
	37 DB              LTI     A,$DB
	goto 1E05
	27 D0              GTI     A,$D0
	EA = 0x01A0;
	EA += A;
	BC = EA;
	EA = 0x0410;
	goto 1E0E
1E05:
	37 FB              LTI     A,$FB
	beep_and_hang(5, 1); /* HANG, never returns */

	BC = EA;
	EA = 0x0339;
1E0E:
	EA -= BC;
	BC = EA;
	EA = ECNT;
	EA += BC;
	BC = [0x9923];
	74 BD              DLT     EA,BC
	EA -= BC;
	ETM0 = EA;
	5D 10              BIT     5,VV:10
	goto 1E2F
	HL = [0x9923];
	EA = HL;
	ETM1 = EA;
	48 46              SKIT    FE1
	00                 NOP     
	VV[FLAGS_1] &= 0xDF; /* 1101 1111 */

1E2F:
	exx();
	exa();
	enable_interrupts();
	push(EA);
	push(HL);
	push(VA);
	push(BC);
	push(DE);
	40 22 23           CALL    $2322
	40 46 1E           CALL    $1E46
	40 5E 1E           CALL    $1E5E
	DE = pop();
	BC = pop();
	VA = pop();
	HL = pop();
	EA = pop();
	return; /* FROM INTERRUPT */

1E46:
	MKL |= 0x40; /* 0100 0000 */ /* mask INTE1 */
	48 45              SKIT    FE0
	00                 NOP     
	MKL &= 0xdf; /* 1101 1111 */ /* activate INTE0 */
	[0x981B] = 0x1E78;
	[0x9818] = timer1_2;
	return 0;
1E5E:
	55 10 02           OFFIW   VV:10,$02
	30 29              DCRW    VV:29
	return 0;
	VV[0x29] = 0x02;
	HL = [0x9923];
	EA = HL;
	5F 12              BIT     7,VV:12
	goto 1E74
	EA++;
	5E 12              BIT     6,VV:12
	EA++;
	goto 1E75
1E74:
	EA--;
1E75:
	ETM1 = EA;
	return 0;
1E78:
	MKL |= 0x20; /* 0010 0000 */ /* mask INTE0 */
	64 83 99           MVI     EOM,$99
	HL = 0x0000;
	[0xC005] = HL;
	VV[FLAGS_1] &= 0x7D; /* 0111 1101 */
	VV[0x0F] &= 0xFD;
	exx();
	exa();
	enable_interrupts();
	return; /* FROM INTERRUPT */

1E8F:
	BC = [0x9921];
	EA = BC;
	BC = [0x9927];
	EA += BC;
	ETM1 = EA;
	EA++;
	EA++;
	ETM0 = EA;
	55 06 10           OFFIW   VV:06,$10
	goto 1EB3
	[0x981B] = 0x1D85;
	[0x9818] = timer1_1;
	goto 1EC1
1EB3:
	[0x981B] = 0x1DE3;
	[0x9818] = timer1_1;
1EC1:
	ETMM = 0x0c; /* 0000 1100 */ /*  */
	VV[FLAGS_1] |= 0x20; /* 0010 0000 */
	48 46              SKIT    FE1
	00                 NOP     
	48 45              SKIT    FE0
	00                 NOP     
	40 22 23           CALL    $2322
	00                 NOP     
	MKL &= 0xbf; /* 1011 1111 */ /* activate INTE1 */
	VV[FLAGS_1] |= 0x80; /* 1000 0000 */
	return 0;

/* always returns 0 */
/* 1ED9 */
void func_1ED9(void)
{
	func_1F11(); /* always returns 0 */
	HL = 0x9000;
	[0x995D] = HL;
	[0x995F] = HL;
	HL = 0x0000;
	[0x9925] = HL;
	if (VV[0x00] & 0x04)
		func_2AD2(); /* always returns 0 */
	if (VV[0x09] & 0x02) A = 0x1E;
	else                 A = 0x00;
	VV[0x3E] = A;
	92                 CALT    ($00A4)
	func_1F2D(); /* always returns 0 */
	while (func_234C());
	if (!(VV[0x00] & 0x04))
		func_2AD2(); /* always returns 0 */
	return 0;
}
/* always returns 0 */
/* 1F0C */
void func_1F0C(void)
{
	while (VV[0x0f] & 0x02)
		func_2089(); /* always returns 0 */
	return 0;
}
/* always returns 0 */
/* 1F11 */
void func_1F11(void)
{
	HL = [0x9933];
	if (VV[0x00] & 0x04) {
		DE = [0x9935];
		EA = DE;
		HL -= 3;
		[0x9935] = HL;
		HL = EA - 3;
	}
	[0x9937] = HL;
	return 0;
}

/* always returns 0 */
/* 1F2D */
void func_1F2D(void)
{
	func_1F75();
	5A 00              BIT     2,VV:00
	goto 1F49
	HL = [0x990D];
	EA = HL;
	EA -= A;
	A = 0x18;
	EA = EA / A, A = EA % A; /* simultaneously */
	EA = [0x0018];
	77 00              EQI     A,$00
	EA <<= 1;
	EA -= A;
	BC = EA;
	goto 1F57
1F49:
	HL = [0x990B];
	EA = HL;
	EA += A;
	C = 0x18;
	48 3F              DIV     C
	C += 0x18;
1F57:
	40 93 1F           CALL    $1F93
	EA = A * C;
	HL = 0x9927;
	[HL] = EA;
	VV[0x29] = 0x02;
	5F 12              BIT     7,VV:12
	goto 1F6E
	55 12 20           OFFIW   VV:12,$20
	VV[FLAGS_1] |= 0x02; /* 0000 0010 */
	goto 1F74
1F6E:
	55 07 40           OFFIW   VV:07,$40
	VV[FLAGS_1] |= 0x02; /* 0000 0010 */
1F74:
	return 0;
}

void func_1F75(void)
{
	if (VV[0x00] & 0x02) HL = 0x9850;
	else                 HL = 0x1F89;
	A = [HL+[9820]];
	if (VV[0x00] & 0x04)
		A += VV[0x25];
	return;
}

1F89: DW: 0A 01 10 0A 01 2D 20 39 2D 20 34 9A 1F 01 20 AC
1F99: DW: B8 39 73 24 2B 56

int func_1F9F(void)
{
	if (234C())
		return 1;
	if (VV[0x40] & 0x40)
		return 1;
	if (!VV[0x3e]--)
		return 0;
	VV[0x3e] = 0x00;
	return 1;
}

/* always returns 0 */
/* 1FAE */
void func_1FAE(void)
{
	if (VV[0x06] & 0x10) {
		if ((VV[0x09] & 0x02) || (VV[0x09] & 0x04))      HL = 0x201f;
		else if (VV[0x07] & 0x40)                        HL = 0x2013;
		else if ((VV[0x07] & 0x20) || (VV[0x08] & 0x04)) HL = 0x2017;
		else                                             HL = 0x201b;
	}
	else if ((VV[0x09] & 0x02) || VV[0x09] & 0x04)   HL = 0x200f;
	else if (VV[0x07] & 0x40)                        HL = 0x2013;
	else if ((VV[0x07] & 0x20) || (VV[0x08] & 0x04)) HL = 0x200b;
	else                                             HL = 0x2007;

	A = [HL++];

	push(VA);
	A &= 0x7f; /* 0111 1111 */
	VV[0x20] = A;
	A = [HL++];
	VV[0x25] = A;
	EA = [HL];
	HL = 0x9923;
	[HL] = EA;
	VA = pop();
	if (A & 0x80) HL = 0xc006;
	else          HL = 0xc005;
	A = [HL];
	return 0;
}

2007: DW: 80 0C B0 02
200B: DW: 01 0C 60 05
200F: DW: 81 06 B0 02
2013: DW: 82 10 40 02
2017: DW: 04 0C 00 04 83
201B: DW: 0C 00 02
201F: DW: 84 06 00 02

/* always returns 0 */
void func_2023(void)
{
	*data_buffer_wptr = 0x8000;
	*data_buffer_rptr = 0x8000;
	*data_buffer_size = 0x1000;
	return 0;
}
/* always returns 0 */
void func_2033(void)
{
	if (!(VV[0x11] & 0x80))
		return 0;
	HL = 0xC001;
	while ((A = [HL]) != [HL]);
	C = 0x4E;
	if (!(A & 0x01)) C &= 0xfb;
	if (!(A & 0x10)) C |= 0x10;
	if (!(A & 0x08)) C |= 0x20;
	A &= 0x66; /* 0110 0110 */ /* A = x12x x56x */
	A >>= 1; /* A = xx12 xx56 */
	B = A; /* B = xx12 xx56 */
	A &= 0x03;	/* 0000 0011 */ /* A = xxxx xx56 */
	B >>= 2; /* B = xxxx 12xx */
	A |= B; /* A = xxxx 1256 */
	if (A <= 0x03)
		C |= 0x01;
	HL = 0x2079;
	TM0  = [HL+A];
	SML  = C;
	SMH  = 0x0C;
	TMM  = 0x93; /* 1001 0011 */
	TMM &= 0xec; /* 1110 1100 */
	skit(ER);
	return 0;
}

2079: DW: 80 57 47 40 C0 80 40 20 15 10 08 04 80 20 10 04 5F 11

/* unreal */
void data_buffer_fifo_put(uint8_t c)
{
	DE = *data_buffer_wptr;
	[DE++] = c;
	rollover_DE_from_0x9000_to_0x8000(); /* always returns 0 */
	*data_buffer_wptr = DE;
}
/* unreal */
uint8_t data_buffer_fifo_get(void)
{
	DE = *data_buffer_rptr;
	A = [DE++];
	rollover_DE_from_0x9000_to_0x8000(); /* always returns 0 */
	*data_buffer_rptr = DE;
	return A;
}

/* always returns 0 */
void func_2089(void)
{
	if ( (VV[0x11] & 0x80)) return;
	if (!(VV[0x11] & 0x40)) return;
	if ( (VV[0x11] & 0x20)) return;
	if (!([0xC002] & 0x80)) return;

	disable_interrupts();
	EA = [0xc002];
	A  = [0xc004];
	[0xc004] = (A |= 0x20); /* 0010 0000 */
	[0xc004] = (A &= 0xfe); /* 1111 1110 */
	enable_interrupts();
	[0xc004] = (A &= 0xdf); /* 1101 1111 */

	data_buffer_fifo_put(EAH);

	disable_interrupts();

	*data_buffer_size--;

	if (*data_buffer_size == 0x0000) {
		VV[0x11] |= DATA_BUFFER_FULL;
		[0xC004] &= 0xFD; /* 1111 1101 */
	}
	enable_interrupts();
	return 0;
}

/* 20CE */
void __attribute__((interrupt)) irq_serial(void)
{
	uint8_t rxb = RXB;

	MKH |= 0x02; /* 0000 0010 */ /* mask INTSR */

	enable_interrupts();
	if (!(VV[0x11] & DATA_BUFFER_FULL) && !(IRR & INTER)) {
		/* INTER == serial parity or framing error */

		data_buffer_fifo_put(rxb);

		disable_interrupts();

		*data_buffer_size--;
		if (*data_buffer_size == 0x0000)
			VV[0x11] |= DATA_BUFFER_FULL;

		enable_interrupts();

		if (*data_buffer_size == 0x0100) {
			VV[0x11] |= 0x40;
			[0xC004] |= 0x01;
			TXB = 0x13;
		}
	}

	MKH &= 0xfd; /* 1111 1101 */ /* activate INTSR */

	return; /* FROM INTERRUPT */
}

2112:
	40 A5 0E           CALL    $0EA5
	func_2089(); /* always returns 0 */

2116:
	if (func_2127())
		return 0;
	goto 2112;

/* 211B */
int data_buffer_empty(void)
{
	return (*data_buffer_size == 0x1000);
}

/* 2127 */
int func_2127(void)
{
	MKH |= 0x02; /* 0000 0010 */ /* mask INTSR */

	if (data_buffer_empty()) {
		MKH &= 0xfd; /* 1111 1101 */ /* activate INTSR */
		return 0;
	}

	*data_buffer_size++;
	VV[0x11] &= ~DATA_BUFFER_FULL;

	if (!(VV[0x11] & 0x80))
		[0xC004] |= 0x02;

	VV[PRINT_THIS_CHAR] = data_buffer_fifo_get();

	MKH &= 0xfd; /* 1111 1101 */ /* activate INTSR */

	if ((VV[0x11] & 0x40) && *data_buffer_size == 0x0210) {
		VV[0x11] &= 0xbf; /* 1011 1111 */
		TXB = 0x11;
		[0xC004] &= 0xFE;
		[0xC004] |= 0x02;
	}

	func_2FE9(); /* always returns 0 */
	A = VV[PRINT_THIS_CHAR];
	return 1;
}

216F:
	HL = [0x9901];
	[0x9903] = HL;
	VV[0x03] |= 0x08
	VV[0x11] &= 0xC3;
	HL = 0x0000;
	[0x9947] = HL;
	VV[0x33] = 0x00;
	HL = 0x9A79;
	[0x9945] = HL;
	if (!(VV[0x11] & 0x01))
		goto 21EE;
	DE = [0x9951];
	EA = DE;
	DE = [0x9939] + 3;
	EA -= DE;
	A = 0x03;
	EA = EA / A, A = EA % A; /* simultaneously */
	BC = EA;
	HL = 0x9A79;
	EA = 0x0000;
	goto 21DC
21AD:
	push(BC);
	push(EA);
	A = [DE++];
	EA = [DE++];
	77 20              EQI     A,$20
	goto 21B9
	EA = pop();
	BC = pop();
	goto 21DC
21B9:
	3D                 STAX    (HL+)
	push(VA);
	59 02              BIT     1,VV:02
	goto 21C2
	A = EAL;
	A &= 0x7f;
	EAL = A;
21C2:
	[HL++] = EA;
	VV[0x03] &= 0xF7;
	A = EAH;
	57 10              OFFI    A,$10
	VV[0x11] |= 0x10
	A = EAL;
	57 20              OFFI    A,$20
	VV[0x11] |= 0x08
	VA = pop();
	BC = EA;
	func_22C9(); /* always returns 0 */
	BC = pop();
	EA += BC;
	BC = pop();
21DC:
	53                 DCR     C
	goto 21AD
	DE = [0x9905];
	[0x9903] = DE;
	EA += DE;
	DE = EA;
	[0x9901] = DE;
21EE:
	[0x9939] = HL;
	return 0;

/* 21F3 */
void rollover_DE_from_0x9000_to_0x8000(void)
{
	if (DE == 0x9000)
		DE =  0x8000;
}

/* 21FC */
void rollover_DE_from_0x7fff_to_0x8fff(void)
{
	if (DE == 0x7fff)
		DE =  0x8fff;
}

/* 2205 */
int func_2205(void)
{
	BC = [0x9939];
	EA = 0x9DA9;
	if (EA > BC)
		return 1;
	return 0;
}
/* 2210 */
int func_2210(void)
{
	HL = [0x9939];
	EA = 0x9A79;
	if (EA >= HL)
		return 1;
	return 0;
}

221B:
	40 05 22           CALL    $2205
	func_1B05(); /* always returns 0 */
	VV[0x03] &= 0x7f;
	HL = 0x9901;
	EA = [HL];
	DE = [0x993b];
	EA += DE;
	[HL] = EA;
	if (VV[0x09] & 0x10)
		VV[0x11] |= 0x10;
	if (VV[0x08] & 0x20)
		VV[0x11] |= 0x08;
	HL = 0x9808;
	EA = [HL];
	HL = [0x9939];
	A = VV[PRINT_THIS_CHAR];
	if (VV[0x05] & 0x80)
		func_2254();
	[HL++] = A;
	[HL++] = EA; /* uint16_t */
	[0x9939] = HL;
	return 0;

void func_2254(void)
{
	if (A != 0x20) {
		if (VV[0x03] & 0x08) {
			[0x9945] = HL;
			return 0;
		}
		push(EA);
		push(HL);
		HL = 0x9947;
		EA = [HL];
		EA += DE;
		[HL] = EA;
		VV[0x33]++; /* skip on carry? */
		HL = pop();
		EA = pop();
	}
	VV[0x03] &= 0xf7; /* 1111 0111 */
	return 0;
}

int func_2272(void)
{
	EA = [0x9935];
	HL = [0x9937];
	if (EA == HL)
		return 0;
	if (VV[0x00] & 0x04) {
		A  = [HL++];
		EA = [HL  ];
		HL -= 4;
	} else {
		A  = [HL++];
		EA = [HL++];
	}
	[0x9937] = HL;
	return 1;
}

2291:
	push(EA);
	40 05 22           CALL    $2205
	func_1B05(); /* always returns 0 */
	EA = pop();
	55 07 40           OFFIW   VV:07,$40
	VV[0x11] |= 0x20;
	A = VV[0x09];
	A |= 0x01;
	HL = [0x9939];
	[HL++] = EA;
	3D                 STAX    (HL+)
	[0x9939] = HL;
	[0x9945] = HL;
	HL = 0x9901;
	EA = [HL];
	DE = [0x993B];
	EA += DE;
	[HL] = EA;
	HL = 0x0000;
	[0x9833] = HL;
	[0x9947] = HL;
	return 0;

/* always returns 0 */
/* 22C9 */
void func_22C9(void)
{
	push(BC);
	func_22E6(); /* always returns 0 */
	if      (VV[0x07] & 0x40) A = 0x10;
	else if (B        & 0x04) A = 0x0c;
	else                      A = 0x06;
	EA = mul24(EA, A);
	BC = pop();
	if (B & 0x01)
		return 0;
	if (C & 0x08)
		EA <<= 1;
	return 0;
}

/* always returns 0 */
void func_22E6(void)
{
	if (B & 0x01) {
		EAL = A;
		A = C;
		EAH = A;
		return 0;
	}
	if      (VV[0x07] & 0x40) A = 0x09;
	else if (C & 0x80)        A = 0x0A;
	else                      A = 0x0C;
	if (B & 0x04)
		A += 2;
	EA = 0x0000;
	EAL = A;
	return 0;
}
/* always returns 0 */
void func_2313(void)
{
	[0x995B] = 0x0400;
	memset(0x9000, 0x00, 0x07fe);
	return 0;
}

2322:
	if (VV[0x12] & 0x80) {
		DE = [0x9941];
		EA = 0x0000;
		74 EE              DNE     EA,DE
		return 0;
		DE--;
		[0x9941] = DE;
		func_2127(); /* ignore rets, there's a nop after this */
		EA = 0x0000;
		EAH = A;
		if (VV[0x12] & 0x08) {
			push(EA);
			func_2127(); /* ignore rets, there's a nop after this */
			EA = pop();
			EAL = A;
		}
		HL = 0x9925;
		[HL] = EA;
		return 1;
	}
	DE = [0x995B];
	EA = [DE];
	HL = 0x0400;
	74 EF              DNE     EA,HL
	return 0;
	EA++;
	[DE] = EA;
	DE = [0x995F];
	EA = [DE];
	HL = 0x9925;
	[HL] = EA;
	EA = 0x0000;
	[DE++] = EA;
	func_242B(); /* always returns 0 */
	[0x995F] = DE;
	return 1;

234C:
	VV[0x40] &= 0xBF;
	EA = 0x0100;
	DE = [0x995B];
74 AE              DGT     EA,DE
	goto 235D;
	VV[0x40] |= 0x40;
	return 1;
235D:
	55 40 10           OFFIW   VV:40,0x10
	goto 237A;
	VV[0x40] = 0x00;
	A = 0x00;
	[0xc000] = A;
	VV[0x3c] = A;
	VV[0x3d] = A;
	if (!func_2272())
		return 0;
	HL = 0x9837;
	[HL++] =  A;
	[HL  ] = EA; /* VV[0x38] */
	BC = EA;
237A:
	func_2436();
	goto 23A0
	37 B0              LTI     A,$B0
	37 B3              LTI     A,$B3
	goto 2387;
	VV[0x40] |= 0x80;
2387:
	func_22E6(); /* always returns 0 */
	if (VV[0x39] & 0x02)
		A <<= 1;
	VV[0x3A] = A;
	func_24D0(); /* always returns 0 */
	HL = 0x9965;
	func_2686(); /* always returns 0 */
	func_25EF(); /* always returns 0 */
	func_262A(); /* always returns 0 */

23A0:
	A = VV[0x3A];
	if (!A--)
		return 1;
	A += VV[0x3D];
	VV[0x3A] = A;
	DE = [0x995D];
	if (VV[0x37] == ' ')
		goto 23DE;
	5A 00              BIT     2,VV:00
	goto 23C7
	func_2418(); /* always returns 0 */
	HL = [0x9959];
23BD:
	HL--;
	HL--;
	EA = [HL];
	BC = EA;
	40 F1 23           CALL    $23F1
	goto 23BD
	goto 23D9
23C7:
	58 40              BIT     0,VV:40
	HL = 0x9965;
	HL = 0x99ED;
23CF:
	EA = [HL++];
	BC = EA;
	40 F1 23           CALL    $23F1
	goto 23CF
	func_2418(); /* always returns 0 */
23D9:
	[0x995D] = DE;
	return 1;
23DE:
	55 00 04           OFFIW   VV:00,$04
	func_2418(); /* always returns 0 */
23E4:
	BC = 0x0000;
	40 F1 23           CALL    $23F1
	goto 23E4
	5A 00              BIT     2,VV:00
	func_2418(); /* always returns 0 */
	goto 23D9
23F1:
	5C 38              BIT     4,VV:38
	goto 2405
	55 38 04           OFFIW   VV:38,$04
	goto 2403
	5A 00              BIT     2,VV:00
	goto 2400
	74 5D 02           OFFI    E,$02
	goto 2403
	goto 2405
2400:
	74 4D 02           ONI     E,$02
2403:
	C = 0x80;
2405:
	EA = [DE];
	EA |= BC;
	[DE++] = EA;
	func_242B(); /* always returns 0 */
	push(HL);
	HL = 0x995B;
	disable_interrupts();
	[HL]--;
	enable_interrupts();
	HL = pop();
	if (!VV[0x3A]--)
		return 1;
	return 0;

/* always returns 0 */
void func_2418(void)
{
	A = VV[0x3D];
	while (A--) {
		DE--;
		DE--;
		func_242B(); /* always returns 0 */
		HL = 0x995B;
		disable_interrupts();
		EA = [HL];
		EA++;
		[HL] = EA;
		enable_interrupts();
	}
	return 0;
}
/* always returns 0 */
void func_242B(void)
{
	if (D == 0x98) D = 0x90;
	if (D == 0x8F) D = 0x97;
	return 0;
}

2436:
	if (!(VV[0x40] & 0x10))
		goto 243F;
	BC = [0x9961];
	goto 2482;
243F:
	if ((VV[0x39] & 0x01) || (VV[0x10] & 0x50))
		VV[0x38] &= 0xef;
	if (!(VV[0x39] & 0x01))
		goto 2457;
	BC = [0x9837];
	EA = BC;
	if (VV[0x39] & 0x02)
		EA <<= 1;
	BC = EA;
	goto 2482;
2457:
	if (!(VV[0x05] & 0x08) || (A != ' '))
		goto 2462;
	if (!func_24A0())
		goto 2482;
2462:
	if (A == ' ')
		goto 2472;
	5C 10              BIT     4,VV:10
	goto 246B;
	5C 39              BIT     4,VV:39
	goto 2472;
246B:
	55 10 40           OFFIW   VV:10,$40
	55 38 20           OFFIW   VV:38,$20
	return 1;
2472:
	func_22E6(); /* always returns 0 */
	55 39 02           OFFIW   VV:39,$02
	48 25              SLL     A
	55 38 08           OFFIW   VV:38,$08
	48 25              SLL     A
	C = A;
	B = 0x00;
2482:
	if (B == 0x00) {
		VV[0x40] &= 0xEF;
		A = C;
	} else {
		VV[0x40] |= 0x10;
		A = 0xFF;
	}
	60 33              SUBNB   C,A
	52                 DCR     B
	[0x9961] = BC;
	func_2497(); /* always returns 0 */
	return 0;

/* always returns 0 */
void func_2497(void)
{
	VV[0x3A] = A;
	VV[0x3d] = 0x00;
	VV[0x37] = ' ';
	return 0;
}

24A0:
	HL = 0x9937;
	EA = [HL];
	if (VV[0x00] & 0x04) {
		EA += 3;
	} else {
		EA -= 3;
	}
	HL = [0x9945];
	74 AF              DGT     EA,HL
	return 1;
	HL = 0x9953;
	EA = [HL];
	if (!(VV[0x00] & 0x04))
		goto 24C7;
	A = VV[0x35];
	74 A8 36           GTAW    VV:36
	EA++;
	30 35              DCRW    VV:35
	goto 24CE
24C7:
	if (VV[0x36] == 0x00)
		goto 24CE;
	EA++;
	30 36              DCRW    VV:36
24CE:
	BC = EA;
	return 0;

24D0:
	if (VV[0x38] & 0x02) {
		B = [0x9837];
		B -= 0x3a;
		func_1AC2(); /* always returns 0 */
		if (!(VV[0x39] & 0x02)) {
			VV[0x3B] = 0x0B;
			A = [HL++];
			if (!(A & 0x80))
				VV[0x40] |= 0x02;
			EA = [0x2000];
			func_25E2(EA); /* always returns 0 */
			goto 27C9;
		}
		A = [HL++];
		VV[0x3B] = A;
		VV[0x3C] = 0x00;
		EA = 0x000E;
		EA += HL;
		DE = 0x26E9;
		if (!(VV[0x38] & 0x80))
			DE = 0x26E8;
		[0x9963] = DE;
		B = 0x80;
	} else {
		A = VV[0x37];
		EA = 0x3401; /* IMPORTANT */
		if (!(VV[0x38] & 0x40))
			EA = 0x3301;
		HL = EA = [EA + 2*A];
		VV[CHARTABLE_FIELD_1] = [HL++];
		if (!(VV[0x39] & 0x02) || (VV[0x38] & 0x01) || !(VV[CHARTABLE_FIELD_1] & 0x02)) {
			A = [HL];
			if (!(A & 0x80))
				VV[0x40] |= 0x02;
			if (VV[0x39] & 0x02 || !(VV[0x39] & 0x80) || !(VV[CHARTABLE_FIELD_1] & 0x08)) {
				if (VV[0x07] & 0x40 || !(VV[CHARTABLE_FIELD_1] & 0x10)) {
					if (!(VV[CHARTABLE_FIELD_1] & 0x20) || (!(VV[0x07] & 0x40) && (VV[0x38] & 0x80))) {
						HL++;
						if (!(VV[CHARTABLE_FIELD_1] & 0x40)) {
							VV[0x3B] = 0x09;
							HL++;
							A = [HL++];
							func_25E2(A); /* always returns 0 */ /* lower byte only */
						} else {
							VV[0x3B] = 0x0B;
							A = [HL++];
							if (VV[0x40] & 0x80) {
								func_25E2(A); /* always returns 0 */ /* lower byte only */
							} else {
								if (VV[0x38] & 0x80) {
									EA = 0x6000;
									func_25E2(EA); /* always returns 0 */
								} else {
									if (VV[0x38] & 0x04 || !(VV[0x07] & 0x40)) {
										func_25E2(A); /* always returns 0 */ /* lower byte only */
									} else {
										EA = 0x2000;
										EAL = A;
										func_25E2(EA); /* always returns 0 */
									}
								}
							}
						}
					} else {
						VV[0x3B] = 0x09;
						func_25C9(0xC0); /* always returns 0 */
					}
				} else {
					VV[0x3B] = 0x08;
					func_25C9(0xE0); /* always returns 0 */
				}
			} else {
				if (!(VV[CHARTABLE_FIELD_1] & 0x04) || (!(VV[0x07] & 0x40) && !(VV[0x38] & 0x80))) {
					func_25C9(0xF0); /* always returns 0 */
					VV[0x3B] = 0x09;
					HL++;
					A = [HL++];
					func_25E2(A); /* always returns 0 */ /* lower byte only */
				} else {
					VV[0x3B] = 0x08;
					func_25C9(0xF8); /* always returns 0 */
				}
			}
			goto 27C9;
		}
		func_25C9(0xFC); /* always returns 0 */
		func_26A6(); /* always returns 0 */
		func_26B0(); /* always returns 0 */
		EA = HL;
		A = VV[0x3b];
		if (B & 0x80)
			A += 0x03;
		EA += A;
	}
	func_26EC(); /* always returns 0 */
	func_26DB(); /* always returns 0 */
	DE = 0x9965;
	A = VV[0x3C];
	if (C--)
		func_2AEA(); /* always returns 0 */
	HL = 0x99ED;
	A = VV[0x3B];
	48 25              SLL     A
	55 38 02           OFFIW   VV:38,$02
	VV[0x3B] = A;
	BC = [0xFFFF];
	while (VV[0x3b]--) {
		EA = [HL++];
		A = [C000];
		if (A & 0x80)
			continue;
		EA &= BC;
		[DE++] = EA;
		BC = [0xFFFF];
		EA ^= BC;
		BC = EA;
	}
	return 0;

/* always returns 0 */
void func_25C9(uint8_t A)
{
	const uint8_t local_var[6] = { 0x0C, 0x0D, 0x09, 0x08, 0x0B, 0x08 };
	A &= VV[CHARTABLE_FIELD_1];
	A ^= 0xff;
	B = A;
	EA = HL;
	for (int i = 0; i < 6; i++) {
		A = local_var[i];
		if (B & 0x80)
			EA += A;
		B <<= 1;
	}
	HL = EA;
	return 0;
}
/* always returns 0 */
void func_25E2(EA)
{
	if (!(VV[0x07] & 0x40) && !(VV[0x38] & 0x80))
		return;
	[C001] = EA;
	return;
}
/* always returns 0 */
void func_25EF(void)
{
	if (!(VV[0x38] & 0x0c))
		return 0;
	EA = 0x0000;
	DE = [0x9959];
	[DE++] = EA;
	[DE  ] = EA;
	HL = 0x9965;
	DE = [0x99ED];
	push(DE);
	VV[0x40] |= 0x01
	A = VV[0x3a];
	B = A;
	if (VV[0x38] & 0x08)
		A <<= 1, A &= borrow;
	VV[0x3a] = A;
	A = B + VV[0x3d];
	BC = 0x0000;
	if (!(VV[0x39] & 0x02) || !(VV[0x38] & 0x04)) {
		func_28BC(); /* always returns 0 */
	} else {
		func_28BF(); /* always returns 1, already skipped */
	}
	HL = pop();
	func_2686(); /* always returns 0 */
	return 0;
}
/* always returns 0 */
void func_262A(void)
{
	if (!(VV[0x39] & 0x02) || !(VV[0x39] & 0x80))
		return 0;
	if (VV[0x40] & 0x01) {
		DE = 0x9965;
		HL = 0x99ED;
	} else {
		DE = 0x99ED;
		HL = 0x9965;
	}
	push(HL);
	push(HL);
	push(DE);
	A = VV[0x3A] + VV[0x3D];
	51                 DCR     A
	VV[0x3B] = A;
	C = A;
	do {
		HL++;
		[DE++] = [HL++];
	} while (C--);
	HL = pop();
	EA = 0x0044;
	EA += HL;
	memset(EA, 0x00, 0x42);
	push(EA);
	B = 0x01;
	do {
		EA++;
		DE = EA;
		push(HL);
		A = VV[0x3B];
		C = A;
		do {
			A = [HL++];
			A &= B;
			A |= [DE];
			[DE++]  = A;
		} while (C--);
		HL = pop();
	} while (B<<=1);
	HL = pop();
	DE = pop();
	A = VV[0x3B];
	C = A;
	do {
		A = [HL++];
		DE++;
		[DE++] = A;
	} while (C--);
	C = 0x07;
	do {
		[DE++] = 0x00;
		[DE++] = [HL++];
	} while (C--);
	HL = pop();
	func_2686(); /* always returns 0 */
	return 0;
}
/* always returns 0 */
void func_2686(void)
{
	[C000] = 0x00;
	EA = DE - HL;
	B = EAL >> 1;
	A = VV[0x3a];
	if (A >= B) {
		A -= B;
		if (A--)
			func_2AEA(); /* always returns 0 */
	} else {
		A -= B;
		A = ~A + 1; /* negate */
		VV[0x3d] = A;
	}
	[0x9959] = DE;
	return 0;
}
/* always returns 0 */
void func_26A6(void)
{
	B = A = [HL++];
	A &= 0x1f; /* 0001 1111 */
	VV[0x3C] = A;
	A = [HL++];
	VV[0x3B] = A;
	return;
}
/* always returns 0 */
void func_26B0(void)
{
	if (!(VV[0x38] & 0x80)) {
		HL += 3;
		[0x9963] = DE;
		return;
	}
	if (!(B & 0x40)) {
		[0x9963] = HL;
		HL += 3;
		return;
	}
	if (B & 0x80)
		A += 0x03;
	A <<= 1;
	A += 0x03;
	EA = HL;
	EA += A;
	HL = EA;
	func_26A6(); /* always returns 0 */
	[0x9963] = DE;
	return;
}
/* always returns 0 */
void func_26DB(void)
{
	push(HL);
	HL = [0x9963];
	[C001] = [HL++];
	[C002] = [HL++];
	[C003] = [HL++];
	HL = pop();
	return;
}

26E8: 00                 NOP     
26E9: 00                 NOP     
	00
	1F

/* always returns 0 */
void func_26EC(void)
{
	if (VV[0x39] & 0x40)
		goto 2723;
	if (VV[FLAGS_1] & 0x40) /* 0100 0000 */
		HL = EA;
	EA = 0x99ED;
	func_26F8(); /* always returns 0 */
	return 0;
}
/* always returns 0 */
void func_26F8(void)
{
	[0xC000] = 0x00;
	if (B & 0x80) {
		C = 0x01;
		if (!(VV[0x38] & 0x02))
			C = 0x02;
		DE = 0xC001;
		do { [DE++] = [HL++] } while (C--);
	}
	DE = EA;
	C = VV[0x3b];
	EA = 0x0000;
	do {
		[DE++] = [C000];
		[DE++] = [HL++];
		if (VV[0x38] & 0x02)
			[DE++] = EA;
	} while (C--);
	return 0;
}

2723:
	push(BC);
	push(EA);
	EA = 0x9965;
	func_26F8(); /* always returns 0 */
	HL = pop();
	BC = pop();
	EA = 0x99ED;
	func_26F8(); /* always returns 0 */
	HL = 0x9965;
	DE = 0x99ED;
	C = [0x983B];
	55 38 02           OFFIW   VV:38,$02
	48 27              SLL     C
	5E 10              BIT     6,VV:10
	goto 27B8
	goto 277D
2748:
	do {
		push(BC);
		B = 0x00;
		HL++;
		C = [DE + 0x01];
		A = [HL++];
		if (A & 0x40 || C & 0x80) B |= 0x80;
		if (A & 0x20 || C & 0x20) B |= 0x40;
		if (A & 0x08 || C & 0x10) B |= 0x20;
		if (C & 0x04            ) B |= 0x10;
		if (A & 0x01            ) B |= 0x08;
		A = [DE];
		if (A & 0x80            ) B |= 0x04;
		func_27BC(); /* always returns 0 */
		BC = pop();
277D:
	} while (C--);
	return 0;
	do {
		push(BC);
		B = 0x00;
		A = [HL++];
		if (A & 0x80            ) B |= 0x04;
		A = [DE + 0x01];
		C = A;
		A = [HL++];
		if (A & 0x80            ) B |= 0x80;
		if (C & 0x40            ) B |= 0x40;
		if (A & 0x10            ) B |= 0x20;
		if (A & 0x04 || C & 0x08) B |= 0x10;
		if (A & 0x02 || C & 0x02) B |= 0x08;
		if (C & 0x01            ) B |= 0x04;
		func_27BC(); /* always returns 0 */
		BC = pop();
27B8:
	} while (C--);
	return 0;

/* always returns 0 */
void func_27BC(void)
{
	EA = 0x0000;
	A = B;
	EAH = A;
	if (!(VV[0x39] & 0x40)) /* 0010 0000 */
		EA >>= 3;
	[DE++] = EA;
	return 0;
}

27C9:
	if (VV[0x40] & 0x80 || VV[0x39] & 0x40 || !(VV[0x39] & 0x02) || VV[FLAGS_1] & 0x10 || !(VV[FLAGS_1] & 0x40)) {
		DE = 0x9965;
		B = 0x00;
		func_27E8(); /* always returns 0 */
		if (!func_2803())
			return 0;
		VV[0x3B] = A;
		func_27E8(); /* always returns 0 */
		return 0;
	}
	DE = 0x99ED;
	C = [0x983B];
	if (C--) {
		do {
			[DE++] = [HL++]
		} while (C--);
	}
	if (func_2803()) {
		C = A;
		A += VV[0x3B];
		VV[0x3B] = A;
		if (C--) {
			do {
				[DE++] = [HL++]
			} while (C--);
		}
	}
	HL = 0x99ED;
	DE = [0x9965];
	EA = 0x0000;
	VV[0x3B]--; /* don't do first A = [HL++]; on overflow */
	do {
		A = [HL++];
		B = A;
		C = [C000];
		if (!(C & 0x80)) {
			while (1) {
				do {
					if (VV[0x3b] == 0x00) {
						C = 0x00;
						break;
					}
					A = [HL++];
					C = [C000];
					if (!(C & 0x80)) {
						C = A;
						break;
					}
				} while (VV[0x3b]--);
				func_2958(); /* always returns 0 */
				func_2909(); /* always returns 0 */
				func_28F4(); /* always returns 0 */
				EAH = A;
				if (!VV[0x3b]--)
					break;
				func_2965(); /* always returns 0 */
				func_2909(); /* always returns 0 */
				func_28F4(); /* always returns 0 */
				EAH = A;
				A = B;
				EAL = A;
				A = C;
				B = A;
			}
		}
	} while (VV[0x3b]--);
	return 0;

/* always returns 0 */
/* 27E8 */
void func_27E8(void)
{
	while (VV[0x3b]--) {
		A = B;
		A ^= 0xff;
		A &= [HL++];
		C = [C000];
		if (C & 0x80)
			continue;
		B = A;
		func_28F4(); /* always returns 0 */
		if (!(VV[0x38] & 0x02))
			continue;
		A = 0x00;
		B = A;
		func_28F4(); /* always returns 0 */
	}
	return 0;
}

/* 2803 */
int func_2803(void)
{
	if ((VV[0x07] & 0x40) || !(VV[0x39] & 0x04))
		return 0;
	A = 0x01;
	if (VV[0x39] & 0x04)
		A += 2;
	if (A & 0x80 || A == 0x00)
		return 0;
	HL -= 3;
	return 1;
}

/* always returns 0 */
void func_28BC(void)
{
	while (A--) {
		EA = [HL++];
		push(EA);
		EA |= BC;
		[DE++] = EA;
		if (VV[0x38] & 0x08) {
			if (!(VV[0x38] & 0x04))
				EA = 0x0000;
			[DE++] = EA;
		}
		BC = pop();
	}
	return 0;
}
/* always returns 1 */
void func_28BF(void)
{
	if (++A)
		[0x9957] = BC;
	EA = BC;
	do {
		push(EA);
		EA = [HL++];
		push(EA);
		EA |= BC;
		if (VV[0x38] & 0x08) {
			BC = [0x9957];
			push(BC);
			BC = EA;
			[0x9957] = BC;
			BC = pop();
			EA |= BC;
			[DE++] = EA;
			EA = 0x0000;
		} else {
			push(EA);
			BC = 0xFFFF;
			EA = [HL];
			EA ^= BC;
			BC = pop();
			EA &= BC;
		}
		[DE++] = EA;
		EA = pop();
		BC = pop();
	} while (A--);
	return 1;
}
/* always returns 0 */
/* 28F4 */
void func_28F4(void)
{
	func_2911(); /* always returns 0 */
	EA = 0x0000;
	EAH = A;
	if (VV[0x40] & 0x02)
		EA >>= 1;
	if (VV[0x39] & 0x40)
		func_2925(); /* always returns 0 */
	[DE++] = EA;
	return 0;
}
/* always returns 0 */
/* 2909 */
void func_2909(void)
{
	if (!(VV[0x39] & 0x10))
		return 0;
	if (A & 0x02)
		A |= 0x01;
	return 0;
}

/* always returns 0 */
/* 2911 */
void func_2911(void)
{
	if (VV[0x10] & 0x10 || !(VV[0x39] & 0x10))
		return 0;
	if (VV[0x40] & 0x80) {
		A &= 0x0F;
		return 0;
	}
	if (!(A & 0x01)) A = 0x00;
	else             A = 0x0F;
	return 0;
}
/* always returns 0 */
/* 2925 */
void func_2925(void)
{
	push(BC);
	C = 0x00;
	if (VV[0x10] & 0x40)
		EA <<= 1;
	A = EAH;
	if (A & 0x80) C |= 0x80;
	if (A & 0x20) C |= 0x40;
	if (A & 0x08) C |= 0x20;
	if (A & 0x02) C |= 0x10;
	if (!(VV[0x10] & 0x40)) {
		A = EAL;
		if (A & 0x80)
			C |= 0x08;
	}
	EA = 0x0000;
	A = C;
	EAH = A;
	if (!(VV[0x39] & 0x20))
		EA >>= 4;
	BC = pop();
	return 0;
}
/* always returns 0 */
/* 2958 */
void func_2958(void)
{
	push(DE);
	push(HL);
	func_298C(); /* always returns 0 */
	func_29B8(); /* always returns 0 */
	A |= D;
	HL = pop();
	DE = pop();
	return 0;
}
/* always returns 0 */
/* 2965 */
void func_2965(void)
{
	push(DE);
	push(HL);
	A = B;
	func_29B8(); /* always returns 0 */
	D = A;
	A = C;
	A &= 0x7f;
	A = [HL+A];
	if (!(C & 0x80))
		A &= 0x7f;
	D |= A;
	D ^= 0xff;
	A = B;
	A <<= 1;
	A &= C;
	H = A;
	A = C;
	A <<= 1;
	A &= B;
	A |= H;
	A &= D;
	HL = pop();
	DE = pop();
	return 0;
}

/* always returns 0 */
void func_298C(void)
{
	A = EAL;
	48 25              SLL     A
	A &= C;
	D = A;
	A = EAL;
	E = A;
	A = C;
	48 25              SLL     A
	A &= E;
	D |= A;
	A = B;
	48 25              SLL     A
	A |= B;
	E = A;
	push(BC);
	HL = 0x2A52;
	A = EAL;
	func_29C4(); /* always returns 0 */
	E |= A;
	A = C;
	func_29C4(); /* always returns 0 */
	A |= E;
	A ^= 0xff;
	D &= A;
	BC = pop();
	A = B;
	return;
}
/* always returns 0 */
void func_29B8(void)
{
	HL = 0x29D2;
	A &= 0x7f;
	A = [HL+A];
	if (!(B & 0x80))
		A &= 0x7f; /* 0111 1111 */
	return;
}
/* always returns 0 */
void func_29C4(void)
{
	if (A == 0x7c)
		A = 0xfc;
	B = A;
	A &= 0x7f;
	A = [HL+A];
	if (!(B & 0x80))
		A &= 0xbf; /* 1011 1111 */
	return;
}

29D2: DW: 00 00 00 02 00 00 04 06 00 00 00 02 08 08 0C 0E
29E2: DW: 00 00 00 02 00 00 04 06 10 10 10 12 18 18 1C 1E
29F2: DW: 00 00 00 02 00 00 04 06 00 00 00 02 08 08 0C 0E
2A02: DW: 20 20 20 22 20 20 24 26 30 30 30 32 38 38 3C 3E
2A12: DW: 80 80 80 82 80 80 84 86 80 80 80 82 88 88 8C 8E
2A22: DW: 80 80 80 82 80 80 84 86 90 90 90 92 98 98 9C 9E
2A32: DW: C0 C0 C0 C2 C0 C0 C4 C6 C0 C0 C0 C2 C8 C8 CC CE
2A42: DW: E0 E0 E0 E2 E0 E0 E4 E6 F0 F0 F0 F2 F8 F8 FC FE

2A52: DW: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04
2A62: DW: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 08 0C
2A72: DW: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04
2A82: DW: 00 00 00 00 00 00 00 00 00 00 00 00 18 10 18 1C
2A92: DW: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04
2AA2: DW: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 08 0C
2AB2: DW: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04
2AC2: DW: 40 40 40 40 40 40 40 40 60 60 60 60 78 70 78 7C

/* always returns 0 */
/* 2AD2 */
void func_2AD2(void)
{
	if      (VV[0x07] & 0x40) A = 0x00;
	else if (VV[0x09] & 0x06) A = 0x0C;
	else                      A = 0x06;
	func_2497(); /* always returns 0 */
	VV[0x38] &= 0xef;
	func_23A0(); /* result skipped */
	return 0;
}

void func_2AEA(void)
{
	EA = 0x0000;
	do {
		B = [C000];
		if (!(B & 0x80))
			[DE++] = EA;
	} while (A--);
	return 0;
}
/* always returns 0 */
/* 2AFA */
void func_2AFA(void)
{
	if (!func_2E8F()) B = 0x20;
	else              B = 0x00;
	C = [0x984F];
	push(BC);
	if (!sw_cn6_debounced()) A = 0x00;
	else                     A = 0x10;
	BC = pop();
	A |= B;
	B = A;
	A ^= C;
	if (A & 0x30) {
		VV[0x4F] = B | (C & 0x4f);
		[0x984B] = 0x0000;
		if (VV[0x4f] & 0x20) {
			if (!(VV[0x4f] & 0x10))
				VV[0x14] |= 0x02;
			goto 2B33
		}
	}
	if (VV[0x4f] & 0x10)
		VV[0x14] |= 0x02;
2B33:
	func_32BF(); /* always returns 0 */
	[C007] = 0x05;
	PC |= 0x04; /* 0000 0100 */
	delay(30);
	PC &= 0xfb; /* 1111 1011 */
	delay(25);
	if ((VV[0x4f] & 0x10) || (VV[0x4f] & 0x20)) A = 0x0C;
	else                                        A = 0x24;
	func_3012(); /* always returns 0 */
	func_301C(); /* always returns 0 */
	VV[0x13] |= 0x02;
	func_2B5A(); /* always returns 0 */
	return 0;
}
/* always returns 0 */
/* 2B5A */
void func_2B5A(void)
{
	VV[0x2C] = 0x24;
	[0x992B] = 0x0000;
	VV[0x26] = 0x00;
	return 0;
}

2B68:
	if (VV[0x26] == 0x00)
		return 0;
	goto 2BA0
2B6F:
	if (!func_32EC())
		goto 2D79;
	func_32F3(); /* always returns 0 */
	EA = [HL];
	HL = [0x992B];
	EA -= HL;
	BC = EA;
	goto 2B88
2B82:
	C = [0x982C];
	B = 0x00;

2B88:
	push(BC);
	55 14 40           OFFIW   VV:14,$40
	40 13 2C           CALL    $2C13
	func_31B0(); /* always returns 0 */
	BC = pop();
	40 B8 2B           CALL    $2BB8
	A = VV[0x26];
	EA = BC;
	EA -= A;
	48 0A              SK      CY
	goto 2BB2
	60 E3              SUB     A,C
2BA0:
	A += 0x0c;
	5D 4F              BIT     5,VV:4F
	A += 0x18;
	C = A;
	B = 0x80;
	func_313F(); /* always returns 0 */
	EA = 0x000C;
	5D 4F              BIT     5,VV:4F
	EA = 0x0024;
2BB2:
	BC = EA;
	func_313F(); /* always returns 0 */
	VV[0x26] = 0x00;
	return 0;
2BB8:
	VV[0x03] &= 0xFE;
	func_32F3(); /* always returns 0 */
	EA = [HL];
	DE = EA;
	HL = 0x992B;
	EA = [HL];
	EA += BC;
2BC8:
	74 BE              DLT     EA,DE
	goto 2BD9
	55 4F 20           OFFIW   VV:4F,$20
	goto 2BFE
	HL = [0x992F];
	74 BF              DLT     EA,HL
	goto 2BF4
	goto 2BFE
2BD9:
	VV[0x13] &= 0xFD;
	[0x9A75] = 0x0000;
	if (!func_32E5())
		goto 2BF0;
	HL = pop();
	VV[0x26] = 0x00;
	goto 2D7D;
2BF0:
	EA -= DE;
	goto 2BC8
2BF4:
	HL = EA;
	EA = DE;
	EA -= HL;
	EA += BC;
	BC = EA;
	EA = 0x0000;
2BFE:
	HL = 0x992B;
	[HL] = EA;
	HL = 0x984B;
	EA = [HL];
	EA += BC;
	A = EAH;
	57 C0              OFFI    A,$C0
	EA = 0x3FFF;
	[HL] = EA;
	return 0;

2C13:
	if (!func_2E08())
		goto 2C27;
	if (!func_32EC())
		goto 2D47;
	if (VV[0x01] & 0x04)
		goto 2C27;
	40 7D 2D           CALL    $2D7D
	goto 2D07;
2C27:
	VV[0x14] &= 0xFD;
	return 0;

2C2B:
	func_32CF(); /* always returns 0 */
	5E 14              BIT     6,VV:14
	return 0;
	beep_x_y(5, 4, 1); /* 104E */
	goto 0EC2;
2C37:
	func_32CF(); /* always returns 0 */
	40 4B 2E           CALL    $2E4B
	00                 NOP     
	if (!sw_cn6_debounced())
		goto 2C4C;
	VV[0x13] |= 0x04
	55 13 20           OFFIW   VV:13,$20
	40 C4 32           CALL    $32C4
	VV[0x13] &= 0xDF;
2C4C:
	BC = 0x0FE4; sw_line_feed
	99                 CALT    ($00B2)
	40 79 2C           CALL    $2C79
	BC = 0x0FEB; sw_form_feed
	99                 CALT    ($00B2)
	40 A4 2C           CALL    $2CA4
	BC = 0x0FF2; sw_load_eject
	99                 CALT    ($00B2)
	40 B2 2C           CALL    $2CB2
	goto 32B9;

2C64:
	59 14              BIT     1,VV:14
	goto 2C6D
	5D 4F              BIT     5,VV:4F
	return 0;
	if (!sw_cn6_debounced())
		return 0;
	return 1;

2C6D:
	if (!(VV[0x13] & 0x04))
		return 1;
	if (!sw_cn6_debounced())
		return 0;
	5D 4F              BIT     5,VV:4F
	if (!func_2E08())
		return 1;
	return 0;

2C79:
	40 64 2C           CALL    $2C64
	goto 2CD0
	VV[0x13] &= 0xFB;
	VV[0x13] |= 0x01
2C84:
	40 82 2B           CALL    $2B82
	40 7E 30           CALL    $307E
2C8A:
	if (!sw_line_feed())
		return 0;
	BC = [0x990F];
	EA = [0x0006];
	74 AD              DGT     EA,BC
	goto 2C8A
	if (!func_32E5())
		goto 2C84;
	59 14              BIT     1,VV:14
	if (!func_2E08())
		goto 2C84;
	goto 2D7D;

2CA4:
	if (!func_32EC())
		goto 2CB2
	40 64 2C           CALL    $2C64
	goto 2CB5
	VV[0x13] &= 0xFB;
	goto 2B6F;

2CB2:
	55 14 02           OFFIW   VV:14,$02
2CB5:
	goto 2CD0
	5A 13              BIT     2,VV:13
	goto 2CBE
	if (!sw_cn6_debounced())
		goto 2CD0;
	5D 4F              BIT     5,VV:4F
	goto 2CDA
2CBE:
	goto 2D79

2CC0:
	5D 13              BIT     5,VV:13
	goto 2CCC
	if (!func_32EC())
		goto 2D79
	VV[0x13] &= 0xDF;
	return 0;
2CCC:
	if (!func_2E08())
		return 0;
2CD0:
	if (!func_32EC())
		goto 2D47
	55 4F 20           OFFIW   VV:4F,$20
	goto 2D5B
2CDA:
	90                 CALT    ($00A0)
	40 91 2D           CALL    $2D91
	90                 CALT    ($00A0)
	goto 2D03
	BC = 0x02D0;
	59 14              BIT     1,VV:14
	40 6F 2D           CALL    $2D6F
	func_313F(); /* always returns 0 */
	BC = 0x02AC;
	40 D2 2E           CALL    $2ED2
	goto 2D07
	func_31D0(); /* always returns 0 */
	BC = 0x80B2;
	func_313F(); /* always returns 0 */
	BC = [0x9847];
	EA = 0x0042;
	EA += BC;
2D01: BC = EA;
	func_313F(); /* always returns 0 */
2D03:
	40 25 2D           CALL    $2D25
	goto 2D1C

2D07:
	40 C4 32           CALL    $32C4
	59 14              BIT     1,VV:14
	goto 2DA5
	55 14 40           OFFIW   VV:14,$40
	VV[0x13] |= 0x40
	5E 14              BIT     6,VV:14
	VV[0x13] |= 0x80
	goto 2C2B;

2D1C:
	VV[0x13] &= 0x3B;
	5D 4F              BIT     5,VV:4F
	VV[0x14] |= 0x10;
	return 0;
2D25:
	func_32B9(); /* always returns 0 */
	VV[0x14] &= 0xFD;
	if (!sw_cn6_debounced())
		goto 2D2E;
	return 1;
2D2E:
	BC = 0x0000;
	[0x992B] = BC;
	[0x9929] = BC;
	[0x984B] = BC;
	VV[0x26] = 0x00;
	VV[0x13] &= 0xFD;
	VV[0x14] &= 0xFD;
	return 0;
2D47:
	59 14              BIT     1,VV:14
	40 79 2D           CALL    $2D79
	if (!sw_cn6_debounced())
		goto 2D5B;
	BC = 0x8AB6;
	func_313F(); /* always returns 0 */
	BC = 0x01DE;
	40 D2 2E           CALL    $2ED2
	goto 2D07
	goto 2D5F
2D5B:
	if (!sw_cn6_debounced())
		goto 2D5F;
	goto 2D07
2D5F:
	func_31D0(); /* always returns 0 */
	BC = [0x9843];
	EA = 0x0181;
	EA += BC;
	BC = EA;
	func_313F(); /* always returns 0 */
	goto 2D03

2D6F:
	BC = 0x04AE;
	if (!func_32E5())
		BC = 0x0393;
	return 0;
2D79:
	5D 4F              BIT     5,VV:4F
	goto 2D91

2D7D:
	40 08 2E           CALL    $2E08
	func_31D0(); /* always returns 0 */
	BC = 0x2520; /* '% ' */
	if (!func_32E5())
		BC = 0x0BD0;
	func_313F(); /* always returns 0 */
	40 6F 2D           CALL    $2D6F
	goto 2D9E

2D91:
	if (!sw_cn6_debounced())
		goto 2D94;
	goto 2D7D
2D94:
	func_31D0(); /* always returns 0 */
	BC = 0x8D80;
	func_313F(); /* always returns 0 */
	BC = 0x0070;
2D9E:
	40 AE 2E           CALL    $2EAE
	goto 2DAE
	VV[0x14] &= 0xEF;
2DA5:
	VV[0x13] &= 0xDF;
	VV[0x14] |= 0x02;
	func_32BF(); /* always returns 0 */
	return 0;
2DAE:
	VV[0x13] |= 0x20
	if (!func_32E5())
		goto 2DBC;
	40 25 2D           CALL    $2D25
	VV[0x13] |= 0x02
	goto 2DC2
2DBC:
	func_32B9(); /* always returns 0 */
	40 C5 2D           CALL    $2DC5
2DC2:
	goto 2C2B;
2DC5:
	5D 4F              BIT     5,VV:4F
	goto 2DE4
	EA = 0x0BD0;
	HL = [0x992B];
	EA += HL;
	A = VV[0x26];
	EA += A;
	HL = [0x992D];
	74 BF              DLT     EA,HL
	goto 2DDE
	goto 2DFF
2DDE:
	EA -= HL;
	74 BF              DLT     EA,HL
	goto 2DDE
	goto 2DFF
2DE4:
	HL = [0x992B];
	EA = HL;
	A = VV[0x26];
	EA += A;
	HL = 0x0D80;
	int borrow = (EA >= HL);
	EA -= HL;
	if (!borrow)
		goto 2DF4;
	goto 2DFF
2DF4:
	HL = [0x9931];
	DE = 0x0000;
2DFB:
	74 A7              DADDNC  EA,HL
	goto 2DFF
	goto 2DFB
2DFF:
	HL = EA;
	[0x992B] = HL;
	VV[0x26] = 0x00;
	return 0;

/* 2E08 */
int func_2E08(void)
{
	while (1) {
		disable_interrupts();
		DE = [9929];
		HL = [990F];
		enable_interrupts();
		EA = DE;
		if (HL != 0x0000) {
			if (!(VV[0x01] & 0x80)) {
				EA += HL;
				DE = [0x0142];
				if (EA > DE) func_2089(); /* always returns 0 */
				else         return 0;
				continue;
			}
			int borrow = (EA >= HL);
			EA -= HL;
			if (!borrow)
				return 0;
		} else {
			A = VV[0x26];
			int carry = (A > EA);
			EA -= A;
			if (carry)
				return 0;
		}
		DE = [0x0142];
		if (EA > DE) return 1;
		else         return 0;
	}
}

/* 2E3A */
int sw_cn6_debounced(void)
{
	return ckbit_1(read_debounced_PA());
}
/* 2E3E */:
int sw_cn6(void)
{
	return ckbit_1(read_stable_PA());
}

/* 2E41 */
int ckbit_1(uint8_t A)
{
	if (A & 0x02) {
		VV[0x4F] &= 0xEF; /* 1110 1111 */
		return 0;
	} else {
		VV[0x4F] |= 0x10; /* 0001 0000 */
		return 1;
	}
}

2E4B:
	if (!func_2E8F())
		goto 2E68;
	55 4F 20           OFFIW   VV:4F,$20
	goto 2E60
	5A 13              BIT     2,VV:13
	return 1;
	if (!sw_cn6_debounced())
		goto 2E59;
	return 1;
2E59:
	one_short_beep(); /* always returns 0 */
	goto 2E4B
2E5B:
	one_short_beep(); /* always returns 0 */
	if (!func_2E8F())
		return 1;
2E60:
	40 7D 2E           CALL    $2E7D
	goto 2E5B
	VV[0x4F] &= 0xDF;
	goto 2E7A
2E68:
	55 4F 20           OFFIW   VV:4F,$20
	return 1;
	goto 2E73
2E6D:
	one_short_beep(); /* always returns 0 */
	if (!func_2E8F())
		goto 2E73;
	return 1;
2E73:
	40 7D 2E           CALL    $2E7D
	goto 2E6D
	VV[0x4F] |= 0x20
2E7A:
	func_32BF(); /* always returns 0 */
	return 0;
2E7D:
	if (!func_2E08())
		goto 2E82;
	return 1;
2E82:
	BC = [0x9929];
	EA = 0x0000;
	if (EA != BC)
		return 0;
	if (!sw_cn6_debounced())
		return 0;
	return 1;

int func_2E8F(void)
{
	if (!sw_cn4())
		if (  VV[0x4f] & 0x20 )
			return 0;
	} else {
		if (!(VV[0x4f] & 0x20))
			return 1;
	}
	A, B = read_debounced_PA();
	if (A & 0x04)
		return 0;
	return 1;
}
/* 2E9F */
int sw_cn4(void)
{
	if (read_stable_PA() & 0x04)
		return 0;
	return 1;
}

/* always returns 0 */
/* 2EA6 */
void func_2EA6(void)
{
	A = C;
	A += VV[0x26];
	VV[0x26] = A;
	func_313F(); /* always returns 0 */
	return 0;
}

2EAE:
	func_2089(); /* always returns 0 */
	HL = 0x990F;
	EA = [HL];
	DE = 0x0000;
	74 AE              DGT     EA,DE
	return 0;
	5C 4F              BIT     4,VV:4F
	goto 2EAE
	DE = EA;
2EBE:
	EA = [HL];
	74 EE              DNE     EA,DE
	goto 2EBE
	5C 4F              BIT     4,VV:4F
	goto 2EAE
	HL = [0x990F];
	[0x9A77] = HL;
	40 F0 2E           CALL    $2EF0
	return 1;
2ED2:
	func_2089(); /* always returns 0 */
	HL = 0x990F;
	EA = [HL];
	DE = 0x0000;
	74 AE              DGT     EA,DE
	return 0;
	55 4F 10           OFFIW   VV:4F,$10
	goto 2ED2
	DE = EA;
2EE3:
	EA = [HL];
	74 EE              DNE     EA,DE
	goto 2EE3
	55 4F 10           OFFIW   VV:4F,$10
	goto 2ED2
	40 F0 2E           CALL    $2EF0
	return 1;
2EF0:
	disable_interrupts();
	55 01 10           OFFIW   VV:01,$10
	55 01 22           OFFIW   VV:01,$22
	goto 2EFE
	[0x990F] = BC;
	enable_interrupts();
	return 0;
2EFE:
	enable_interrupts();
	func_32B9(); /* always returns 0 */
	55 01 80           OFFIW   VV:01,$80
	B |= 0x80;
	func_313F(); /* always returns 0 */
	return 0;

2F0A:
	59 13              BIT     1,VV:13
	55 03 02           OFFIW   VV:03,$02
	return 1;
	5C 13              BIT     4,VV:13
	goto 2F1A
	40 67 30           CALL    $3067
	func_2FB3(); /* always returns 0 */
	goto 2F34
2F1A:
	45 0F C0           ONIW    VV:0F,$C0
	55 01 30           OFFIW   VV:01,$30
	return 1;
	40 EC 32           CALL    $32EC
	59 14              BIT     1,VV:14
	55 13 02           OFFIW   VV:13,$02
	return 1;
	EA = 0x0000;
	BC = [0x992B];
	74 FD              DEQ     EA,BC
	return 1;
2F34:
	5C 13              BIT     4,VV:13
	55 4F 80           OFFIW   VV:4F,$80
	goto 2F43
	if (!func_32EC())
		goto 2F52
	55 01 04           OFFIW   VV:01,$04
	goto 2F52
	goto 2F4C
2F43:
	BC = [0x9A75];
	EA = [0x03FF];
	74 ED              DNE     EA,BC
2F4C:
	if (!sw_cn6())
		goto 2F52;
	goto 2FAA
2F52:
	BC = [0x9A75];
	BC++;
	EA = 0x03FF;
	74 BD              DLT     EA,BC
	if (!data_buffer_empty())
		BC = 0x0000;
	if (!func_2210())
		BC = 0x0000;
	[0x9A75] = BC;
	EA = 0x0000;
	74 ED              DNE     EA,BC
	return 1;
	55 13 10           OFFIW   VV:13,$10
	return 1;
	EA = 0x0000;
	BC = [0x984B];
	5F 4F              BIT     7,VV:4F
	74 ED              DNE     EA,BC
	goto 2F96
	5D 4F              BIT     5,VV:4F
	55 14 01           OFFIW   VV:14,$01
	return 1;
	BC = [0x9A75];
	EA = 0x03FF;
	74 FD              DEQ     EA,BC
	return 1;
	if (!func_2FC8())
		goto 2FAA;
2F96:
	BC = 0xC805;
2F99:
	push(BC);
	delay(C);
	if (!sw_online())
		goto 2FA8;
	BC = pop();
	52                 DCR     B
	goto 2F99
	VV[0x13] |= 0x10
	one_short_beep(); /* always returns 0 */
	sw_online_wait();
	return 1;
2FA8:
	BC = pop();
	return 1;
2FAA:
	VV[0x4F] &= 0x7F;
	VV[0x13] &= 0xEF;
	func_32BF(); /* always returns 0 */
	return 0;

/* always returns 0 */
/* 2FB3 */
void func_2FB3(void)
{
	BC = [0x9A75];
	EA = [0x03FF];
	if (EA != BC)
		return 0;
	[0xC004] ^= 0x10;
	return 0;
}
/* 2FC8 */
int func_2FC8(void)
{
	func_32B9(); /* always returns 0 */
	if (sw_cn6_debounced())
		return 0;
	EA = 0x0268;
	BC = [0x9849];
	EA += BC;
	BC = [0x9847];
	EA -= BC;
	BC = EA;
	func_313F(); /* always returns 0 */
	func_32B9(); /* always returns 0 */
	if (!sw_cn6_debounced()) {
		VV[0x4F] |= 0x80;
		return 1;
	}
	return 0;
}
/* always returns 0 */
/* 2FE9 */
void func_2FE9(void)
{
	if (VV[0x4f] & 0x80)
		func_301C(); /* always returns 0 */
	func_2FEF(); /* always returns 0 */
	return 0;
}
/* always returns 0 */
/* 2FEF */
void func_2FEF(void)
{
	if (!(VV[0x13] & 0x10))
		return 0;
	VV[0x13] &= 0xEF;
	BC = 0x0000;
	[0x9A75] = BC;
	A = [0xC004];
	A |= 0x10;
	[0xC004] = A;
	if (!(VV[0x13] & 0x08))
		return 0;
	VV[0x13] &= 0xF7;
	if (!(VV[0x4f] & 0x20)) A = 0x24;
	else                    A = 0x0C;
	func_3012(); /* always returns 0 */
	return 0;
}
/* always returns 0 */
/* 3012 */
void func_3012(void)
{
	C = A;
	push(BC);
	B = 0x80;
	func_313F(); /* always returns 0 */
	BC = pop();
	B = 0x00;
	func_313F(); /* always returns 0 */
	return 0;
}
/* always returns 0 */
/* 301C */
void func_301C(void)
{
	if (!(VV[0x4f] & 0x80))
		return 0;
	func_31D0(); /* always returns 0 */
	EA = 0x028C;
	BC = [0x9849];
	EA += BC;
	BC = [0x9847];
	EA -= BC;
	BC = EA;
	B |= 0x80;
	func_313F(); /* always returns 0 */
	VV[0x4F] &= 0x7F;
	BC = 0x0024;
	func_313F(); /* always returns 0 */
	func_32B9(); /* always returns 0 */
	BC = 0x0000;
	[0x984B] = BC;
	VV[0x14] &= 0xEF;
	VV[0x13] |= 0x02
	return 0;
}

/* always returns 0 */
/* 304E */
void func_304E(void)
{
	if (!(VV[0x14] & 0x10))
		return 0;
	VV[0x14] &= 0xEF;
	func_32F3(); /* always returns 0 */
	EA = [HL];
	HL = [0x984B];
	HL++;
	if ((VV[0x4f] & 0x20) || (HL <= EA))
		return 0;
	A = 0x24;
	func_3012(); /* always returns 0 */
	return 0;
}

3067:
	VV[0x13] |= 0x01
306A:
	if (!sw_line_feed())
		goto 3072;
	40 D1 30           CALL    $30D1
	goto 3077
3072:
	if (!sw_form_feed())
		return 0;
	40 9C 30           CALL    $309C
3077:
	func_32B9(); /* always returns 0 */
	40 7E 30           CALL    $307E
	goto 306A

307E:
	58 13              BIT     0,VV:13
	return 0;
	func_32B9(); /* always returns 0 */
	BC = 0x8702;
3087:
	push(BC);
	delay(C);
	A, B = read_stable_PA();
	BC = pop();
	A &= 0xc0;
	67 C0              NEI     A,$C0
	goto 3098
	52                 DCR     B
	goto 3087
	VV[0x13] &= 0xFE;
	return 0;
3098:
	VV[0x13] |= 0x01
	return 0;
309C:
	EA = 0x0000;
	HL = [0x984B];
	74 FF              DEQ     EA,HL
	goto 30C2
	HL = [0x9847];
	55 4F 20           OFFIW   VV:4F,$20
	HL = [0x9843];
	EA = 0x01B0;
	74 FF              DEQ     EA,HL
	goto 30BC
30B8:
	one_short_beep(); /* always returns 0 */
	if (!sw_form_feed())
		return 0;
	goto 30B8
30BC:
	5D 4F              BIT     5,VV:4F
	goto 3120
	goto 3123
30C2:
	HL = [0x9849];
	EA = 0x006C;
	74 FF              DEQ     EA,HL
	goto 3126
30CD:
	one_short_beep(); /* always returns 0 */
	if (!sw_form_feed())
		return 0;
	goto 30CD

30D1:
	EA = 0x0000;
	HL = [0x984B];
	74 FF              DEQ     EA,HL
	goto 30F9
	HL = [0x9847];
	55 4F 20           OFFIW   VV:4F,$20
	HL = [0x9843];
	EA = 0xFFFC;
	74 FF              DEQ     EA,HL
	goto 30F3
30ED:
	one_short_beep(); /* always returns 0 */
	if (!sw_line_feed())
		return 0;
	goto 30ED
30F3:
	5D 4F              BIT     5,VV:4F
	goto 310A
	goto 310D
30F9:
	HL = [0x9849];
	EA = [0xFF94];
	74 FF              DEQ     EA,HL
	goto 3110
3104:
	one_short_beep(); /* always returns 0 */
	if (!sw_line_feed())
		return 0;
	goto 3104
310A:
	HL = 0x9847;
310D:
	HL = 0x9843;
3110:
	HL = 0x9849;
	5F 4F              BIT     7,VV:4F
	VV[0x13] |= 0x08
	EA = [HL];
	EA--;
	EA--;
	BC = 0x8002;
	goto 3130
3120:
	HL = 0x9847;
3123:
	HL = 0x9843;
3126:
	HL = 0x9849;
	EA = [HL];
	EA++;
	EA++;
	BC = 0x0002;
3130:
	[HL] = EA;
	push(EA);
	func_313F(); /* always returns 0 */
	EA = pop();
	HL = 0x0000;
	74 FF              DEQ     EA,HL
	return 0;
	one_short_beep(); /* always returns 0 */
	wait_for_button(); /* always returns 0 */
	return 0;

/* always returns 0 */
/* 313F */
void func_313F(void)
{
	EA = 0x7FFF;
	if (!(EA & BC))
		return 0;
	disable_interrupts();
	if (!(VV[0x01] & 0x80) && !(B & 0x80) && !(VV[0x01] & 0x22) && (VV[0x01] & 0x10) && (VV[0x01] & 0x08)) {
		HL = 0x990F;
		EA = [HL];
		EA += BC;
		[HL] = EA;
	} else {
		enable_interrupts();
		push(BC);
		do {
			func_2089(); /* always returns 0 */
		} while ((VV[0x0f] & 0x02) || (VV[0x01] & 0x30));
		func_31B0(); /* always returns 0 */
		BC = pop();
		VV[0x01] |= 0x90
		if (!(B & 0x80))
			VV[0x01] &= 0x7F;
		B &= 0x7f;
		[0x990f] = BC;
		EA = 0x000A;
		if (EA >= BC) {
			VV[0x01] &= 0xB5; /* 1011 1100 */
			A = 0x02;
		} else {
			VV[0x01] |= 0x48; /* 0100 1000 */
			A = 0x0B;
		}
		VV[0x27] = A;
		PC  |= 0x04; /* 0000 0100 */
		ETMM = 0x04; /* 0000 0100 */ /*  */
		disable_interrupts();
		ETM0 = ECNT + 100;
		[0x981B] = 0x31F5;
		IRR &= ~FE0; /* clear FE0 */
		MKL &= 0xdf; /* 1101 1111 */ /* activate INTE0 */
	}
	enable_interrupts();
	return 0;
}
/* always returns 0 */
/* 31B0 */
void func_31B0(void)
{
	BC = [0x984B];
	HL = 0x9843;
	if (!(VV[0x4f] & 0x20))
		HL = 0x9847;
	EA = [HL];
	EA += BC;
	BC = EA;
	if (B & 0x80) {
		func_31D0(); /* always returns 0 */
		return 0;
	}
	EA = 0x0168;
	if (!(VV[0x4f] & 0x20))
		EA = 0x01D4;
	if (EA <= BC)
		return 0;
	func_31D0(); /* always returns 0 */
	return 0;
}
/* always returns 0 */
/* 31D0 */
void func_31D0(void)
{
	if (VV[0x4f] & 0x20) func_7888(0x010D); /* always returns 0 */
	else                 func_7888(0x00D1); /* always returns 0 */
	return 0;
}
/* 31D8 */
int func_31D8(void)
{
	BC = [0x984B];
	HL = 0x9843;
	if (!(VV[0x4f] & 0x20))
		HL = 0x9847;
	BC += [HL];
	EA = 0x0168;
	if (!(VV[0x4f] & 0x20))
		EA = 0x01D4;
	if (EA > BC) return 0;
	else         return 1;
}

31F5:
	exx();
	exa();
	push(EA);
	push(VA);
	push(BC);
	push(HL);
	EA = ECNT;
	push(EA);
	5D 01              BIT     5,VV:01
	goto 3214
	enable_interrupts();
	if (!(PC & 0x04))
		goto 320B;
	PC &= 0xfb; /* 1111 1011 */
	goto 325A;
320B:
	MKL |= 0x20; /* 0010 0000 */ /* mask INTE0 */
	VV[0x01] &= 0xDF;
	EA = pop();
	goto 326A
3214:
	40 6F 32           CALL    $326F
	enable_interrupts();
	if (!sw_cn6())
		goto 322F;
	HL = [0x9929];
	74 5E 80           OFFI    H,$80
	HL = 0x7FFF;
	HL++;
	5F 01              BIT     7,VV:01
	goto 3232;
	HL--;
	HL--;
	74 5E 80           OFFI    H,$80
322F:
	HL = 0x0000;
3232:
	[0x9929] = HL;
	HL = 0x990F;
	[HL]--;
	BC = 0x0000;
	74 FD              DEQ     EA,BC
	goto 3246
	VV[0x01] |= 0x20
	VV[0x01] &= 0xED;
3246:
	5B 01              BIT     3,VV:01
	goto 3257
	BC = [0x0004];
	74 ED              DNE     EA,BC
	VV[0x01] |= 0x02
	65 27 06           NEIW    VV:27,$06
	VV[0x01] &= 0xBF;
3257:
	55 01 62           OFFIW   VV:01,$62
325A:
	30 27              DCRW    VV:27
	A = VV[0x27];
	48 25              SLL     A
	HL = 0x32A3;
	EA = [HL + A];
	HL = pop();
	EA += HL;
	ETM0 = EA;
326A:
	HL = pop();
	BC = pop();
	VA = pop();
	EA = pop();
	return; /* FROM INTERRUPT */

326F:
void func_326F(void)
{
	if (VV[0x01] & 0x80) HL = 0x3289;
	else                 HL = 0x3293;
	A = [HL+[C007]];
	[C007] = A;
	[C007] = [HL+A];
	return;
}

3289: DW: 09 05 0A 09 06 04 02 09 09 01 08 09 06 09 05 01
3269: DW: 04 09 0A 08 02 09 09 09 09 09 F4 77 F9 47 A7 0F
32A9: DW: 95 0C 0C 0B 47 0A E5 09 47 0A 0C 0B 95 0C A7 0F

/* always returns 0 */
/* 32B9 */
void func_32B9(void)
{
	while (VV[0x01] & 0x30)
		func_2089(); /* always returns 0 */
	return 0;
}
/* always returns 0 */
/* 32BF */
void func_32BF(void)
{
	func_32B9(); /* always returns 0 */
	if (sw_cn6_debounced()) [0x9929] = 0x0166;
	else                    [0x9929] = 0x0000;
	return 0;
}
/* always returns 0 */
/* 32CF */
void func_32CF(void)
{
	if (!func_2E08() || !sw_cn6_debounced()) {
		[0xC004] &= 0xBF;
		return;
	}
	if (func_32EC()) {
		[0xC004] |= 0x40;
		return;
	}
	if (!(VV[0x13] & 0xc0)) {
		[0xC004] &= 0xBF;
		return;
	}
	[0xC004] |= 0x40;
	return;
}
/* 32E5 */
int func_32E5(void)
{
	if (VV[0x4f] & 0x20)
		return 0;
	if (VV[0x02] & 0x20)
		return 1;
	return 0;
}
/* 32EC */
int func_32EC(void)
{
	if (VV[0x4f] & 0x20)
		return 1;
	if (VV[0x02] & 0x20)
		return 0;
	return 1;
}
/* always returns 0 */
/* 32F3 */
void func_32F3(void)
{
	if (!(VV[0x02] & 0x20)) HL = 0x992D;
	else                    HL = 0x984D;
	if (!(VV[0x4f] & 0x20)) HL = 0x9931;
	return 0;
}

/* FUCKING IMPORTANT THIS IS 0x3555!!! */
3301: 3555 359a 35d9 3620 3667 36a2 36d1 3722
3311: 374b 378e 3806 3882 38d1 392a 3982 39c7
3321: 3a0c 3a4f 3aca 3b1d 3b6c 3bb7 3bf6 3c2d
3331: 3c85 3d05 3d70 3db5 3dfc 3e43 3e8e 3ecd
3341: 3f38 3f45 3f68 3f99 3fe0 4029 40a3 4123
3351: 4150 4181 41b2 41f9 423c 4269 42a8 42cf
3361: 431a 4361 439c 43e3 442c 446d 44b4 44fd
3371: 4564 45ab 45f2 4619 4646 4685 46c4 4703
3381: 4748 4797 4806 484b 4898 48dd 4920 4965
3391: 49b2 49f9 4a30 4a7b 4aec 4b37 4b86 4bf5
33a1: 4c40 4c8d 4ce0 4d2f 4d70 4db3 4e1e 4e6e
33b1: 4ee9 4f60 4fd7 5016 504b 5096 50cb 50fe
33c1: 510c 5137 517c 51c5 5204 5251 5290 52d1
33d1: 531a 5361 539c 53d9 5444 547f 54c8 550d
33e1: 5554 559f 55ea 562b 566a 56a9 56f0 5768
33f1: 57e3 585a 58dc 5923 5960 5985 59c0 5a0b

3401: 5a52 3dfc 3e8e 5aa3 3d70 3555 3982 39c7
3411: 5b01 5b50 359a 5b8f 5bca 3667 3c2d 392a
3421: 3e43 3b1d 3aca 5c0d 3db5 3620 5c54 35d9
3431: 5c9b 3c85 3d05 5d1d 36d1 3ecd 38d1 5d62
3441: 5dab 5df0 5e2b 5e72 3806 378e 5eb9 5efe
3451: 374b 5f45 5f86 5fc5 6050 3722 60db 6126
3461: 6171 617f 618d 619b 61a9 61b7 61c5 61d3
3471: 61e1 61ef 61fd 620b 6219 6227 6235 6243
3481: 6251 625f 626d 627b 6289 6297 62a5 62b3
3491: 62c1 62cf 62dd 62eb 62f9 6307 6315 6323
34a1: 6331 633f 634d 635b 6369 6377 6385 6393
34b1: 63a1 63af 63bd 63cb 63d9 63e7 63f5 6403
34c1: 6411 3a4f 6456 649b 64de 6525 6576 65c1
34d1: 6604 664f 6696 66e9 6728 677f 67cd 680a
34e1: 6851 6890 68db 691e 6961 6977 698d 69d0
34f1: 36a2 6a17 6a46 6a71 6ab4 6af3 6b32 3f38
3501: 6b65 6ba0 6bdf 6c56 6cae 6d25 6d64 6db8
3511: 6e38 6e75 6eba 6f06 6f51 6f9c 6fd7 700e
3521: 7045 707c 70b3 7107 715a 71ae 71f5 7249
3531: 7294 72d9 734c 73bf 7432 74b4 7533 757a
3541: 75a5 75ec 7639 76c8 771b 774a 777d

77B1:
	stepper_vref(0x07);
	[0xc008] = 0x00;
	[0xc00b] = 0x00;
	[0xc00a] = 0xba;
	[0xc009] = 0xb5;
	[0xc008] = 0x0d;
	if (sw_cn7_debounced()) [0x991D] = 0x7B66;
	else                    [0x991D] = 0x7B76;
	stepper_vref(0x06);
	VV[0x1d] = 0x03;
	delay(25);
	do {
		func_7845(); /* always returns 0 */
	} while (VV[0x1d]--);
	stepper_vref(0x07);
	delay(75);
	VV[0x00] |= 0x80;
/* 77F7: */
	if (!sw_cn7_debounced()) {
		[0x9917] = 0x03E3;
		func_7875(); /* always returns 0 */
	}
/* 7806: */
	[0x9917] = 0x0000;
	func_7888(0x010D); /* always returns 0 */ /* DEBUG HANGS HERE */
	VV[0x00] &= 0x7f;
	[0x991D] = 0x7B76;
	stepper_vref(0x06);
	delay(6);
	VV[0x1d] = 0x14;
7823:
	func_7845(); /* always returns 0 */
	if (!sw_cn7())
		goto 782C;
	55 00 02           OFFIW   VV:00,$02
	goto 7831;
782C:
	30 1D              DCRW    VV:1D
	goto 7823
	beep_and_hang(2, 3); /* HANG, never returns */

7831:
	func_7845(); /* always returns 0 */
	func_7845(); /* always returns 0 */
	stepper_vref(0x07);
	delay(75)
	HL = 0x0003;
	[0x9917] = HL;
	return 0;

/* always returns 0 */
/* 7845 */
void func_7845(void)
{
	VV[0x00] |= 0x02;
	func_7B4D(); /* always returns 0 */
	delay(3);
	if (!sw_cn7())
		VV[0x00] &= 0xfd;
	return 0;
}

/* sets A */
/* 7851 */
int func_7851(void)
{
	A = [C008];
	HL = 0x7860;
	for (int i = 0; i < 5; i++)
		if (A == [HL++])
			return 0;
	return 1;
}

7860: DW: 0C 0D 0E 0F /* should be 5 bytes? */

/* HANG, never returns */
/* 786A */
void beep_and_hang(uint8_t repeat, uint8_t n_beeps)
{
	func_0C48(); /* always returns 0 */
	write_all_93c06(); /* always returns 0 */
	beep_x_y(repeat, n_beeps, 0);
	while(1); /* HANG */
}
/* always returns 0 */
/* 7875 */
void func_7875(void)
{
	DE = [9917];
	EA = 0x000a;
	if (DE <= EA)
		return 0;
	func_7888(0x000A); /* always returns 0 */
	return 0;
}
/* always returns 0 */
/* 7888 */
void func_7888(uint16_t val)
{
	do {
		int newval;

		if ([0x9917] == val)
			break;

		main_loop_1(); /* always returns 0 */

		if (VV[0x00] & 0x80) VV[0x1f] = 0x01;
		else                 VV[0x1f] = 0x03;

		VV[0x00] &= 0xBF; /* 1011 1111 */

		newval = val - [0x9917];
		if (newval < 0) {
			VV[0x00] |= 0x40; /* 0100 0000 */
			newval = [0x9917] - val;
		}
		if (newval < 0x001E) {
			newval = 0x001E;
			VV[0x00] ^= 0x40; /* 0100 0000 */
		}
		[0x9949] = newval;

		func_798D(); /* always returns 0 */

		if (!(VV[0x00] & 0x80))
			VV[0x00] |= 0x01;

	} while (!(VV[0x00] & 0x80));

	main_loop_1(); /* always returns 0 */
	return 0;
}

78D2:
	VV[0x00] |= 0x10
	58 00              BIT     0,VV:00
	goto 78DF
	func_7bb1();
	VV[0x00] &= 0xFE;
	goto 78E0
78DF:
	main_loop_1(); /* always returns 0 */
78E0:
	VV[0x1F] = 0x03;
	func_1F75();
	HL = 0x990B;
	DE = [0x9919];
	EA = [HL++];
	BC = [0x02B8];
	EA += BC;
	5A 00              BIT     2,VV:00
	goto 78F9
	EA -= A;
	goto 78FB
78F9:
	EA += A;
78FB:
	B = 0x18;
	48 3E              DIV     B
	[DE++] = EA;
	EA = [HL];
	BC = [0x02B8];
	EA += BC;
	5A 00              BIT     2,VV:00
	goto 790E
	EA -= A;
	goto 7910
790E:
	EA += A;
7910:
	A = 0x18;
	EA = EA / A, A = EA % A; /* simultaneously */
	77 00              EQI     A,$00
	EA++;
	[DE] = EA;
	40 FB 7B           CALL    $7BFB
	EA = DE;
	int borrow = (EA >= BC);
	EA -= BC;
	if (!borrow)
		goto 7940;
	VV[0x00] |= 0x40
	HL = 0x000F;
	int borrow = (EA >= HL);
	EA -= HL;
	if (!borrow)
		goto 7949;
	HL = 0x001E;
	75 20 03           EQIW    VV:20,$03
	74 B7              DSUBNB  EA,HL
	goto 795E
	EA = DE;
	EA -= BC;
	A = 0x0F;
	EA -= A;
	VV[0x00] &= 0xBF;
	goto 7957
7940:
	HL = 0x0010;
	EA = BC;
	EA -= DE;
	74 BF              DLT     EA,HL
	goto 7950
7949:
	EA = [0x001E];
	VV[0x00] |= 0x40
	goto 7957
7950:
	A = 0x0F;
	EA += A;
	VV[0x00] |= 0x40
7957:
	HL = 0x9949;
	[HL] = EA;
	func_798D(); /* always returns 0 */
	main_loop_1(); /* always returns 0 */
795E:
	func_1F9F();
	goto 795E
	40 FB 7B           CALL    $7BFB
	A = 0x11;
	EA = HL;
	EA -= BC;
	EA += A;
	HL = EA;
	[0x9949] = HL;
	VV[0x0F] |= 0x02
	EA = DE;
	EA -= BC;
	EA--;
	HL = EA;
	[0x994B] = HL;
	A = VV[0x20];
	VV[0x1F] = A;
	VV[0x00] &= 0xBF;
	func_798D(); /* always returns 0 */
	VV[0x00] &= 0xEF;
	ETMM = 0x04; /* 0000 0100 */ /*  */
	return 0;

/* always returns 0 */
/* 798D */
void func_798D(void)
{
	func_7BBE(); /* always returns 0 */
	if ((VV[0x00] & 0x10) && (VV[0x00] & 0x04))
		VV[0x00] ^= 0x40;
	if (VV[0x00] & 0x40) HL = 0x7B76;
	else                 HL = 0x7B66;
	[991D] = HL;
	switch (VV[0x1F]) {
	case 0: [0x991F] = 0x7C6E; break;
	case 1: [0x991F] = 0x7C7E; break;
	case 2: [0x991F] = 0x7C9C; break;
	case 3: [0x991F] = 0x7CAC; break;
	case 4: [0x991F] = 0x7CBC; break;
	}
	VV[0x0F] |= 0x90;
	func_7C1F(); /* always returns 0 */
	if (VV[0x1f] == 0x04 || VV[0x1f] == 0x01) {
		VV[0x00] |= 0x20;
		[0x9949] <<= 1;
		[0x994B] <<= 1;
		A = 0x1C;
	}
	VV[0x1D] = 0x0E;
	stepper_vref(0x05);
	TMM |= 0xe0; /* 1110 0000 */
	[0x9818] = timer1_2;
	VV[0x0F] |= 0x01
	A = 0xE6;
	TM1 = A;
	clear_interrupt(FT1);
	TMM &= 0x3f; /* 0011 1111 */
	MKL &= 0xfb; /* 1111 1011 */ /* activate INTT1 */
	return 0;
}
/* 7A04 */
void __attribute__((interrupt)) timer1_2(void)
{
	EA = ECNT;
	HL = EA;
	[0x9921] = HL;
	if (!func_7A34()) {
		func_7B4D(); /* always returns 0 */
		exx();
		exa();
		enable_interrupts();
		push(VA);
		push(EA);
		push(BC);
		push(DE);
		push(HL);
		A = VV[0x1D];
		HL = [991F];
		A = [HL+A];
		TM1 = A;
		40 C4 7A           CALL    $7AC4
		func_7A99(); /* always returns 0 */
		HL = pop();
		DE = pop();
		BC = pop();
		EA = pop();
		VA = pop();
		return; /* FROM INTERRUPT */
	}
	check_voltage(); /* either returns 0 or resets */
	exx();
	exa();
	enable_interrupts();
	return; /* FROM INTERRUPT */
}
/* 7A34 */
int func_7A34(void)
{
	if (!(VV[0x0f] & 0x41))
		return 0;
	if (!(VV[0x0f] & 0x01)) {
		if (VV[0x1e]--) {
			VV[0x0f] &= 0xbf;
			func_0BF7(); /* always returns 0 */
		}
		return 1;
	}
	VV[0x0f] &= 0xfe;
	if (!(VV[0x0f] & 0x40)) {
		stepper_vref(0x06);
		return 0;
	}
	stepper_vref(0x07);
	TM1 = 0xc0;
	VV[0x1e] = 0x0e;
	return 1;
}
/* 7A5A */
void __attribute__((interrupt)) timer1_1(void)
{
	func_7B4D(); /* always returns 0 */
	exx();
	exa();
	enable_interrupts();
	[0x9949]--;
	return; /* FROM INTERRUPT */
}
/* always returns 0 */
/* 7A6A */
void func_7A6A(void)
{
	VV[0x0F] &= 0xCF; /* 1100 1111 */
	VV[0x0F] |= 0x08; /* 0000 1000 */
	switch (VV[0x1F]) {
	case 0: [0x991F] = 0x7C6F; break;
	case 1: [0x991F] = 0x7C7F; break;
	case 2: [0x991F] = 0x7C9D; break;
	case 3: [0x991F] = 0x7CAD; break;
	case 4: [0x991F] = 0x7CBD; break;
	}
	[0x9818] = timer1_2;
	if ((VV[0x00] & 0x80) && (VV[0x00] & 0x40) && (VV[0x1d] <= 0x13))
		VV[0x1D] = 0x13;
	return 0;
}
/* always returns 0 */
/* 7A99 */
void func_7A99(void)
{
	if (VV[0x0f] & 0x69)
		return 0;
	if (!func_7B1D())
		return 0;
	if (VV[0x00] & 0x80) {
		if ((!(VV[0x00] & 0x40) && !sw_cn7()) ||
		    ( (VV[0x00] & 0x40) &&  sw_cn7()))
			func_7A6A(); /* always returns 0 */
		return 0;
	}
	if (VV[0x0f] & 0x10)
		return 0;
	if (!sw_cn7()) {
		VV[0x00] &= 0xFD;
		return 0;
	}

	if (VV[0x00] & 0x02)
		beep_and_hang(2, 3); /* HANG, never returns */

	VV[0x00] |= 0x02;

	return 0;
}

7AC4:
	if (!(VV[0x0f] & 0x18))
		return 0;
	if (!(VV[0x0f] & 0x10))
		goto 7AF7;
	if (VV[0x1f] == 0x04)
		goto 7AD4;
	if (VV[0x1f] != 0x01)
		goto 7ADA;
7AD4:
	if (VV[0x1d] == 0x0e)
		stepper_vref(0x05);
7ADA:
	30 1D              DCRW    VV:1D
	75 1D 00           EQIW    VV:1D,$00
	return 0;
	if (VV[0x1f] == 0x04)
		goto 7AE8;
	if (VV[0x1f] == 0x01) stepper_vref(0x03);
	else                  stepper_vref(0x05);
	VV[0x0F] &= 0xEF;
	if (!(VV[0x0f] & 0x20))
		return 0;
	func_7A6A(); /* always returns 0 */
	return 0;
7AF7:
	20 1D              INRW    VV:1D
	5D 00              BIT     5,VV:00
	A = 0x0F;
	A = 0x1D;
	if (VV[0x1d] != A)
		return 0;
	if ((VV[0x00] & 0x80) || !func_7851()) {
		VV[0x0F] |= 0x41
		VV[0x0F] &= 0x77;
		VV[0x00] &= 0xDF;
		return 0;
	}
	if (VV[0x1d]--)
		A = [0x7C9A];
	TM1 = A;
	return 0;

/* 7B1D */
int func_7B1D(void)
{
	[0x9949]--;

	if (VV[0x00] & 0x80) {
		if (EA == 0x0000)
			beep_and_hang(2, 3); /* HANG, never returns */
		return 1;
	}

	if (VV[0x0f] & 0x08)
		return 1;

	if (VV[0x00] & 0x20) HL = 0x001D;
	else                 HL = 0x000F;

	if (EA > HL) {
		if (!(VV[0x0f] & 0x02))
			return 1;
		[0x994B]--;
		if (EA == 0x0000)
			goto 1E8F;
		return 1;
	}

	func_7A6A(); /* always returns 0 */

	return 0;
}

/* always returns 0 */
/* 7B4D */
void func_7B4D(void)
{
	HL = [0x991D];
	A  = [C008];
	if (!(VV[0x00] & 0x20))
		[C008] = [HL + A];
	[C008] = [HL + A];
	check_voltage(); /* either returns 0 or resets */
	return 0;
}

7B66: DW: 0D 0D 0D 0D 0D 0F 0C 0D 0D 0D 0D 0E 08 05 06 0B
7B76: DW: 0D 0D 0D 0D 0D 0D 0E 0D 0C 0D 0D 0F 06 08 0B 05

/* 7B86 */
int sw_cn7_debounced(void)
{
	do {
		A = read_stable_PA();
		delay(10);
		B = read_stable_PA();
	} while (A != B);
	if (A & 0x01)
		return 0;
	return 1;
}
/* 7B95 */
int sw_cn7(void)
{
	if (read_stable_PA() & 0x01)
		return 0;
	return 1;
}

/* THIS SEEMS TO BE THE MAIN LOOP FOR NOW */
/* always returns 0 */
/* 7BA4 */
void main_loop_1(void)
{
	while (VV[0x0f] & 0xc0) {
		if (VV[0x00] & 0x10)
			func_1F9F(); /* ignore rets, there's a nop after this */
		func_2089(); /* always returns 0 */
	}
}
/* always returns 0 */
/* 7BB1 */
void func_7bb1(void)
{
	while (VV[0x0f] & 0xc0 || VV[0x01] & 0x30) {
		if (VV[0x00] & 0x10)
			func_1F9F(); /* ignore rets, there's a nop after this */
		func_2089(); /* always returns 0 */
	}
}
/* always returns 0 */
/* 7BBE */
void func_7BBE(void)
{
	while (1) {
		main_loop_1(); /* always returns 0 */
		if (!(VV[0x0f] & 0x02))
			return 0;
		if (!(VV[0x01] & 0x10) && !(PC & 0x04))
			break;
		func_1F9F(); /* ignore rets, there's a nop after this */
		func_2089(); /* always returns 0 */
	}
	disable_interrupts();
	if (VV[0x01] & 0x20) {
		MKL |= 0x20; /* 0010 0000 */ /* mask INTE0 */
		VV[0x01] &= 0xDF;
	}
	enable_interrupts();
	return 0;
}

7BD5:
	VV[0x00] &= 0xFB;
	55 00 08           OFFIW   VV:00,$08
	return 0;
	HL = 0x990B;
	EA = [HL++];
	BC = EA;
	EA = [HL];
	DE = EA;
	EA += BC;
	48 A0              DSLR    EA
	A = 0x18;
	EA = EA / A, A = EA % A; /* simultaneously */
	A = 0x1D;
	EA += A;
	HL = [0x9917];
	74 B7              DSUBNB  EA,HL
	VV[0x00] |= 0x04
	return 0;

7BFB:
	HL = 0x9917;
	EA = [HL++];
	BC = EA;
	EA = [HL++];
	DE = EA;
	EA = [HL];
	HL = EA;
	5A 00              BIT     2,VV:00
	return 0;
	EA = 0x0363;
	EA -= BC;
	BC = EA;
	EA = 0x0363;
	EA -= HL;
	push(EA);
	EA = 0x0363;
	EA -= DE;
	HL = EA;
	EA = pop();
	DE = EA;
	return 0;

/* always returns 0 */
/* 7C1F */
void func_7C1F(void)
{
	uint16_t val;
	if (!(VV[0x00] & 0x40)) {
		val = [0x9917] + [0x9949];
		if (val <= 0x01F4) {
			[0x9917] = val;
			return 0;
		}
		[0x9949] = 0x0213 - val + [0x9949];
		[0x9917] = 0x0213;
		return 0;
	}
	val = [0x9917] - [0x9949];
	if (val >= 0x0029) {
		[0x9917] = val;
		return 0;
	}
	[0x9949] = - 0x000A + val + [0x9949];
	[0x9917] =   0x000A;
	return 0;
}

void stepper_vref(int v)
{
	/* v from 0 to 7 */
	PA = v << 3;
	return;
}

7c6e  2b 2b 2b 2c 2d 2e 30 32  35 39 3f 47 52 62 8a e6  |+++,-.0259?GRb..|
7c7e  2b 2b 2b 2b 2b 2b 2b 2b  2b 2b 2b 2c 2c 2d 2e 2f  |+++++++++++,,-./|
7c8e  30 31 32 35 37 3a 3d 41  45 4d 59 6c 87 e6 1b 1b  |01257:=AEMYl....|
7c9e  1b 1c 1d 1f 21 23 26 2a  2f 35 3d 49 60 e6 20 20  |....!#&*/5=I`.  |
7cae  20 21 22 23 24 26 29 2d  31 38 40 4a 60 e6 20 20  | !"#$&)-18@J`.  |
7cbe  20 20 20 20 20 21 21 21  21 22 22 23 23 24 25 26  |     !!!!""##$%&|
7cce  27 28 2a 2d 30 35 3b 46  52 67 87 e6 8e 77 00     |'(*-05;FRg...w. |

7CDB:
	77 00              EQI     A,$00
	return 0;
	8E                 CALT    ($009C)
	C = A;
	push(BC);
	8E                 CALT    ($009C)
	BC = pop();
	B = A;
	8E                 CALT    ($009C)
	if (A == 0x00)
		goto 7D32;
	if (A == 0x01) {
		8E                 CALT    ($009C)
		if (A != 0xfe)
			return 0;
		8E                 CALT    ($009C)
		if (A != 0x80)
			return 0;
		A = VV[DIPSW1] ^ 0xff;
		func_7D9B(); /* always returns 0 */
		A = VV[DIPSW2] ^ 0xff;
		A &= 0x0f;
		func_7D9B(); /* always returns 0 */
		func_1B05(); /* always returns 0 */
		return 0;
	}
	if (A == 0x03)
		goto 7D10;
	if (A == 0x04)
		goto 7CFA;
	return 0;
7CFA:
	func_1B05(); /* always returns 0 */
	8E                 CALT    ($009C)
	77 FB              EQI     A,$FB
	return 0;
	8E                 CALT    ($009C)
	77 02              EQI     A,$02
	return 0;
	8E                 CALT    ($009C)
	C = A;
	B = 0x80;
	40 88 2B           CALL    $2B88
	A = 0x0C;
	func_3012(); /* always returns 0 */
	return 0;
7D10:
	40 FD 16           CALL    $16FD
	8E                 CALT    ($009C)
	77 FC              EQI     A,$FC
	return 0;
	8E                 CALT    ($009C)
	77 81              EQI     A,$81
	return 0;
	8E                 CALT    ($009C)
	37 03              LTI     A,$03
	return 0;
	VV[0x06] |= 0x80;
	if (A == 0x00)
		VV[0x06] &= 0x5F;
	if (A == 0x01)
		VV[0x06] |= 0x20;
	if (A == 0x02)
		VV[0x06] &= 0xdf;
	return 0;

7D32:
	8E                 CALT    ($009C)
	if (A != 0xff)
		return 0;
	8E                 CALT    ($009C)
	if (A != 0x00)
		return 0;
	8E                 CALT    ($009C)
	37 02              LTI     A,$02
	return 0;
	if (A != 0x00)
		A = 0x02;
	5D 06              BIT     5,VV:06
	if (++A)
		EA = 0x7D7C;
	EA += A;
	HL = EA;
	A = [HL];
	[9846] = A;
	EA = 0x0D21;
	EA += A;
	HL = EA;
	EA = 0x9850;
	EA += A;
	A = [HL];
	HL = EA;
	B  = A;
	push(HL);
	push(BC);
	8E                 CALT    ($009C)
	BC = pop();
	HL = pop();
	A += B;
	3B                 STAX    (HL)
	8E                 CALT    ($009C)
	return 0;
	40 C9 15           CALL    $15C9
	40 14 15           CALL    $1514
	40 2F 15           CALL    $152F
	goto 7D78;
	40 2B 15           CALL    $152B
	40 C9 15           CALL    $15C9
7D78:
	40 D6 04           CALL    $04D6
	return 0;

7D7C: DW: 03 00 04 01 00

/* always returns 0 */
void func_7D9B(void)
{
	EA = byte_to_char(A);
	VV[PRINT_THIS_CHAR] = EAL;
	push(EA);
	40 CD 05           CALL    $05CD
	EA = pop();
	VV[PRINT_THIS_CHAR] = EAH;
	40 CD 05           CALL    $05CD
	return 0;
}
