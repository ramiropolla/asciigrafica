/* VV */
#define ADDRESS_93C06     0x42
#define CHARTABLE_FIELD_1 0x3f

0000: goto _start;                     /* reset */
0004: goto _irq0; /* IRQ 0 == NMI */
0008: 11                 EXX           /* IRQ 1 */
0009: 10                 EXA     
000A: goto 9817; /* INTFT0, INTFT1 */
0010: 00                 NOP           /* IRQ 2 */
0018: 11                 EXX           /* IRQ 3 */
0019: 10                 EXA     
001A: goto 981A;
0020: 00                 NOP           /* IRQ 4 */
0028: goto 20CE; /* IRQ 5 */

002B: void delay(C ms){}
0041: [HL]--; return;

0050: 48 29              CALB    
0052: return 1;
0053: return 0;
0060: 00                 NOP          /* IRQ 6 */

0080: 002B delay(C ms);
0082: 1057
0084: 1325
0086: 14ec
0088: 00ca
008A: 170F
008C: 16f7
008E: 0feb
0090: 0f01
0092: 10A1 { [C004] |= A; }
0094: 109B { [C004] &= A; }
0096: 1b05
0098: 1c93
009A: 2089
009C: 2116
009E: 21F3
00A0: 2e3A
00A2: 313F
00A4: 78D2
00A6: 7BA4
00A8: 7B4D
00AA: 798D
00AC: 7B95
00AE: 1680
00B0: 1B02
00B2: 0050
00B4: 242B
00B6: 28F4
00B8: 05A5 { memset(EA, 0x00, B*255+C); A = 0x00; } /* DONE */
00BA: 216F
00BC: 1334
00BE: 0041 { [HL]--; } /* DONE */

/* bitmask for bit n, 0 = 00000001, 1 = 00000010, etc */
/* always returns 0 */
uint8_t bitmask(uint8_t A)
{
	B = 0x00;
	carry = 1;
	do {
		B = (B << 1) | carry;
		carry = 0;
	} while (A--);
	A = B;
	return A;
}

00CA:
uint16_t func_00CA(uint16_t EA)
{
	BC = EA;
	EA = A * C;
	push(EA);
	EA = A * B;
	BC = pop();
	A = EAH;
	if (A != 0x00) {
		48 2B              STC     
		return 0;
	}
	A = EAL;
	EA = 0x0000;
	EAH = A;
	EA += BC;
	return 0;
}

_start:
00E0: V     = 0xff;
00E2: SP    = 0x0000;
00E7: MM    = 0x0f; /* 64k EPROM | Internal RAM Access */
00EB: PORTA = b00111000;
00EE: MA    = b11000111; /* 0 = output; 1 = input */
00F2: MB    = b11111111; /* 0 = output; 1 = input */
00F6: EOM   = b10011001; /* to set LVx, output LVx */
00F9: MCC   = b11001011; /* 0 = port mode; 1 = control mode; CO1 output, CO0 output, TI Input, RxD, TxD */
00FD: PORTC = b00000000;
0100: MC    = b00001010; /* 0 = output; 1 = input */
0102: B = 0x02;

0104: reread:

ANM = 0x08; /* scan mode, AN4 - AN7, more than 9MHz */

/* SKIT = skip next instruction if interrupt is set, clear interrupt */
/* INTFAD = last four conversion results for registers CR0-CR3 is complete */
010A: /* wait for 0x100 AD conversions */

/* wait for input voltage to be above 24V (Epson LX-800 Technical Manual.pdf, page 44) */

0111: A     = CR1;
if (B & 0x02) {
	if (0xCA <= A)
		B = 0xfd;
	goto reread;
}

if (0xCA > A || NMI)
	reset();

[0xC004] = 0x81;

memset(0xff00, 0xFF, 0x100);
memset(0xff00, 0x00, 0x100);
if ([0xffff] != 0x00)
	beep_endlessly(); /* HANG */

0149: reset_ram(0xff);
014C: reset_ram(0x00);

[9841] = 0x01;
SP = 0xa000; /* set stack pointer now that we know the ram is ok */
VV  = 0x98xx;
VV' = 0x98xx;
clear_interrupt(F2); /* ONLINE BUTTON */
EI(); /* enable interrupts */
read_dip_to_ram();
MB  = b11111101; /* 0 = output; 1 = input */ /* 93c06.DI = input */
0167: 40 64 0C           CALL    $0C64
016A: A = 0x54;
[9817] = 0x54; /* JMP instruction */
[981a] = 0x54; /* JMP instruction */
0174: 40 F7 0B           CALL    $0BF7
VV[0x41] &= 0xfe;
017A: 40 CC 02           CALL    $02CC
017D: 40 33 20           CALL    $2033
0180: 40 23 20           CALL    $2023
0183: 40 13 23           CALL    $2313
VV[0x4f] &= 0xf7;
VV[0x4f] |= 0x40;
018C: 40 B1 77           CALL    $77B1
018F: 40 FA 2A           CALL    $2AFA
0192: 40 A0 19           CALL    $19A0
0195: 9D                 CALT    ($00BA)
0196: 5B 4F              BIT     3,VV:4F
0198: HL = 2D00;
019B: HL = 4C80;
019E: [993D] = HL;
01A2: 40 5A 2B           CALL    $2B5A
01A5: 40 A8 10           CALL    $10A8
01A8: 40 33 02           CALL    $0233
01AB: 55 14 20           OFFIW   VV:14,$20
01AE: goto 01C4;
01AF: 40 5B 0F           CALL    $0F5B
01B2: 55 03 02           OFFIW   VV:03,$02
	goto 0350;
	55 03 04           OFFIW   VV:03,$04
	goto 0392;
	55 14 04           OFFIW   VV:14,$04
	goto 043E;
01C4:
	40 CF 01           CALL    $01CF
	40 38 13           CALL    $1338
	goto 01C4;
	40 CD 05           CALL    $05CD
	goto 01C4;
01CF:
	40 A2 0E           CALL    $0EA2
	func_2089(); /* always returns 0 */
	40 27 21           CALL    $2127
	goto 01CF;
	return 0;

void read_dip_to_ram()
{
	uint16_t dip;
	do {
		dip = read_dip();
	} while (dip != read_dip());
	if (!(SW2 & 0x80))
		VV[0x11] |= 0x80;
	[9831] = SW1;
	[9832] = SW2 & 0x7f;
}

/* C = SW1, B = SW2 */
uint16_t read_dip(void)
{
	C = PB; /* DIP SW1 */
	B = 0;
	wait_for_ADC(0x00); /* scan mode, AN0 - AN3, more than 9MHz */
	if (CR0 & 0x80)	B |= 0x01;	/* DIP SW2.1 */
	if (CR1 & 0x80)	B |= 0x02;	/* DIP SW2.2 */
	if (CR2 & 0x80)	B |= 0x04;	/* DIP SW2.3 */
	if (CR3 & 0x80)	B |= 0x08;	/* DIP SW2.4 */
	wait_for_ADC(0x08); /* scan mode, AN4 - AN7, more than 9MHz */
	if (CR0 & 0x80)	B |= 0x10; /* bar{SLCT IN} */
	if (CR3 & 0x80)	B |= 0x80; /* don't know */
}

void wait_for_ADC(uint8_t A)
{
	ANM = A;
	while (!(IIR & FAD));
	return 0;
}

0233:
	A = VV[0x31];
	if (!(A & 0x01)) {
		push(VA);
		40 10 15           CALL    $1510
		VA = pop();
	}
	if (!(A & 0x02))
		VV[0x04] |= 0x40;
	47 08              ONI     A,$08
	goto 024E
	if (A & 0x04) HL = 0x0948;
	else          HL = 0x0A20;
	goto 0256;
024E:
	if (A & 0x04) HL = 0x072C;
	else          HL = 0x09D8;
0256: [0x992D] = HL;
025A: [0x9931] = HL;
025E: 57 10              OFFI    A,$10
0260: goto 0277
VV[0x04] |= 0x30;
if (A & 0x80)	VV[0x04] |= 0x01;
if (A & 0x40)	VV[0x04] |= 0x02;
if (A & 0x20)	VV[0x04] |= 0x04;
0273: VV[0x0C] = 0x00;
0276: goto 0289
0277: VV[0x04] &= 0xf8;
if (A & 0x80)	VV[0x0c] |= 0x01;
if (A & 0x40)	VV[0x0c] |= 0x02;
if (A & 0x20)	VV[0x0c] |= 0x04;
0289: A = VV[0x32];
if (!(A & 0x01))	VV[0x14] |= 0x01;
VV[0x02] &= 0xdf;
if (!(A & 0x02))	VV[0x02] |= 0x20;
0298: EA = HL;
0299: B = 0x00;
if (!(A & 0x04))	B = 0xD8;
029F: 70 62              ESUB    EA,B
02A1: HL = EA;
02A2: [0x992F] = HL;
if (!(A & 0x08))	VV[0x02] |= 0x80;
02AB: 57 10              OFFI    A,$10
VV[0x02] |= 0x0c;
02B0: A = 0x10;
02B2: 70 79 06 98        MOV     ($9806),A
02B6: 55 4F 04           OFFIW   VV:4F,$04
02B9: 40 F8 14           CALL    $14F8
02BC: 40 2B 15           CALL    $152B
02BF: 58 4F              BIT     0,VV:4F
02C1: 40 2F 15           CALL    $152F
02C4: 59 4F              BIT     1,VV:4F
02C6: goto 15CD;
02C9: goto 15C9;
02CC: 40 E4 0F           CALL    $0FE4
02CF: goto 02E1
02D0: 87                 CALT    ($008E)
02D1: goto 02D7
VV[0x03] |= 0x04;
02D5: goto 0307
02D7: 40 F2 0F           CALL    $0FF2
02DA: goto 02FE
02DC: 40 09 03           CALL    $0309
02DF: goto 0307
02E1: 87                 CALT    ($008E)
02E2: goto 02F2
02E3: 40 F2 0F           CALL    $0FF2
02E6: goto 02ED
02E7: func_0CE9();
02EA: goto 1026;
02ED: VV[0x4F] |= 0x01;
02F0: goto 0301
02F2: 40 F2 0F           CALL    $0FF2
	return 0;
	40 26 10           CALL    $1026
	return 0;
	40 26 10           CALL    $1026
	return 0;
	VV[0x4f] &= 0xfe;
0301: VV[0x03] |= 0x02;
0304: VV[0x11] |= 0x40;
0307: 81                 CALT    ($0082)
0308: return 0;
0309: func_1054();
030C: 40 26 10           CALL    $1026
030F: EA = 0000;
0312: push(EA);
0313: EA = pop();
0314: 40 48 03           CALL    $0348
0317: return 0;
0318: push(EA);
0319: 87                 CALT    ($008E)
031A: goto 0313
031B: 81                 CALT    ($0082)
031C: 40 26 10           CALL    $1026
031F: EA = pop();
0320: 40 48 03           CALL    $0348
0323: return 0;
0324: push(EA);
0325: 40 E4 0F           CALL    $0FE4
0328: goto 031F
0329: 81                 CALT    ($0082)
032A: 40 26 10           CALL    $1026
032D: EA = pop();
032E: 40 48 03           CALL    $0348
0331: return 0;
0332: push(EA);
0333: 40 F2 0F           CALL    $0FF2
0336: goto 032D
0337: 81                 CALT    ($0082)
0338: 40 26 10           CALL    $1026
033B: EA = pop();
033C: 40 48 03           CALL    $0348
033F: return 0;
0340: push(EA);
0341: 87                 CALT    ($008E)
0342: goto 033B
0343: EA = pop();
0344: VV[0x14] |= 0x04
0347: return 0;
0348: EA++;
0349: DE = 0xFF00;
034C: 74 FE              DEQ     EA,DE
034E: return 1;
034F: return 0;

0350: 40 B9 0D           CALL    $0DB9
0353: HL = 038B;
0356: 40 F4 08           CALL    $08F4
0359: 40 82 2B           CALL    $2B82
035C: 40 26 10           CALL    $1026
035F: 40 0A 09           CALL    $090A
0362: A = 0x20;
0364: VV[0x28] = A;
0366: push(VA);
0367: 40 A2 0E           CALL    $0EA2
036A: VA = pop();
036B: VV[0x16] = A;
036D: VV[0x15] = A;
036F: 40 E4 05           CALL    $05E4
0372: 40 B1 08           CALL    $08B1
0375: goto 0377
0376: goto 0381
0377: 86                 CALT    ($008C)
0378: A = VV[0x28];
037A: 40 34 04           CALL    $0434
037D: VV[0x28] = A;
037F: goto 0366
0381: 40 1B 22           CALL    $221B
0384: A = VV[0x16];
0386: 40 34 04           CALL    $0434
0389: goto 0366
038B: 50                 EXH     
038C: 53                 DCR     C
038D: HL++;
038E: HL = 3431;
0391: 00                 NOP     

0392: 40 2F 15           CALL    $152F
0395: 40 FC 14           CALL    $14FC
0398: HL = 0403;
039B: 40 F4 08           CALL    $08F4
039E: 40 82 2B           CALL    $2B82
03A1: 40 26 10           CALL    $1026
03A4: BC = 0000;
03A7: push(BC);
03A8: clear_80_spaces(); /* always returns 0 */
03AB: BC = pop();
03AC: push(BC);
03AD: 40 CF 01           CALL    $01CF
03B0: BC = pop();
03B1: EA = [0x000F];
03B4: EA &= BC;
03B6: DE = EA;
03B7: EA = [0xFF06];
03BA: EA += DE;
03BC: EA += DE;
03BE: EA += DE;
03C0: DE = EA;
03C1: push(VA);
03C2: 40 20 04           CALL    $0420
03C5: VA = pop();
03C6: EA = [0x000F];
03C9: EA &= BC;
03CB: DE = EA;
03CC: EA = [0xFF37];
03CF: EA += DE;
03D1: DE = EA;
03D2: push(BC);
03D3: B = A;
03D4: 74 0A 7F           ANI     B,$7F
03D7: 74 3A 20           LTI     B,$20
03DA: 74 6A 7F           NEI     B,$7F
03DD: A = 0x2e;
03DF: [DE] = A;
03E0: BC = pop();
03E1: 55 03 01           OFFIW   VV:03,$01
03E4: goto 03F3
03E5: DE = 0xFF00;
03E8: A = B;
03E9: 40 20 04           CALL    $0420
03EC: A = C;
03ED: 40 20 04           CALL    $0420
03F0: VV[0x03] |= 0x01
03F3: 12                 INX     BC
03F4: 74 5B 0F           OFFI    C,$0F
03F7: goto 03AC
03F9: push(BC);
03FA: HL = 0xFF00;
03FD: 40 F4 08           CALL    $08F4
0400: BC = pop();
0401: goto 03A7

0403: DW: 44 61 74 61 20 44 75 6D 70 20 4D 6F 64 65 00
          "Data Dump Mode"

0412: HL = 0xFF00;
0415: func_08FE();
0418: clear_80_spaces(); /* always returns 0 */
041B: 8B                 CALT    ($0096)
041C: 40 07 17           CALL    $1707
041F: return 1;
0420: 70 79 89 FF        MOV     ($FF89),A
0424: 40 27 04           CALL    $0427
0427: HL = 0xFF89;
042A: A = 0x30;
042C: 48 38              RLD     
042E: 37 3A              LTI     A,$3A
0430: A += 0x07;
0432: [DE++] = A;
0433: return 0;
0434: 41                 INR     A
0435: 67 7F              NEI     A,$7F
0437: A = 0xA0;
0439: 67 FF              NEI     A,$FF
043B: A = 0x20;
043D: return 0;
043E: func_1054();
0441: 40 D8 31           CALL    $31D8
0444: 40 CC 04           CALL    $04CC
0447: 40 2B 15           CALL    $152B
044A: 40 C9 15           CALL    $15C9
044D: 40 FC 14           CALL    $14FC
0450: 40 14 15           CALL    $1514
0453: VV[0x46] = 0x04;
0456: goto 046F
0457: 65 46 02           NEIW    VV:46,$02
045A: VV[0x46] = 0x01;
045D: 65 46 01           NEIW    VV:46,$01
0460: goto 0465
0461: 40 2F 15           CALL    $152F
0464: goto 046B
0465: 40 2B 15           CALL    $152B
0468: 40 C9 15           CALL    $15C9
046B: BC = [0x8288];
046E: 91                 CALT    ($00A2)
046F: 40 D6 04           CALL    $04D6
0472: BC = [0x0288];
0475: 91                 CALT    ($00A2)
0476: 48 64              SKNIT   F2 /* ONLINE BUTTON */
0478: goto 0487
0479: 40 F2 0F           CALL    $0FF2
047C: goto 047E
047D: goto 049A
047E: 40 E4 0F           CALL    $0FE4
0481: goto 0484
0482: goto 04A9
0484: 87                 CALT    ($008E)
0485: goto 0476
0486: goto 046B
0487: 40 26 10           CALL    $1026
048A: 30 46              DCRW    VV:46
048C: goto 0457
VV[0x14] &= 0xfb;
0491: 40 48 0C           CALL    $0C48
0494: 40 9A 0C           CALL    $0C9A
0497: goto 0000;
049A: 81                 CALT    ($0082)
049B: 40 26 10           CALL    $1026
049E: 40 B8 04           CALL    $04B8
04A1: 37 FF              LTI     A,$FF
04A3: goto 0476
04A5: 41                 INR     A
04A6: 3B                 STAX    (HL)
04A7: goto 0476
04A9: 81                 CALT    ($0082)
04AA: 40 26 10           CALL    $1026
04AD: 40 B8 04           CALL    $04B8
04B0: 27 00              GTI     A,$00
04B2: goto 0476
04B4: 51                 DCR     A
04B5: 3B                 STAX    (HL)
04B6: goto 0476
04B8: A = VV[0x46];
04BA: EA = [0x9850];
04BD: EA += A;
04BF: HL = EA;
04C0: A = [HL];
04C1: return 0;

04CC:
	EA -= BC;
	BC = EA;
	40 88 2B           CALL    $2B88
	40 B9 32           CALL    $32B9
	return 0;

04D6:
	VV[0x2C] = 0x24;
	if (VV[0x46] == 0x04) goto 04F2;
	if (VV[0x46] == 0x03) goto 04EF;
	if (VV[0x46] == 0x01) goto 04EC;
	if (VV[0x46] != 0x00) return 0;
	HL = 0x058A;
04EC:
	HL = 0x0578;
04EF:
	HL = 0x0565;
04F2:
	HL = 0x0553;
	40 9C 05           CALL    $059C
	A = [0x0D21[VV[0x46]]];
	B = A;
	40 B8 04           CALL    $04B8
	60 B2              SUBNB   A,B
	int borrow = (A >= B);
	A -= B;
	if (!borrow)
		goto 0503;
	goto 0511
0503:
	48 3A              NEGA    
	67 00              NEI     A,$00
	goto 0511
	push(VA);
	VV[0x15] = '-';
	40 CD 05           CALL    $05CD
	VA = pop();
0511:
	40 59 0E           CALL    $0E59
0514: A = EAL;
0515: VV[0x15] = A;
0517: push(EA);
0518: 40 CD 05           CALL    $05CD
051B: EA = pop();
051C: A = EAH;
051D: VV[0x15] = A;
051F: 40 CD 05           CALL    $05CD
0522: A = 0x48;
0524: VV[0x15] = A;
0526: 40 CD 05           CALL    $05CD
0529: 40 4C 05           CALL    $054C
052C: 86                 CALT    ($008C)
052D: VV[0x2C] = 0x15;
0530: VV[0x45] = 0x03;
0533: VV[0x15] = 0x48;
0536: 40 E4 05           CALL    $05E4
0539: 40 B1 08           CALL    $08B1
053C: goto 0541
053D: 40 1B 22           CALL    $221B
0540: goto 0533
0541: 40 4C 05           CALL    $054C
0544: 86                 CALT    ($008C)
0545: 30 45              DCRW    VV:45
0547: goto 0533
0548: VV[0x2C] = 0x24;
	return 0;

054C:
	25 46 02           GTIW    VV:46,$02
	VV[0x06] &= 0xef;
	return 0;

0553: DW: 4E 4C 51 20 20 20 48 20 2F 41 64 6A 75 73 74 3D 20 00
          "NLQ   H /Adjust= "
0565: DW: 44 72 61 66 74 20 48 20 2F 41 64 6A 75 73 74 3D 20 00 00
          "Draft H /Adjust= "
0578: DW: 4E 4C 51 20 20 20 4C 20 2F 41 64 6A 75 73 74 3D 20 00
          "NLQ   L /Adjust= "
058A: DW: 44 72 61 66 74 20 4C 20 2F 41 64 6A 75 73 74 3D 20 00
          "Draft L /Adjust= "

059C:
	push(HL);
	40 A5 0E           CALL    $0EA5
	HL = pop();
	func_08FE();
	return 0;
05A5: A = 0x00;

05A7: memset(EA, A, B*255+C); A = A;

void reset_ram(uint8_t c)
{
	uint8_t last;
	memset(0x9800, c, 0x2000);
	A = [0xb800];
	if (A != C) {
		0C48();
		1044();
		/* HANG */
	}
	return;
}

/* IMPORTANT looks like function to print char */
05CD:
{
	do {
		A = VV[0x15];
		push(VA);
		40 E4 05           CALL    $05E4
		40 B1 08           CALL    $08B1
		goto 05DC
		VA = pop();
		40 1B 22           CALL    $221B
		return 0;
05DC:
		86                 CALT    ($008C)
		VA = pop();
		VV[0x15] = A;
	} while (!(VV[0x05] & 0x01));
	return 0;
}

05E4:
	VV[0x08] &= 0x8c;
	VV[0x08] |= VV[0x0a] & 0x73;
	VV[0x09] &= 0x26;
	VV[0x09] |= VV[0x0b] & 0xd9;
	VV[0x07] &= 0xef;
	if (!(VV[0x09] & 0x02))
		goto 060E;
	if (!(VV[0x09] & 0x80))
		goto 0611;
	5A 08              BIT     2,VV:08
	55 09 40           OFFIW   VV:09,$40
	VV[0x06] &= 0xef;
	goto 0611
060E:
	55 09 40           OFFIW   VV:09,$40
0611:
	VV[0x08] |= 0x20;
	40 D6 1A           CALL    $1AD6
	goto 0620;
	VV[0x08] |= 0x02
	VV[0x06] &= 0xef
	goto 06C6;
0620:
	40 32 06           CALL    $0632
	5C 07              BIT     4,VV:07
	40 F7 07           CALL    $07F7
0628:
	5E 04              BIT     6,VV:04
	return 0;
	if (VV[0x15] == 0x30)
		VV[0x15] = 0x7F;
	return 0;
0632:
	B = VV[0x04];
	A = VV[0x15];
	if (A == 0x5f) /* '_' */
		VV[0x09] |= 0x08;
	if (!(A & 0x80))
		return 0;
	if (!(VV[0x04] & 0x20))
		goto 0665;
	B &= 0x07; /* 0000 0111 */
	74 2A 04           GTI     B,$04
	74 6A 00           NEI     B,$00
	goto 0676
	HL = 0x065D;
	48 26              SLL     B
	B -= 0x02;
	EA = [HL + B];
	BC = EA;
	48 29              CALB    
	return 0;
	goto 0676
#if 0
065D:
	A = EAH;
	07 12              ANI     A,$12
	07 1C              ANI     A,$1C
	07 26              ANI     A,$26
	07 47              ANI     A,$47
	80                 CALT    ($0080)
	goto 066E
	VV[0x09] |= 0x80;
	VV[0x15] &= 0x7f;
066E:
	A = VV[0x15];
	67 5F              NEI     A,$5F
	VV[0x09] |= 0x08;
	return 0;
#else
065D: 0708
065F: 0712
0661: 071c
0663: 0726

065E: 07 12
0660: 07 1C
0662: 07 26
0664: 07 47
0666: 80
0667: C6
0668: 15 09 80
066B: 05 15 7F
066E: 01 15
0670: 67 5F
0672: 15 09 08
0675: B8
#endif
0676:
	27 AF              GTI     A,$AF
	return 0;
	37 E0              LTI     A,$E0
	goto 069F;
	VV[0x06] &= 0xef;
	55 0A 20           OFFIW   VV:0A,$20
	goto 068F
	55 09 02           OFFIW   VV:09,$02
	goto 068F
	55 09 40           OFFIW   VV:09,$40
	VV[0x08] &= 0xDF;
068F:
	VV[0x08] &= 0xEF;
	VV[0x09] &= 0x3F;
	HL = 0x0628;
	A = [HL+A];
	74 98 09           ORAW    VV:09
	VV[0x09] = A;
	return 0;
069F:
	77 F4              EQI     A,$F4
	67 F5              NEI     A,$F5
	goto 06AA
	67 FF              NEI     A,$FF
	VV[0x15] = 0x20;
	return 0;
06AA:
	55 0A 20           OFFIW   VV:0A,$20
	goto 06B8
	55 09 02           OFFIW   VV:09,$02
	goto 06B8
	55 09 40           OFFIW   VV:09,$40
	VV[0x08] &= 0xdf;
06B8:
	67 F4              NEI     A,$F4
	VV[0x09] |= 0x10;
	VV[0x08] &= 0xef;
	VV[0x09] &= 0x3f;
	VV[0x06] &= 0xef
06C6:
	5E 07              BIT     6,VV:07
	return;
	55 11 20           OFFIW   VV:11,$20
	VV[0x07] &= 0xbf; /* 1011 1111 */
	return;

06D0: VV[0x06] &= 0xef; /* 1110 1111 */
	return;
	VV[0x06] |= 0x10; /* 0001 0000 */
	return;

06D8: 10                 EXA     
06D9: 10                 EXA     
06DA: 10                 EXA     
06DB: 10                 EXA     
06DC: 10                 EXA     
06DD: 10                 EXA     
06DE: 10                 EXA     
06DF: 10                 EXA     
06E0: 10                 EXA     
06E1: 10                 EXA     
06E2: 10                 EXA     
06E3: 10                 EXA     
06E4: 00                 NOP     
06E5: 00                 NOP     
06E6: 00                 NOP     
06E7: 10                 EXA     
06E8: A = EAH;
06E9: A = EAH;
06EA: EAH = A;
06EB: EAH = A;
06EC: A = EAH;
06ED: EAH = A;
06EE: EAH = A;
06EF: EAH = A;
06F0: A = EAH;
06F1: EAH = A;
06F2: A = EAH;
06F3: EAH = A;
06F4: EAH = A;
06F5: A = EAH;
06F6: EAH = A;
06F7: A = EAH;
06F8: A = EAH;
06F9: EAH = A;
06FA: EAH = A;
06FB: A = EAH;
06FC: A = EAH;
06FD: EAH = A;
06FE: EAH = A;
06FF: EAH = A;
0700: EAH = A;
0701: 00                 NOP     
0702: EAH = A;
0703: EAH = A;
0704: EAH = A;
0705: 10                 EXA     
0706: EAH = A;
0707: A = EAH;

0708: HL = 0x0749;
070B: B = 0x2E;
070D: C = 0x00;
070F: D = 0x09;
0711: goto 0730;
0712: HL = 0x07A7;
0715: B = 0x0F;
0717: C = 0x00;
0719: D = 0x01;
071B: goto 0730;
071C: HL = 0x07C7;
071F: B = 0x14;
0721: C = 0x00;
0723: D = 0x05;
0725: goto 0730;
0726: HL = 0x07F1;
0729: B = 0x02;
072B: C = 0x00;
072D: D = 0x04;
072F: goto 0730;
0730:
	43                 INR     C
	HL++;
	if (EA == [HL++])
		goto 0738;
	52                 DCR     B
	goto 0730;
	return 1;
0738:
	HL--;
	HL--;
	A = [HL];
	VV[0x15] = A;
	A = D;
	60 AB              GTA     A,C
0740:
	goto 0745
	VV[0x07] |= 0x10;
	return 0;
0745:
	VV[0x08] |= 0x40;
	return 0;

0749: VV[0x9B] |= 0x14;
074C: 9D                 CALT    ($00BA)
074D: 9B                 CALT    ($00B6)
074E: BD                 STAX    (HL+B)
074F: 1F                 MOV     L,A
0750: BE                 STAX    (HL+EA)
0751: A = C;
0752: goto 0762
0753: 7C DD              CALF    $0CDD
0755: 10                 EXA     
0756: goto 074C
0757: 16 F9              XRI     A,$F9
0759: 80                 CALT    ($0080)
075A: 9E                 CALT    ($00BC)
075B: 81                 CALT    ($0082)
075C: A9                 DCX     EA
075D: 82                 CALT    ($0084)
075E: BC = EA;
075F: 83                 CALT    ($0086)
0760: DE = EA;
0761: 84                 CALT    ($0088)
0762: HL = EA;
0763: 85                 CALT    ($008A)
0764: return 0;
0765: 86                 CALT    ($008C)
0766: goto 076D
0767: 87                 CALT    ($008E)
0768: goto 0770
0769: 88                 CALT    ($0090)
076A: goto 077B
076B: 89                 CALT    ($0092)
076C: goto 077E
076D: 8A                 CALT    ($0094)
076E: goto 0781
076F: 8B                 CALT    ($0096)
0770: goto 0784
0771: 8C                 CALT    ($0098)
0772: goto 0787
0773: 8D                 CALT    ($009A)	func_2089(); /* always returns 0 */
0774: goto 078A
0775: 8E                 CALT    ($009C)
0776: goto 078D
0777: 8F                 CALT    ($009E)	rollover_DE_from_0x9000_to_0x8000();
0778: goto 0790
0779: 90                 CALT    ($00A0)
077A: goto 0793
077B: 91                 CALT    ($00A2)
077C: goto 079B
077D: 92                 CALT    ($00A4)
077E: goto 075F
077F: 93                 CALT    ($00A6)	func_7ba4();
0780: goto 0763
0781: 94                 CALT    ($00A8)
0782: goto 0766
0783: 95                 CALT    ($00AA)
0784: goto 0769
0785: 96                 CALT    ($00AC)
0786: goto 076C
0787: 97                 CALT    ($00AE)
0788: goto 0770
0789: 98                 CALT    ($00B0)
078A: goto 0773
078B: 99                 CALT    ($00B2)
078C: goto 0776
078D: 9A                 CALT    ($00B4)
078E: goto 0779
078F: 9B                 CALT    ($00B6)
0790: goto 077C
0791: { memset(EA, 0x00, B*255+C); A = 0x00; }
0792: goto 077F
0793: 9D                 CALT    ($00BA)
0794: goto 0782
0795: 9E                 CALT    ($00BC)
0796: goto 0785
0797: [HL]--;
0798: goto 0788
0799: VA = pop();
079A: goto 078B
079B: BC = pop();
079C: goto 078F
079D: DE = pop();
079E: goto 0792
079F: HL = pop();
07A0: goto 0795
07A1: EA = pop();
07A2: goto 079A
07A3: A5                 DMOV    EA,BC
07A4: goto 07A0
07A5: EA = DE;
07A6: goto 07A3
07A7: 86                 CALT    ($008C)
07A8: 84                 CALT    ($0088)
07A9: 82                 CALT    ($0084)
07AA: 86                 CALT    ($008C)
07AB: 8A                 CALT    ($0094)
07AC: 89                 CALT    ($0092)
07AD: 8E                 CALT    ($009C)
07AE: 8B                 CALT    ($0096)
07AF: 93                 CALT    ($00A6)	func_7ba4();
07B0: 8C                 CALT    ($0098)
07B1: 87                 CALT    ($008E)
07B2: 8E                 CALT    ($009C)
07B3: 83                 CALT    ($0086)
07B4: 8F                 CALT    ($009E)	rollover_DE_from_0x9000_to_0x8000();
07B5: 84                 CALT    ($0088)
07B6: 91                 CALT    ($00A2)
07B7: 8C                 CALT    ($0098)
07B8: 92                 CALT    ($00A4)
07B9: 95                 CALT    ($00AA)
07BA: 94                 CALT    ($00A8)
07BB: 99                 CALT    ($00B2)
07BC: 96                 CALT    ($00AC)
07BD: 91                 CALT    ($00A2)
07BE: 98                 CALT    ($00B0)
07BF: 96                 CALT    ($00AC)
07C0: 99                 CALT    ($00B2)
07C1: 9B                 CALT    ($00B6)
07C2: 9D                 CALT    ($00BA)
07C3: 92                 CALT    ($00A4)
07C4: [HL]--;
07C5: 94                 CALT    ($00A8)
07C6: A9                 DCX     EA
07C7: 10                 EXA     
07C8: 8F                 CALT    ($009E)	rollover_DE_from_0x9000_to_0x8000();
07C9: A = C;
07CA: 98                 CALT    ($00B0)
07CB: 7C A0              CALF    $0CA0
07CD: 16 A4              XRI     A,$A4
07CF: 83                 CALT    ($0086)
07D0: 84                 CALT    ($0088)
07D1: HL = pop();
07D2: 86                 CALT    ($008C)
07D3: BC = pop();
07D4: 8D                 CALT    ($009A)	func_2089(); /* always returns 0 */
07D5: 84                 CALT    ($0088)
07D6: 8E                 CALT    ($009C)
07D7: 8C                 CALT    ($0098)
07D8: 91                 CALT    ($00A2)
07D9: 8A                 CALT    ($0094)
07DA: 92                 CALT    ($00A4)
07DB: 8B                 CALT    ($0096)
07DC: 94                 CALT    ($00A8)
07DD: 90                 CALT    ($00A0)
07DE: 95                 CALT    ($00AA)
07DF: 93                 CALT    ($00A6)	func_7ba4();
07E0: 99                 CALT    ($00B2)
07E1: 9B                 CALT    ($00B6)
07E2: 9D                 CALT    ($00BA)
07E3: 9A                 CALT    ($00B4)
07E4: 9E                 CALT    ($00BC)
07E5: [HL]--;
07E6: BC = pop();
07E7: EA = pop();
07E8: A5                 DMOV    EA,BC
07E9: EA = DE;
07EA: EA = DE;
07EB: 9E                 CALT    ($00BC)
07EC: EA = HL;
07ED: 8F                 CALT    ($009E)	rollover_DE_from_0x9000_to_0x8000();
07EE: EA++;
07EF: DE = pop();
07F0: AD                 LDAX    (HL+B)
07F1: VV[0x9B] |= 0x14
07F4: 9D                 CALT    ($00BA)
07F5: A = C;
07F6: AF 01              LDAX    (HL+$01)
07F8: VV[0x47] |= 0x80
07FB: 65 0C 00           NEIW    VV:0C,$00
07FE: return 0;
07FF: HL = 0x0815;
0802: B = 0x0B;
0804: 70 ED              NEAX    (HL+)
0806: goto 080A
0807: 52                 DCR     B
0808: goto 0804
0809: return 0;
080A: HL--;
080B: A = VV[0x0C];
080D: B = 0x0C;
080F: EA = A * B;
0811: AE                 LDAX    (HL+EA)
0812: VV[0x15] = A;
0814: return 0;

0815: 23                 DCX     DE
0816: DE = [0x5B40];
0819: 5C 5D              BIT     4,VV:5D
081B: 5E 60              BIT     6,VV:60
081D: 7B 7C              CALF    $0B7C
081F: 7D 7E              CALF    $0D7E
0821: 23                 DCX     DE
0822: DE = [0x0500];
0825: 0F                 MOV     A,L
0826: 10                 EXA     
0827: 5E 60              BIT     6,VV:60
0829: 1E                 MOV     H,A
082A: 02                 INX     SP
082B: A = VV[0x16];
082D: 23                 DCX     DE
082E: DE = [0x1710];
0831: EAH = A;
0832: EAL = A;
0833: 5E 60              BIT     6,VV:60
0835: B = A;
0836: C = A;
0837: D = A
0838: 11                 EXX     
0839: 06                 illegal 

DE = 0x5B40;
5C 5D              BIT     4,VV:5D
5E 60              BIT     6,VV:60
7B 7C              CALF    $0B7C
7D 7E              CALF    $0D7E
23                 DCX     DE
DE = [0x1240];
BC = [0x5E0D];
60 13              XRA     C,A
VV[0x0E] |= 0x7E;
23                 DCX     DE
A = C;
E = A;
A |= 0x18;
A = E;
EAL = A;
1E                 MOV     H,A
B = A;
C = A;
A = H;
D = A;
23                 DCX     DE
DE = [0x0540];
5C 1E              BIT     4,VV:1E
5E 02              BIT     6,VV:02
0865: 00                 NOP     
0866: 03                 DCX     SP
0867: A = VV[0x04];
0869: A = D;
086A: DE = 0x0740;
086D: A = EAL;
086E: A = EAH;
086F: 5E 60              BIT     6,VV:60
0871: 16 0A              XRI     A,$0A
0873: 7D 7E              CALF    $0D7E	93c06.instruction(WDS);
0875: 23                 DCX     DE
0876: DE = [0x5B40];
0879: 1F                 MOV     L,A
087A: 5D 5E              BIT     5,VV:5E
087C: 60 7B              EQA     C,A
087E: 7C 7D              CALF    $0C7D
0880: 7E 23              CALF    $0E23
0882: A = C;
0883: E = A;
0884: 12                 INX     BC
0885: BC = [0x190D];
0888: 1E                 MOV     H,A
0889: 13                 DCX     BC
088A: VV[0x0E] |= 0x1C
088D: 23                 DCX     DE
088E: DE = [0x121D];
0891: BC = [0x190D];
0894: 1E                 MOV     H,A
0895: 13                 DCX     BC
0896: VV[0x0E] |= 0x1C
0899: 23                 DCX     DE
089A: DE = [0x07A0];
089D: A = EAL;
089E: A = EAH;
089F: 1E                 MOV     H,A
08A0: 60 A1              ADDNC   A,A
08A2: A = B;
DE = pop();
HL = pop();
23                 DCX     DE
DE = [0x07A0];
A = EAL;
A = EAH;
1E                 MOV     H,A
D = A
BC = pop();
A = B;
DE = pop();
HL = pop();

08B1:
	VV[0x11] &= 0xFB;
	VV[0x05] &= 0xFE;
	A = VV[0x15];
	BC = [0x9808];
	40 C9 22           CALL    $22C9
	HL = EA;
	[0x993B] = HL;
	HL = [0x9901];
	EA += HL;
	HL = [0x993d];
	74 AF              DGT     EA,HL
	return 1;
	if (!(VV[0x05] & 0x80))
		return 0;
	if (VV[0x15] == ' ') {
		VV[0x05] |= 0x01;
		return 0;
	}
	push(EA);
	HL = 0x9947;
	EA = [HL];
	48 A0              DSLR    EA
	HL = [0x993d];
	EA += HL;
	HL = EA;
	EA = pop();
	74 AF              DGT     EA,HL
	return 1;
	VV[0x11] |= 0x04
	return 0;

08F4:
	push(HL);
	40 A5 0E           CALL    $0EA5
	HL = pop();
	func_08FE();
	86                 CALT    ($008C)
	return 0;

void func_08FE(void)
{
	while (1) {
		A = [HL++];
		if (!A)
			return 0;
		VV[0x15] = A;
		push(HL);
		40 CD 05           CALL    $05CD
		HL = pop();
	}
}

090A:
	HL = 0x09D5;
	A = VV[0x31];
	[0xFF8A] = A;
	40 55 09           CALL    $0955
	40 55 09           CALL    $0955
	A = VV[0x31];
	B = A;
	B &= 0x0c;
	B >>= 2;
	40 5E 09           CALL    $095E
	5D 04              BIT     5,VV:04
	goto 0939
	A = VV[0x04];
	B = A;
	74 0A 07           ANI     B,$07
	40 5E 09           CALL    $095E
	while ([HL++] != 0x02);
	while ([HL++] != 0x02);
	goto 0945;
0939:
	while ([HL++] != 0x02);
	40 55 09           CALL    $0955
	A = VV[0x0C];
	B = A;
	40 5E 09           CALL    $095E
0945:
	A = VV[0x32];
	[0xFF8A] = A;
	40 55 09           CALL    $0955
	40 55 09           CALL    $0955
	40 55 09           CALL    $0955
	goto 0955

0955:
	A = [0xFF8A];
	B = !(A & 0x01);
	A >>= 1;
095E:
	push(BC);
	push(HL);
	clear_80_spaces(); /* always returns 0 */
	HL = pop();
	BC = pop();
	DE = 0xFF00;
	strcpy(DE, HL); /* always returns 0 */
	strskip(B); /* always returns 0 */
	DE = 0xFF14; /* 20 */
	strcpy(DE, HL); /* always returns 0 */
	while ([HL++] != 0x01);
	A = [HL];
	if (A != 0xff) {
		DE = 0xFF25; /* 40 */
		func_098E(); /* always returns 0 */
	}
	A = 0x00;
	[DE] = A;
	push(HL);
	HL = 0xFF00;
	40 F4 08           CALL    $08F4
	HL = pop();
	while ([HL++] != 0x02);
	return 0;

void func_098E(void)
{
	do {
		strcpy(DE, HL); /* always returns 0 */
		DE++;
		[DE++] = 0x4F; /* 'O' */
		A = [0xFF8A];
		EA = 0x4646; /* 'FF' */
		if (A & 0x01)
			EA = 0x204E; /* ' O' */
		A >>= 1;
		[DE++] = EA;
		[0xFF8A] = A;
		DE++;
		A = [HL];
	} while (A != 0x02);
}
/* always returns 0 */
void clear_80_spaces(void)
{
	[0xFF50] = 0x00;
	memset(0xFF00, ' ', 0x4E);
}
/* always returns 0 */
void strcpy(uint8_t *DE, uint8_t *HL)
{
	while (1) {
		A = [HL++];
		if (A == 0x00)
			return 0;
		[DE++] = A;
	}
}
/* always returns 0 */
void strskip(uint8_t B)
{
	while (1) {
		if (!B--)
			return 0;
		while ([HL++]);
	}
}

09D5: DW: 43 68 61 72 61 63 74 65 72 20 50 69 74 63 68 00
          "Character Pitch"
09E5: DW: 31 32 20 43 50 49 00
          "12 CPI"
09EC: DW: 31 32 20 43 50 49 00
          "10 CPI"
09F3: DW: 01 31 2D 31 00
             "1-1"
09F8: DW: 02 53 68 61 70 65 20 6F 66 20 5A 65 72 6F 00
             "Shape of Zero"
0A07: DW: 30 20 28 53 6C 61 73 68 65 64 29 00
          "0 (Slashed)"
0A13: DW: 30 20 28 55 6E 73 6C 61 73 68 65 64 29 00
          "0 (Unslashed)"
0A21: DW: 01 31 2D 32 00
             "1-2"
0A26: DW: 02 50 61 67 65 20 4C 65 6E 67 74 68 00
             "Page Length"
0A33: DW: 37 30 2F 36 20 69 6E 63 68 00
          "70/6 inch"
0A3D: DW: 38 2E 35 20 69 6E 63 68 00
          "8.5 inch"
0A46: DW: 31 32 20 69 6E 63 68 00
          "12 inch"
0A4E: DW: 31 31 20 69 6E 63 68 00
          "11 inch"
0A56: DW: 01 31 2D 33 00
             "1-3"
0A5B: DW: 31 2D 34 00
          "1-4"
0A5F: DW: 02 50 43 20 54 61 62 6C 65 00
             "PC Table"
0A69: DW: 55 6E 69 74 65 64 20 53 74 61 74 65 73 00
          "United States"
0A77: DW: 4D 75 6C 74 69 6C 69 6E 67 75 61 6C 00
          "Multilingual"
0A84: DW: 50 6F 72 74 75 67 61 6C 00
          "Portugal"
0A8D: DW: 43 61 6E 61 64 61 2D 46 72 65 6E 63 68 00
          "Canada-French"
0A9B: DW: 4E 6F 72 77 61 79 00
          "Norway"
0AA2: DW: 55 6E 69 74 65 64 20 53 74 61 74 65 73 00
          "United States"
0AB0: DW: 55 6E 69 74 65 64 20 53 74 61 74 65 73 00
          "United States"
0ABE: DW: 55 6E 69 74 65 64 20 53 74 61 74 65 73 00
          "United States"
0ACC: DW: 01 31 2D 35 00
             "1-5"
0AD1: DW: 31 2D 36 00
          "1-6"
0AD5: DW: 31 2D 37 00
          "1-7"
0AD9: DW: 31 2D 38 00
          "1-8"
0ADD: DW: 02 43 68 61 72 61 63 74 65 72 20 54 61 62 6C 65 00
             "Character Table"
0AEE: DW: 47 72 61 70 68 69 63 73 00
          "Graphics"
0AF7: DW: C9 F4 E1 EC E9 E3 F3 00
0AFF: DW: 01 31 2D 35 00
             "1-5"
0B04: DW: 02 43 6F 75 6E 74 72 79 00
             "Country"
0B0D: DW: 55 2E 53 2E 41 2E 00
          "U.S.A."
0B14: DW: 46 72 61 6E 63 65 00
          "France"
0B1A: DW: 47 65 72 6D 61 6E 79 00
          "Germany"
0B23: DW: 55 2E 4B 2E 00
          "U.K."
0B28: DW: 44 65 6E 6D 61 72 6B 00
          "Denmark"
0B30: DW: 53 77 65 64 65 6E 00
          "Sweden"
0B37: DW: 49 74 61 6C 79 00
          "Italy"
0B3D: DW: 53 70 61 69 6E 00
          "Spain"
0B43: DW: 01 31 2D 36 00
             "1-6"
0B48: DW: 31 2D 37 00
          "1-7"
0B4C: DW: 31 2D 38 00
          "1-8"
0B50: DW: 02 53 68 6F 72 74 20 54 65 61 72 2D 6F 66 66 00
             "Short Tear-off"
0B60: DW: 49 6E 76 61 6C 69 64 00
          "Invalid"
0B68: DW: 56 61 6C 69 64 00
          "Valid"
0B6E: DW: 01 32 2D 31 00
             "2-1"
0B73: DW: 02 43 53 46 20 4D 6F 64 65 00
             "CSF Mode"
0B7D: DW: 56 61 6C 69 64 00
          "Valid"
0B83: DW: 49 6E 76 61 6C 69 64 00
          "Invalid"
0B8B: DW: 01 32 2D 32 00
             "2-2"
0B90: DW: 02 53 6B 69 70 20 50 65 72 66 6F 72 61 74 69 6F 6E 00
             "Skip Perforation"
0BA2: DW: 31 20 69 6E 63 68 00
          "1 inch"
0BA9: DW: 4E 6F 6E 65 00
          "None"
0BAE: DW: 01 32 2D 33 00
             "2-3"
0BB3: DW: 02 41 75 74 6F 20 4C 46 00
             "Auto LF"
0BBC: DW: 56 61 6C 69 64 00
          "Valid"
0BC2: DW: 44 65 70 65 6E 64 20 6F 6E 20 49 2F 46 00
          "Depend on I/F"
0BD0: DW: 01 32 2D 34 00
             "2-4"
0BD5: DW: 02 44 72 61 66 74 20 50 72 69 6E 74 20 53 70 65 65 64 00
             "Draft Print Speed"
0BE8: DW: 4E 6F 72 6D 61 6C 00
          "Normal"
0BEF: DW: 48 69 67 68 00
          "High"

0BF4: 01 FF 02

0BF7:
	TMM |= 0xe0; /* 1110 0000 */
	             /* ff input clock source: upcounter 0 equals tm0 */
	             /* timer0: internal clock /12, count up */
	             /* timer1: upcounter0 = tm0, reset to 0 and stop counting */
	IRR &= ~INTFT1; /* clear FT1 interrupt flag */
	TM1  = 0x26;
	[9818] = 0x0c0f;
	TMM &= 0x3f; /* 0011 1111 */
	             /* timer1: count up, internal clock / 384 */
	MKL &= 0xfb; /* 1111 1011 */ /* activate INTT1 */
	return 0;

0C0F: 40 16 0C           CALL    $0C16
0C12: 11                 EXX     
0C13: 10                 EXA     
0C14: enable_interrupts();
0C15: return; /* FROM INTERRUPT */

0C16:
A = CR1;
if (VV[0x41] & 0x02) {
	if (A <= 0xb8) {
		VV[0x41] |= 0x01;
		0C48();
		0C9A();
		A = 0xC3;
		[0xC004] = 0xC3;
		reset();
	}
	VV[0x41] |= 0xfd;
	return;
}
if (A <= 0xb8)
	VV[0x41] |= 0x02;
return;

/* NMI */
void _irq0(void)
{
	if (VV != 0x98)
		reset();
	if (!(VV[0x41] & 0x01)) {
		VV[0x41] |= 0x01;
		0C48();
		0C9A();
		[0xC004] = 0xC3;
		reset();
	}
	enable_interrupts();
	return; /* FROM INTERRUPT */
}

0C48:
	MKL    = 0xff; /* mask all interrupts */
	MKH    = 0xff; /* mask all interrupts */
	[0xc005] = 0x0000; /* Latches (and inverts) the data for pin 9 of the printhead. */
	[0xc007] = 0x0000; /* Latches the phase data for the CR motor. */
	EOM   = b10011001; /* to set LVx, output LVx */
	[VV:0x0f] &= 0x3f; /* 0011 1111 */
	[VV:0x01] &= 0xcf; /* 1100 1111 */
	goto 0F9C;

0C64:
	VV[ADDRESS_93C06] = 0x00;
0C67:
	93c06.WEN();
	HL = 0x9847;
	B = 0x00;
	C = 0x07;
0C71:
	do {
		push(BC);
		93c06.READ();
		[HL++] = EA;
		BC = 0xffff;
		if (EA != BC)
			93c06.ERASE();
		if (VV[ADDRESS_93C06]++ == 0xff)
			BC = pop();
		B += EAL;
		B += EAH;
	} while (--C == 0xff);
	if (B != 0x1D) {
		if (VV[ADDRESS_93C06] <= 0x08)
			goto 0C67;
		func_0CD3();
	}
	93c06.WDS();
	return;

0C9A:
	0CBF();
	93c06.WEN();
0CA0:
	if (VV[ADDRESS_93C06] >= 0x09)
		VV[ADDRESS_93C06] = 0x00;
	HL = 0x9847;
	C = 0x07;
0CAB:
	push(BC);
	48 85              LDEAX   (HL++)
	BC = 0xffff;
	if (EA != BC)
		93c06.WRITE();
	VV[ADDRESS_93C06]++;
	if (!VV[ADDRESS_93C06]) BC = pop();
	if (!C--)
		goto 0CAB;
	93c06.WDS();
	return 0;
0CBF:
	A = 0x00;
	HL = 0x9847;
	B = 0x0e;
0CC6:
	70 C5              ADDX    (HL+)
	52                 DCR     B
	goto 0CC6
	B = 0x1d;
	60 62              SUB     B,A
	70 7A 56 98        MOV     ($9856),B
	return 0;

void func_0CD3(void)
{
	func_1054();
	93c06.WEN();
	93c06.ERAL();
	93c06.WDS();
	memcpy(0x9847, 0x0D18, 0x0e);
	return 0;
}

void func_0CE9(void)
{
	uint8_t tmp[5];

	func_1054();
	93c06.WEN();
	93c06.ERAL();
	93c06.WDS();
	memcpy(tmp, 0x9850, 5);
	memcpy(0x9847, 0x0D18, 0x0e);
	memcpy(0x9850, tmp, 5);
	return 0;
}

0D18: DW: 00 00 00 00 00 00 90 12 00 2D 1F 39 37 23 00

/* 0D27 */
uint16_t 93c06.READ(void)
{
	93c06.instruction_addr(READ);
	93c06.DI = 0;
	93c06.clock();
	EA = 0x0000;

	for (i = 0; i < 0x10; i++) {
		EA = (EA<<1) & 93c06.DO;
		93c06.clock();
	}

	return EA;
}
/* 0D52 */
void 93c06.WRITE(void)
{
	93c06.instruction_addr(WRITE);
	93c06.send(EAH);
	93c06.send(EAL);
	93c06.DI = 0;
	93c06.CS = 0;
	delay(10);
	return;
}
/* 0D67 */
void 93c06.ERASE(void)
{
	93c06.instruction_addr(ERASE);
	93c06.DI = 0;
	93c06.CS = 0;
	delay(10);
	return;
}
/* 0D6B */
void 93c06.ERAL(void)
{
	93c06.instruction(ERAL);
	93c06.DI = 0;
	93c06.CS = 0;
	delay(10);
	return;
}
/* 0D6F */
void 93c06.WEN(void)
{
	93c06.instruction(WEN);
	93c06.DI = 0;
	93c06.CS = 0;
	nop();
	return;
}
/* 0D7A */
void 93c06.WDS(void)
{
	93c06.instruction(WDS);
	93c06.DI = 0;
	93c06.CS = 0;
	nop();
	return;
}

void 93c06.instruction(instruction)
{
	93c06.DI = 0;
	93c06.CS = 1;
	93c06.clock();
	93c06.DI = 1; /* start bit */
	93c06.clock();
	93c06.send(A);
	return;
}
void 93c06.instruction_addr(instruction)
{
	A |= VV[ADDRESS_93C06];
	93c06.instruction(A);
}

void 93c06.send(uint8_t A)
{
	B = 0x80;
	do {
		93c06.DI = 0;
		if (A & B)
			93c06.DI = 1;
		93c06.clock();
		B >>= 1;
	} while (B);
	return;
}

0DB9:
	if (!func_32E5())
		return 0;
	40 47 2D           CALL    $2D47
	if (!func_32E5())
		return 0;
	clear_80_spaces(); /* always returns 0 */
	HL = 0x0E0E;
	40 F4 08           CALL    $08F4
	clear_80_spaces(); /* always returns 0 */
	40 34 0E           CALL    $0E34
	EA = [0x1290];
	HL = [0x9A77];
	EA -= HL;
	HL = 0x0142;
	EA += HL;
	HL = 0x984D;
	[HL] = EA;
	A = VV[0x2C];
	48 3D              DIV     A
	77 00              EQI     A,$00
	EA++;
	40 75 0E           CALL    $0E75
	HL = 0x0E26;
	DE = 0xFF00;
	strcpy(DE, HL); /* always returns 0 */
	A = B;
	40 45 0E           CALL    $0E45
	A = C;
	40 51 0E           CALL    $0E51
	A = '.';
	[DE] = A;
	HL = 0xFF00;
	40 F4 08           CALL    $08F4
	40 7D 2D           CALL    $2D7D
	return 0;

0E0E: DW: 54 68 69 73 20 69 73 20 74 68 65 20 66 69 72 73 74 20 6C 69 6E 65 2E 00
          "This is the first line."
0E26: DW: 54 68 69 73 20 69 73 20 6C 69 6E 65 20 00
          "This is line "

0E34:
	BC = [0x1290];
	91                 CALT    ($00A2)
	BC = [0x011E];
	40 AE 2E           CALL    $2EAE
	goto 2DAE;
	VV[0x13] &= 0xDF;
	return 0;

0E45:
	40 59 0E           CALL    $0E59
	A = EAL;
	77 30              EQI     A,$30
	[DE++] = A;
	A = EAH;
	77 30              EQI     A,$30
	[DE++] = A;
	return 0;

0E51:
	40 59 0E           CALL    $0E59
	A = EAL;
	[DE++] = A;
	A = EAH;
	[DE++] = A;
	return 0;

0E59:
	EAH = A;
	EAL = nibble_to_hex(A >>= 4);
	A = EAH;
	EAH = nibble_to_hex(A & 0x0f);
	return 0;

char nibble_to_hex(uint8_t A)
{
	if (A >= 10)
		A += 7; /* distance from numbers to letters in ASCII */
	A += '0';
	return A;
}

0E75:
	DE = [0x0000];
	A = 0x02;
0E7A:
	B = 0x0A;
0E7C: 48 3E              DIV     B
0E7E: 77 02              EQI     A,$02
0E80: goto 0E86
0E81: push(VA);
0E82: A = B;
0E83: E = A;
0E84: VA = pop();
0E85: goto 0E9C
0E86: 77 01              EQI     A,$01
0E88: goto 0E95
0E89: push(VA);
0E8A: push(EA);
0E8B: A = 0x10;
0E8D: EA = A * B;
0E8F: EA += DE;
0E91: DE = EA;
0E92: EA = pop();
0E93: VA = pop();
0E94: goto 0E9C
0E95: 77 00              EQI     A,$00
0E97: goto 0E9C
0E98: push(VA);
0E99: A = B;
0E9A: D = A;
0E9B: VA = pop();
0E9C: 51                 DCR     A
0E9D: goto 0E7A
0E9F: EA = DE;
0EA0: BC = EA;
0EA1: return 0;

0EA2:
	40 09 0F           CALL    $0F09

0EA5:
	40 4B 2E           CALL    $2E4B
	goto 0EC2
	40 0A 2F           CALL    $2F0A
	goto 2C2B;
	48 44              SKIT    F2 /* ONLINE BUTTON */
	return 0;
	5C 13              BIT     4,VV:13
	goto 0EBB
	40 EF 2F           CALL    $2FEF
	88                 CALT    ($0090)
	return 0;
0EBB:
	55 03 04           OFFIW   VV:03,$04
	40 12 04           CALL    $0412
	8B                 CALT    ($0096)
0EC2:
	40 E9 2F           CALL    $2FE9
	40 9C 0F           CALL    $0F9C
	40 08 2E           CALL    $2E08
	40 D0 31           CALL    $31D0
0ECE:
	88                 CALT    ($0090)
0ECF:
	40 37 2C           CALL    $2C37
	48 44              SKIT    F2 /* ONLINE BUTTON */
	goto 0ECF
	55 13 20           OFFIW   VV:13,$20
	goto 0EE5
	40 08 2E           CALL    $2E08
	goto 0EF3
	40 EC 32           CALL    $32EC
	90                 CALT    ($00A0)
	goto 0EE5
	5E 13              BIT     6,VV:13
	goto 0EF3
0EE5:
	40 C0 2C           CALL    $2CC0
	55 13 60           OFFIW   VV:13,$60
	goto 0ECE
	40 E5 32           CALL    $32E5
	90                 CALT    ($00A0)
	goto 0EF3
	goto 0ECE
0EF3:
	VV[0x13] &= 0xBB;
	40 70 0F           CALL    $0F70
	40 0A 2F           CALL    $2F0A
	goto 2C2B;
	88                 CALT    ($0090)
	return 0;
0F01:
	40 13 10           CALL    $1013
	goto 0F01
	48 44              SKIT    F2	/* ONLINE BUTTON */
	00                 NOP     
	return 0;
0F09:
	55 13 10           OFFIW   VV:13,$10
	return 0;
	87                 CALT    ($008E)
	goto 0F33
	55 0B 02           OFFIW   VV:0B,$02
	55 0A 01           OFFIW   VV:0A,$01
	goto 0F22
	40 51 10           CALL    $1051
	VV[0x4F] |= 0x02
	40 C9 15           CALL    $15C9
	goto 0F57
0F22:
	func_1054();
	VV[0x4F] &= 0xFD;
	40 CD 15           CALL    $15CD
	VV[0x4F] |= 0x01
	40 2B 15           CALL    $152B
	goto 0F57
0F33:
	40 E4 0F           CALL    $0FE4
	goto 0F3F;
	81                 CALT    ($0082)
	VV[0x4F] &= 0xFE;
	40 2F 15           CALL    $152F
	goto 0F57
0F3F:
	40 F2 0F           CALL    $0FF2
	goto 0F5A
	5A 0B              BIT     2,VV:0B
	goto 0F50
	func_1054();
	VV[0x4F] &= 0xFB;
	40 FC 14           CALL    $14FC
	goto 0F57
0F50:
	81                 CALT    ($0082)
	VV[0x4F] |= 0x04
	40 F8 14           CALL    $14F8
0F57:
	40 26 10           CALL    $1026
0F5A:
	return 0;
0F5B:
	90                 CALT    ($00A0)
	goto 0F70
	40 EC 32           CALL    $32EC
	40 7D 2D           CALL    $2D7D
	40 E5 32           CALL    $32E5
	55 01 04           OFFIW   VV:01,$04
	goto 0F70
	40 CF 32           CALL    $32CF
	goto 0EC2;
0F70:
	VV[0x14] |= 0x40
	[0xC004] &= 0xB3;
	55 03 02           OFFIW   VV:03,$02
	return 0;
	[0xC004] |= 0x10;
	5F 11              BIT     7,VV:11
	goto 0F8C
	55 11 40           OFFIW   VV:11,$40
	return 0;
	MKH &= 0xfd; /* 1111 1101 */
	A = 0x11;
	TXB = A;
	goto 0F99;
0F8C:
	HL = 0xC002;
	A = [HL];
	57 80              OFFI    A,$80
	return;
	[0xC004] |= 0x20;
	[0xC004] &= 0xDF;
0F99:
	goto 2305;

0F9C:
	func_2089(); /* always returns 0 */
	[VV:0x14] &= 0xBF;
	[0xC004] &= 0xEF;
	if (!(VV[0x11] & 0x40)) {
		A = 0x13;
		TXB = A;
		40 0C 23           CALL    $230C
		delay(1);
	}
	A = 0x40;
	HL = C004;
	70 CB              ONAX    (HL)
	A = 0x04;
	A = 0x0c;
	[0xC004] |= A;
	return;

uint8_t read_stable_PA(void)
{
	do {
		B = PA;
		A = PA;
	} while (A != B);
	/* returns PA in A and B */
}
0FC8: A, B = read_stable_PA();
0FCB: push(BC);
0FCC: delay(10);
0FCF: A, B = read_stable_PA();
0FD2: BC = pop();
0FD3: 60 FA              EQA     A,B
0FD5: goto 0FC8;
0FD6: return;
0FD7: A = PC;
0FD9: A &= 0x3C;
0FDB: B = A;
0FDC: A = PC;
0FDE: A &= 0x3C;
0FE0: 60 FA              EQA     A,B
0FE2: goto 0FD7;
0FE3: return 0;
0FE4: A, B = read_stable_PA();
0FE7: 47 40              ONI     A,$40
0FE9: return 1;
0FEA: return 0;
0FEB: A, B = read_stable_PA();
0FEE: 47 80              ONI     A,$80
0FF0: return 1;
0FF1: return 0;
0FF2: 4C E2              MOV     A,CR2
0FF4: 57 80              OFFI    A,$80
0FF6: return 0;
0FF7: wait_for_AD();
0FFD: 4C E2              MOV     A,CR2
0FFF: 57 80              OFFI    A,$80
1001: return 0;
1002: return 1;
1003: 40 D7 0F           CALL    $0FD7
1006: 47 08              ONI     A,$08
1008: return 1;
1009: return 0;
100A: HL = 0FEB;
100D: HL = 0FE4;
1010: HL = 0FF2;
1013: HL = 1003;
1016: EA = HL;
1017: BC = EA;
1018: push(BC);
1019: 48 29              CALB    
101B: goto 101E
101C: BC = pop();
101D: return 0;
101E: delay(10);
1021: BC = pop();
1022: 48 29              CALB    
1024: return 1;
1025: return 0;
1026: 40 0A 10           CALL    $100A
1029: goto 1026;
102A: 40 0D 10           CALL    $100D
102D: goto 1026;
102E: 40 10 10           CALL    $1010
1031: goto 1026;
1032: return;

1033: void beep_endlessly() {} /* HANG */

1044: HL = 0301;
1047: HL = 0400;
104A: HL = 0102;
104D: goto 105D
104E: HL = 0403;
1051: HL = 0002;
1054: HL = 0001;
1057: HL = 0000;
VV[0x10] |= 0x04;

105D: push(HL);
func_7bb1();
1061: HL = pop();
1062: EA = HL;
1063: BC = EA;

1064: push(BC);
do {
	beep_60ms();
	if (VV[0x10] & 0x04) delay( 30);
	else                 delay(100);
} while (--C != 0xff);
1073: BC = pop();
1074: 52                 DCR     B
1075: goto 107A
VV[10] &= 0xfb; /* 1111 1011 */ /* unset 0x04 */
1079: return 0;
107A: push(BC);
if (VV[0x10] & 0x04) delay(100);
else                 delay(200);
1082: BC = pop();
1083: goto 1064;

1084: void beep_60ms() {}

109B: HL = 0xC004;
109E: A &= [HL];
10A0: goto 10A6;
10A1: HL = 0xC004;
10A4: A |= [HL];
10A6: [HL] = A;
10A7: return;

10A8: HL = 0x9830;
10AB: A = 0x03;
10AD: 3F                 STAX    (HL-)
10AE: 51                 DCR     A
10AF: goto 10AD
10B0: return 0;
10B1: 8E                 CALT    ($009C)
10B2: HL = 0x10CD;
10B5: B = 0x03;
10B7: 70 EF              NEAX    (HL-)
10B9: goto 10BE
10BA: 52                 DCR     B
10BB: goto 10B7
10BC: 8E                 CALT    ($009C)
10BD: return 0;
10BE: push(BC);
10BF: 8E                 CALT    ($009C)
10C0: BC = pop();
10C1: A &= 0x0f;
10C3: HL = 0x982D;
10C6: 27 06              GTI     A,$06
10C8: BD                 STAX    (HL+B)
10C9: return 0;
10CA: 4B 4C              MVIX    HL,$4C
10CC: 59 5A              BIT     1,VV:5A
10CE: A = VV[0x2D];
10D0: goto 10EE
10D1: A = VV[0x2E];
10D3: goto 10EE
10D4: A = VV[0x2F];
10D6: goto 10EE
10D7: A = VV[0x30];
10D9: goto 10EE
10DA: 8E                 CALT    ($009C)
10DB: A &= 0x0f;
10DD: 37 08              LTI     A,$08
10DF: return 0;
10E0: 67 07              NEI     A,$07
10E2: goto 10EC
10E3: goto 10EE
10E4: 8E                 CALT    ($009C)
10E5: A &= 0x0f;
10E7: VV[0x12] |= 0x08
10EA: 37 02              LTI     A,$02
10EC: goto 1190
10EE: 77 02              EQI     A,$02
10F0: 67 03              NEI     A,$03
10F2: VV[0x12] |= 0x04
10F5: 67 05              NEI     A,$05
10F7: VV[0x12] |= 0x60
10FA: 67 06              NEI     A,$06
10FC: VV[0x12] |= 0x20
10FF: 48 25              SLL     A
1101: 48 25              SLL     A
1103: HL = 0x1309;
1106: DE = [0x9821];
1109: 48 8C              LDEAX   (HL+A)
110B: [DE++] = EA;
110D: A += 0x02;
110F: 48 8C              LDEAX   (HL+A)
1111: [DE] = EA;
1113: 40 83 12           CALL    $1283
1116: goto 118C
1118: VV[0x13] |= 0x02
111B: 40 FA 11           CALL    $11FA
111E: 86                 CALT    ($008C)
111F: BC = [0x0000];
1122: HL = [0x993D];
1126: EA = HL;
1127: HL = [0x9901];
112B: EA -= HL;
112D: A = VV[0x22];
112F: 48 3D              DIV     A
1131: DE = EA;
1132: HL = 0x9941;
1135: EA = [HL];
1137: 74 AE              DGT     EA,DE
1139: goto 1144
113A: VV[0x12] |= 0x10
113D: [0x9941] = DE;
1141: EA -= DE;
1143: BC = EA;
1144: 70 1E 3F 99        SBCD    $993F
1148: DE = [0x9941];
114C: EA = DE;
114D: A = VV[0x22];
114F: 84                 CALT    ($0088)
1150: HL = 0x993B;
1153: [HL] = EA;
1155: HL = [0x9941];
1159: EA = HL;
115A: 55 12 08           OFFIW   VV:12,$08
115D: 48 A4              DSLL    EA
115F: HL = EA;
1160: EA = [0x1000];
1163: EA -= HL;
1165: HL = [0x9915];
1169: 74 BF              DLT     EA,HL
116B: goto 1170
116C: push(EA);
	func_2089(); /* always returns 0 */
116E: EA = pop();
116F: goto 1165
1170: HL = [0x9901];
1174: [0x9955] = HL;
1178: VV[0x03] |= 0x80
117B: VV[0x05] |= 0x02
117E: 40 A6 11           CALL    $11A6
1181: VV[0x05] &= 0xFD;
1184: HL = 0x993F;
1187: EA = [HL];
1189: 40 96 11           CALL    $1196
118C: VV[0x12] = 0x00;
118F: return 0;
1190: 40 83 12           CALL    $1283
1193: 00                 NOP     
1194: EA = HL;
1195: goto 1189
1196: 55 12 08           OFFIW   VV:12,$08
1199: 48 A4              DSLL    EA
119B: HL = 0x0000;
119E: 74 EF              DNE     EA,HL
11A0: return 0;
11A1: push(EA);
11A2: 8E                 CALT    ($009C)
11A3: EA = pop();
11A4: A9                 DCX     EA
11A5: goto 119B
11A6: 40 0B 12           CALL    $120B
11A9: return 0;
11AA: 8B                 CALT    ($0096)
11AB: 40 0C 1F           CALL    $1F0C
11AE: BC = [0x993B];
11B2: HL = 0x9901;
11B5: EA = [HL];
11B7: 74 C5              DADD    EA,BC
11B9: [HL] = EA;
11BB: 59 12              BIT     1,VV:12
11BD: goto 11EE
11BF: 40 68 2B           CALL    $2B68
11C2: 40 13 2C           CALL    $2C13
11C5: A = VV[0x21];
11C7: VV[0x20] = A;
11C9: A = VV[0x22];
11CB: VV[0x25] = A;
11CD: HL = [0x9823];
11D1: [0x9923] = HL;
11D5: 5A 12              BIT     2,VV:12
11D7: HL = 0xC005;
11DA: HL = 0xC006;
11DD: A = [HL];
11DE: 40 94 12           CALL    $1294
11E1: VV[0x12] |= 0x80
11E4: VV[0x00] &= 0xFB;
11E7: 92                 CALT    ($00A4)
11E8: 40 2D 1F           CALL    $1F2D
11EB: 40 0C 1F           CALL    $1F0C
11EE: HL = [0x993D];
11F2: 5C 12              BIT     4,VV:12
11F4: HL = [0x9901];
11F8: 85                 CALT    ($008A)
11F9: return 0;
11FA: HL = [0x9901];
11FE: EA = HL;
11FF: A = VV[0x22];
1201: EA += A;
1203: HL = [0x993D];
1207: 74 AF              DGT     EA,HL
1209: return 1;
120A: return 0;
120B: VV[0x12] |= 0x02
120E: BC = [0x9941];
1212: DE = [0x9913];
1216: A = [DE++];
1217: 8F                 CALT    ($009E)	rollover_DE_from_0x9000_to_0x8000();
1218: 77 00              EQI     A,$00
121A: goto 123D
121C: 5B 12              BIT     3,VV:12
121E: goto 1224
121F: A = [DE++];
1220: 8F                 CALT    ($009E)	rollover_DE_from_0x9000_to_0x8000();
1221: 57 80              OFFI    A,$80
1223: goto 123D
1224: 13                 DCX     BC
1225: EA = 0x0000;
1228: 74 FD              DEQ     EA,BC
122A: goto 1216
122B: VV[0x12] &= 0xFD;
122E: 55 12 10           OFFIW   VV:12,$10
1231: goto 123D
1232: DE = [0x993B];
1236: 40 0B 19           CALL    $190B
1239: goto 124E
123A: BC = [0x0000];
123D: HL = [0x9941];
1241: EA = HL;
1242: EA -= BC;
1244: HL = EA;
1245: [0x9943] = HL;
1249: 70 1E 41 99        SBCD    $9941
124D: return 1;
124E: HL = 0x993F;
1251: EA = [HL];
1253: BC = [0x9941];
1257: 74 C5              DADD    EA,BC
1259: [HL] = EA;
125B: return 0;
125C: DE = [0x9941];
1260: EA = 0x0000;
1263: 74 EE              DNE     EA,DE
1265: return 0;
1266: 23                 DCX     DE
1267: [0x9941] = DE;
126B: 40 27 21           CALL    $2127
126E: 00                 NOP     
126F: EA = 0x0000;
1272: EAH = A;
1273: 5B 12              BIT     3,VV:12
1275: goto 127D
1276: push(EA);
1277: 40 27 21           CALL    $2127
127A: 00                 NOP     
127B: EA = pop();
127C: EAL = A;
127D: HL = 0x9925;
1280: [HL] = EA;
1282: return 1;
1283: 8E                 CALT    ($009C)
1284: 1F                 MOV     L,A
1285: push(HL);
1286: 9E                 CALT    ($00BC)
1287: HL = pop();
1288: 1E                 MOV     H,A
1289: EA = 0x0000;
128C: 74 EF              DNE     EA,HL
128E: return 0;
128F: [0x9941] = HL;
1293: return 1;
1294: HL = 0x9943;
1297: EA = [HL];
1299: 40 96 11           CALL    $1196
129C: HL = 0x9943;
129F: EA = [HL];
12A1: A = VV[0x22];
12A3: 84                 CALT    ($0088)
12A4: HL = [0x9903];
12A8: EA += HL;
12AA: BC = EA;
12AB: 70 1E 0B 99        SBCD    $990B
12AF: HL = 0x9941;
12B2: EA = [HL];
12B4: 55 12 08           OFFIW   VV:12,$08
12B7: 48 A4              DSLL    EA
12B9: BC = EA;
12BA: 13                 DCX     BC
12BB: DE = [0x9913];
12BF: EA = DE;
12C0: 74 C5              DADD    EA,BC
12C2: DE = EA;
12C3: BC = [0x9000];
12C6:
	int borrow = (EA >= BC);
	EA -= BC;
	if (!borrow)
		goto 12CF;
12C9: BC = [0x8000];
12CC: 74 C5              DADD    EA,BC
12CE: DE = EA;
12CF: BC = [0x0000];
12D2: 5B 12              BIT     3,VV:12
12D4: goto 12DC
12D5: 2E                 LDAX    (DE-)
12D6: rollover_DE_from_0x7fff_to_0x8fff();
12D9: 57 80              OFFI    A,$80
12DB: goto 12E5
12DC: 2E                 LDAX    (DE-)
12DD: rollover_DE_from_0x7fff_to_0x8fff();
12E0: 77 00              EQI     A,$00
12E2: goto 12E5
12E3: 12                 INX     BC
12E4: goto 12D2
12E5: HL = 0x9941;
12E8: EA = [HL];
12EA: EA -= BC;
12EC: [HL] = EA;
12EE: HL = 0x993F;
12F1: EA = [HL];
12F3: 74 C5              DADD    EA,BC
12F5: [HL] = EA;
12F7: A5                 DMOV    EA,BC
12F8: A = VV[0x22];
12FA: 84                 CALT    ($0088)
12FB: BC = EA;
12FC: HL = 0x9901;
12FF: EA = [HL];
1301: EA -= BC;
1303: HL = 0x990D;
1306: [HL] = EA;
1308: return 0;
1309: 00                 NOP     
130A: EAH = A;
130B: 60 05              illegal 
130D: A = VV[0x0C];
130F: 60 05              illegal 
1311: 00                 NOP     
1312: A = D;
1313: push(VA);
1314: 02                 INX     SP
1315: A = VV[0x06];
1317: push(VA);
1318: 02                 INX     SP
1319: A = VV[0x12];
131B: 10                 EXA     
131C: A = EAH;
131D: A = VV[0x14];
131F: goto 1315
1320: A = EAH;
1321: A = VV[0x10];
1323: 2A                 LDAX    (DE)
1324: 07 B1              ANI     A,$B1
1326: 9E                 CALT    ($00BC)
1327: BC = pop();
1328: 77 00              EQI     A,$00
132A: 67 30              NEI     A,$30
132C: return 0;
132D: 77 01              EQI     A,$01
132F: 67 31              NEI     A,$31
1331: return 1;
1332: HL = pop();
1333: return 0;
1334: 8E                 CALT    ($009C)
1335: A &= 0x7f;
1337: return 0;
1338: 55 02 08           OFFIW   VV:02,$08
133B: 55 02 04           OFFIW   VV:02,$04
133E: goto 1348
133F: 40 77 13           CALL    $1377
1342: 67 11              NEI     A,$11
1344: VV[0x02] |= 0x04
1347: return 0;
1348: 40 63 13           CALL    $1363
134B: goto 134D
134C: return 1;
134D: 67 7F              NEI     A,$7F
134F: goto 137C;
1352: 36 07              SUINB   A,$07
1354: return 0;
1355: HL = 0x13DA;
1358: 48 25              SLL     A
135A: 60 47              ADD     L,A
135C: 74 56 00           ACI     H,$00
135F: EA = [HL];
1361: 48 28              JEA     
1363: 40 77 13           CALL    $1377
1366: 67 7F              NEI     A,$7F
1368: return 0;
1369: 37 20              LTI     A,$20
136B: return 1;
136C: 5D 04              BIT     5,VV:04
136E: return 0;
136F: 77 15              EQI     A,$15
1371: return 0;
1372: A = 0x10;
1374: VV[0x15] = A;
1376: return 1;
1377: 5C 04              BIT     4,VV:04
1379: A &= 0x7f;
137B: return 0;
137C: 55 05 80           OFFIW   VV:05,$80
137F: return 0;
1380: EA = [0x9A79];
1383: HL = [0x9939];
1387: 74 EF              DNE     EA,HL
1389: return 0;
138A: HL--;
138B: A = [HL];
138C: 57 01              OFFI    A,$01
138E: return 0;
138F: HL--;
1390: HL--;
1391: [0x9939] = HL;
1395: 40 36 1D           CALL    $1D36
1398: DE = EA;
1399: HL = 0x9901;
139C: EA = [HL];
139E: EA -= DE;
13A0: [HL] = EA;
13A2: return 0;
13A3: 9E                 CALT    ($00BC)
13A4: 67 19              NEI     A,$19
13A6: goto 13B3
13A7: 77 7F              EQI     A,$7F
13A9: 27 1F              GTI     A,$1F
13AB: goto 13D2
13AD: 27 2F              GTI     A,$2F
13AF: goto 13B3
13B0: 27 5A              GTI     A,$5A
13B2: goto 13C2
13B3: HL = 0x1462;
13B6: B = A;
13B7: A = [HL++];
13B8: 67 00              NEI     A,$00
13BA: return 0;
13BB: 48 85              LDEAX   (HL++)
13BD: 60 FA              EQA     A,B
13BF: goto 13B7
13C0: 48 28              JEA     
13C2: A -= 0x30;
13C4: HL = 0x140C;
13C7: 48 25              SLL     A
13C9: 60 47              ADD     L,A
13CB: 74 56 00           ACI     H,$00
13CE: EA = [HL];
13D0: 48 28              JEA     
13D2: A = VV[0x15];
13D4: 40 63 13           CALL    $1363
13D7: goto 134D
13D9: return 0;
13DA: 57 10              OFFI    A,$10
13DC: goto 8C16;
13DF: EAH = A;
13E0: goto 13D8
13E1: 16 2C              XRI     A,$2C
13E3: EAL = A;
13E4: 02                 INX     SP
13E5: A |= 0xFD;
13E7: 16 B6              XRI     A,$B6
13E9: VV[0xF8] |= 0x14
13EC: DE = EA;
13ED: BC = [0x14B6];
13F0: goto 13ED
13F1: BC = [0x1729];
13F4: goto 13E1
13F5: BC = [0x14B6];
13F8: DE = EA;
13F9: BC = [0x14B6];
13FC: goto 1402
13FD: 16 B6              XRI     A,$B6
13FF: BC = [0x14B6];
1402: HL = pop();
1403: 13                 DCX     BC
1404: DE = EA;
1405: BC = [0x14B6];
1408: DE = EA;
1409: BC = [0x14B6];
140C: 43                 INR     C
140D: A |= 0x45;
140F: A |= 0x47;
1411: A |= 0x4A;
1413: A |= 0xBD;
1415: VV[0xC1] |= 0x15
1418: goto 142A
1419: 16 D5              XRI     A,$D5
141B: 16 4C              XRI     A,$4C
141D: A |= 0x50;
141F: A |= 0xB1;
1421: EAL = A;
1422: DE = EA;
1423: BC = [0x7875];
1426: DE = EA;
1427: BC = [0x14B6];
142A: push(BC);
142B: 10                 EXA     
142C: goto 1446
142D: 16 37              XRI     A,$37
142F: A |= 0xC9;
1431: A |= 0x6C;
1433: A |= 0xCC;
1435: A |= 0x00;
1437: VV[0x04] |= 0x15
143A: A = EAH;
143B: VV[0x0C] |= 0x15
143E: BC = EA;
143F: BC = [0x1754];
1442: goto 1451
1443: 10                 EXA     
1444: goto 1456
1445: 10                 EXA     
1446: 10                 EXA     
1447: VV[0xA1] |= 0x17
144A: DE = EA;
144B: A |= 0x14;
144D: VV[0x89] |= 0x16
1450: 30 17              DCRW    VV:17
1452: EAH = A;
1453: VV[0x25] |= 0x15
1456: EAH = A;
1457: A |= 0xB6;
1459: BC = 0x15A5;
145C: DE = EA;
145D: BC = 0x10D4;
1460: goto 1478
1461: 10                 EXA     
1462: EAL = A;
1463: 5D 17              BIT     5,VV:17
1465: 20 B5              INRW    VV:B5
1467: BC = 0xB721;
146A: BC = 0xB424;
146D: BC = 0xE925;
1470: EAL = A;
1471: 26 F3              ADINC   A,$F3
1473: EAL = A;
1474: 2A                 LDAX    (DE)
1475: goto 1490
1476: 10                 EXA     
1477: A = [HL++];
1478: goto 148A
1479: VV[0x2F] |= 0xBF
147C: A |= 0x5C;
147E: push(EA);
147F: BC = [0xE45E];
1482: 10                 EXA     
1483: 61                 DAA     
1484: A = D;
1485: 16 62              XRI     A,$62
1487: goto 14A2
1488: A |= 0x65;
148A: EAL = A;
148B: EAH = A;
148C: A -= 0x4f;
148E: EAH = A;
148F: A = 0xB5;
1491: BC = 0xB56A;
1494: BC = 0xC56B;
1497: VV[0x6C] |= 0xAB;
149A: 16 6D              XRI     A,$6D
149C: BC = EA;
149D: BC = 0xB570;
14A0: BC = 0xB572;
14A3: BC = 0x3473;
14A6: 16 74              XRI     A,$74
14A8: 02                 INX     SP
14A9: 16 77              XRI     A,$77
14AB: BC = EA;
14AC: BC = [0x2978];
14AF: VV[0x7C] |= 0xDA;
14B2: 7C 00              CALF    $0C00
14B4: 8E                 CALT    ($009C)
14B5: 8E                 CALT    ($009C)
14B6: return 0;
14B7: 8E                 CALT    ($009C)
14B8: VV[0x0A] &= 0x43;
14BB: VV[0x0B] &= 0x7B;
14BE: VV[0x02] &= 0xFD;
14C1: VV[0x02] &= 0xFE;
14C4: 57 01              OFFI    A,$01
14C6: VV[0x0A] |= 0x80
14C9: 57 04              OFFI    A,$04
14CB: VV[0x0B] |= 0x04
14CE: 57 08              OFFI    A,$08
14D0: VV[0x0A] |= 0x04
14D3: 57 10              OFFI    A,$10
14D5: VV[0x0A] |= 0x20
14D8: 47 20              ONI     A,$20
14DA: goto 14E1
14DB: VV[0x02] |= 0x01
14DE: VV[0x0A] |= 0x08
14E1: 57 40              OFFI    A,$40
14E3: VV[0x0B] |= 0x80
14E6: 57 80              OFFI    A,$80
14E8: VV[0x0A] |= 0x10
14EB: goto 1507
14EC: 58 02              BIT     0,VV:02
14EE: 59 02              BIT     1,VV:02
14F0: goto 1507
14F1: VV[0x02] &= 0xFD;
14F4: VV[0x0A] &= 0xF7;
14F7: goto 1507
14F8: VV[0x0B] |= 0x04;
14FB: goto 1507
14FC: VV[0x0B] &= 0xFB;
14FF: goto 1507
1500: VV[0x0A] |= 0x04;
1503: goto 1507
1504: VV[0x0A] &= 0xFB;
1507: goto 1536
1508: VV[0x0A] |= 0x20;
150B: goto 1536
150C: VV[0x0A] &= 0xDF;
150F: goto 1536

1510:
	VV[0x0A] |= 0x80;
	goto 1536
1514:
	VV[0x0A] &= 0x7F;
	goto 1536
1518: 82                 CALT    ($0084)
	goto 151E
	VV[0x0B] &= 0xDF;
	goto 1521
151E:
	VV[0x0B] |= 0x20;
1521:
	VV[0x0B] |= 0x40;
	goto 1536
1525: VV[0x0B] &= 0xBF;
1528: goto 1536
1529: 82                 CALT    ($0084)
152A: goto 152F
152B: VV[0x0B] |= 0x02
152E: goto 1536
152F: VV[0x0B] &= 0xFD;
1532: goto 1536
1533: VV[0x07] |= 0x80
1536:
	A = VV[0x07]
	BC = [0x980A];
	A &= 0xbf; /* 1011 1111 */
	57 80              OFFI    A,$80
	A |= 0x40;
	74 4A 02           ONI     B,$02
	74 5B 04           OFFI    C,$04
	B &= 0xfb;
	74 4B A4           ONI     C,$A4
	74 5A 46           OFFI    B,$46
	goto 1557
	47 20              ONI     A,$20
	55 05 80           OFFIW   VV:05,$80
1557:
	A &= 0xbf; /* 1011 1111 */
	45 07 40           ONIW    VV:07,$40
	goto 1562
	47 40              ONI     A,$40
	goto 1599
	goto 1566
1562:
	57 40              OFFI    A,$40
	goto 1599
1566:
	74 5A 06           OFFI    B,$06
	goto 156E
	74 4B 04           ONI     C,$04
	goto 1577
156E:
	45 08 04           ONIW    VV:08,$04
	55 09 06           OFFIW   VV:09,$06
	goto 157F
	goto 1599
1577:
	55 08 04           OFFIW   VV:08,$04
	goto 1599
	55 09 06           OFFIW   VV:09,$06
	goto 1599
157F:
	74 4A 02           ONI     B,$02
	goto 1587
	59 09              BIT     1,VV:09
	goto 1599
	goto 159E
1587:
	55 09 02           OFFIW   VV:09,$02
	goto 1599
	74 5B 04           OFFI    C,$04
	goto 1596
	74 5A 04           OFFI    B,$04
	5A 08              BIT     2,VV:08
	goto 159E
	goto 1599
1596:
	5A 09              BIT     2,VV:09
	goto 159E
1599:
	push(VA);
	push(BC);
	8B                 CALT    ($0096)
	BC = pop();
	VA = pop();
159E:
	VV[0x07] = A;
	70 1E 08 98        SBCD    $9808
	return 0;
15A5: 82                 CALT    ($0084)
15A6: goto 15AE
15A7: VV[0x02] |= 0x01
15AA: VV[0x0A] |= 0x08
15AD: goto 15B4
15AE: VV[0x02] &= 0xFC;
15B1: VV[0x0A] &= 0xF7;
15B4: goto 1536
15B6: VV[0x02] |= 0x02
15B9: BC = 0x0008;
15BC: goto 15CC
15BD: BC = 0x8000;
15C0: goto 15CC
15C1: BC = 0x8000;
15C4: goto 15D0
15C5: BC = 0x0001;
15C8: goto 15D4
15C9: BC = 0x0001;
15CC: goto 15D6
15CD: BC = 0x0001;
15D0: goto 15E9
15D1: BC = 0x0010;
15D4: 82                 CALT    ($0084)
15D5: goto 15E9
15D6: HL = 0x980A;
15D9: EA = [HL];
15DB: EA |= BC;
15DD: [HL] = EA;
15DF: HL = 0x9808;
15E2: EA = [HL];
15E4: EA |= BC;
15E6: [HL] = EA;
15E8: return 0;
15E9: EA = 0xFFFF;
	EA ^= BC;
15EE: BC = EA;
15EF: HL = 0x980A;
15F2: EA = [HL];
15F4: EA &= BC;
15F6: [HL] = EA;
15F8: HL = 0x9808;
15FB: EA = [HL];
15FD: EA &= BC;
15FF: [HL] = EA;
1601: return 0;
1602: 82                 CALT    ($0084)
1603: goto 1608
1604: VV[0x04] |= 0x20
1607: return 0;
1608: VV[0x04] &= 0xDF;
160B: return 0;
160C: 8E                 CALT    ($009C)
160D: A &= 0x0f;
160F: 37 04              LTI     A,$04
1611: return 0;
1612: C = 0x00;
1614: 67 01              NEI     A,$01
1616: C = 0x10;
1618: 67 02              NEI     A,$02
161A: C = 0x20;
161C: 67 03              NEI     A,$03
161E: C = 0x80;
1620: A = VV[0x05];
1622: 07 B0              ANI     A,$B0
1624: 60 EB              NEA     A,C
1626: return 0;
1627: push(BC);
1628: 86                 CALT    ($008C)
1629: BC = pop();
162A: A = VV[0x05];
162C: 07 4F              ANI     A,$4F
162E: 60 9B              ORA     A,C
1630: VV[0x05] = A;
1632: goto 15B4
1634: 82                 CALT    ($0084)
1635: goto 1641
1636: 55 07 20           OFFIW   VV:07,$20
1639: return 0;
163A: 40 4B 16           CALL    $164B
163D: VV[0x07] |= 0x20
1640: goto 1632
1641: 5D 07              BIT     5,VV:07
1643: return 0;
1644: 40 4B 16           CALL    $164B
1647: VV[0x07] &= 0xDF;
164A: goto 1632
164B: 55 08 04           OFFIW   VV:08,$04
164E: return 0;
164F: 45 09 06           ONIW    VV:09,$06
1652: 8B                 CALT    ($0096)
1653: return 0;
1654: 55 05 B0           OFFIW   VV:05,$B0
1657: return 0;
1658: 8B                 CALT    ($0096)
1659: 5F 03              BIT     7,VV:03
165B: goto 166B
165C: VV[0x03] &= 0x7F;
165F: HL = [0x9955];
1663: EA = HL;
1664: HL = [0x9901];
1668: 74 AF              DGT     EA,HL
166A: goto 1675
166B: 97                 CALT    ($00AE)
166C: DE = EA;
166D: HL = 0x9901;
1670: EA = [HL];
	int borrow = (EA >= DE);
	EA -= DE;
	if (!borrow)
		return 0;
1675: BC = [0x9905];
1679: 74 BD              DLT     EA,BC
167B: goto 167D
167C: return 0;
167D: HL = EA;
167E: 85                 CALT    ($008A)
167F: return 0;
1680: BC = [0x9808];
1684: 40 C9 22           CALL    $22C9
1687: HL = EA;
1688: return 0;
1689: 40 82 18           CALL    $1882
168C: return 0;
168D: DE = [0x9905];
	int borrow = (EA >= DE);
	EA -= DE;
	if (!borrow)
		return 0;
1694: DE = [0x011F];
1697: 74 AE              DGT     EA,DE
1699: return 0;
169A: EA = HL;
169B: DE = [0x4C81];
169E: 5B 4F              BIT     3,VV:4F
16A0: DE = [0x2D01];
16A3: 74 BE              DLT     EA,DE
16A5: return 0;
16A6: [0x993D] = HL;
16AA: goto 16C4
16AB: 40 82 18           CALL    $1882
16AE: return 0;
16AF: DE = [0x993D];
16B3: EA = DE;
	int borrow = (EA >= HL);
	EA -= HL;
	if (!borrow)
		return 0;
16B7: DE = [0x011F];
16BA: 74 AE              DGT     EA,DE
16BC: return 0;
16BD: [0x9905] = HL;
16C1: VV[0x03] &= 0xEF;
16C4: goto 16C9
16C5: 55 05 80           OFFIW   VV:05,$80
16C8: return 0;
16C9:
	40 0B 17           CALL    $170B
	VV[0x11] &= 0xFE;
	9D                 CALT    ($00BA)
	return 0;
	VV[0x04] |= 0x10
	return 0;
	VV[0x04] &= 0xEF;
	return 0;
	40 75 78           CALL    $7875
	40 68 2B           CALL    $2B68
	func_7bb1();
	memset(0x9800, 0x00, 0x0d);
	memset(0x9857, 0x00, 0xb2);
	VV[0x14] |= 0x20;
	EA = pop();
	goto 0195;

16F7:
	98                 CALT    ($00B0)
16F8:
	83                 CALT    ($0086)
	40 82 2B           CALL    $2B82
	goto 1707;
16FD:
	98                 CALT    ($00B0)
	5F 02              BIT     7,VV:02
	goto 1707
	goto 16F8
	98                 CALT    ($00B0)
	40 6F 2B           CALL    $2B6F
	83                 CALT    ($0086)
1707:
	55 11 01           OFFIW   VV:11,$01
	return 0;
170B:
	HL = [0x9905];
170F: [0x9901] = HL;
1713: [0x9903] = HL;
1717: return 0;
1718: 82                 CALT    ($0084)
1719: goto 1721
171A: 5B 00              BIT     3,VV:00
171C: 8B                 CALT    ($0096)
171D: VV[0x00] |= 0x08
1720: return 0;
1721: 55 00 08           OFFIW   VV:00,$08
1724: 8B                 CALT    ($0096)
1725: VV[0x00] &= 0xF7;
1728: return 0;
1729: 5B 02              BIT     3,VV:02
172B: return 0;
172C: VV[0x02] &= 0xFB;
172F: return 0;
1730: 9E                 CALT    ($00BC)
1731: 37 0D              LTI     A,$0D
1733: return 0;
1734: VV[0x0C] = A;
1736: return 0;
1737: 9E                 CALT    ($00BC)
1738: 37 56              LTI     A,$56
173A: return 0;
173B: B = 0x03;
173D: EA = A * B;
173F: A = EAL;
1740: VV[0x2C] = A;
1742: return 0;
1743: A = 0x1B;
1745: A = 0x15;
1747: A = 0x24;
1749: goto 1740
174A: 8E                 CALT    ($009C)
174B: goto 1740
174C: VV[0x01] |= 0x04
174F: return 0;
1750: VV[0x01] &= 0xFB;
1753: return 0;
1754: 8B                 CALT    ($0096)
1755: 8E                 CALT    ($009C)
1756: BC = [0x0000];
1759: C = A;
175A: goto 2B88;
175D: 9E                 CALT    ($00BC)
175E: 67 30              NEI     A,$30
1760: goto 1768
1761: 77 34              EQI     A,$34
1763: return 0;
1764: VV[0x02] |= 0x20
1767: return 0;
1768: VV[0x02] &= 0xDF;
176B: return 0;
176C: 9E                 CALT    ($00BC)
176D: 70 6A 2C 98        MOV     B,($982C)
	if (VV[0x15] != 0x00)
		goto 177B;
1775: 8E                 CALT    ($009C)
1776: 37 17              LTI     A,$17
1778: return 0;
1779: B = 0xD8;
177B: EA = A * B;
177D: HL = 0x0000;
1780: 74 EF              DNE     EA,HL
1782: return 0;
1783: 40 F3 32           CALL    $32F3
1786: [HL] = EA;
1788: HL = 0x9931;
178B: EA = [HL];
178D: HL = 0x992F;
1790: [HL] = EA;
1792: HL = 0x0000;
1795: [0x992B] = HL;
1799: [0x9907] = HL;
179D: VV[0x0D] = 0x00;
17A0: return 0;
17A1: 9E                 CALT    ($00BC)
17A2: 67 00              NEI     A,$00
17A4: return 0;
17A5: B = A;
17A6: A = VV[0x2C];
17A8: EA = A * B;
17AA: BC = EA;
17AB: HL = 0x9931;
17AE: EA = [HL];
17B0: 74 FD              DEQ     EA,BC
17B2: 74 B5              DSUBNB  EA,BC
17B4: return 0;
17B5: goto 17B9
17B6: EA = [0xFFFF];
17B9: HL = 0x992F;
17BC: [HL] = EA;
17BE: return 0;
17BF: 9E                 CALT    ($00BC)
17C0: 37 08              LTI     A,$08
17C2: return 0;
17C3: VV[0x03] |= 0x20
17C6: VV[0x0E] = A;
17C8: return 0;
17C9: A = 0x00;
17CB: goto 17DE
17CC: VV[0x03] |= 0x30
17CF: 97                 CALT    ($00AE)
17D0: HL = 0x9857;
17D3: 48 95              STEAX   (HL++)
17D5: BC = [0x0020];
17D8: goto 17FA
17DA: 9E                 CALT    ($00BC)
17DB: 37 08              LTI     A,$08
17DD: return 0;
17DE: B = 0x11;
17E0: EA = A * B;
17E2: VV[0x03] |= 0x20;
17E5: bitmask(A); /* always returns 0 */
17E8: 74 98 0D           ORAW    VV:0D
17EB: VV[0x0D] = A;
17ED: HL = 0x9879;
17F0: EA += HL;
17F2: HL = EA;
17F3: A = VV[0x2C];
17F5: 3D                 STAX    (HL+)
17F6: C = 0x10;
17F8: B = 0x00;
17FA: push(BC);
17FB: push(HL);
17FC: 8E                 CALT    ($009C)
17FD: HL = pop();
17FE: BC = pop();
17FF: 53                 DCR     C
1800: goto 1802
1801: goto 1811
1802: 67 00              NEI     A,$00
1804: goto 180B
1805: 60 AA              GTA     A,B
1807: goto 180B
1808: 3D                 STAX    (HL+)
1809: B = A;
180A: goto 17FA
180B: 4B 00              MVIX    HL,$00
180D: return 0;
180E: push(BC);
180F: 8E                 CALT    ($009C)
1810: BC = pop();
1811: 67 00              NEI     A,$00
1813: return 0;
1814: 60 AA              GTA     A,B
1816: return 0;

1817: B = A;
1818: goto 180E
1819: 82                 CALT    ($0084)
181A: goto 1832
181B: 9E                 CALT    ($00BC)
181C: B = A;
181D: A = VV[0x2C];
181F: EA = A * B;
1821: BC = EA;
1822: 40 F3 32           CALL    $32F3
1825: EA = [HL];
1827: 74 AD              DGT     EA,BC
1829: return 0;
182A: 70 1E 07 99        SBCD    $9907
182E: VV[0x03] &= 0xDF;
1831: return 0;
1832: 9E                 CALT    ($00BC)
1833: push(VA);
1834: 97                 CALT    ($00AE)
1835: VA = pop();
1836: 84                 CALT    ($0088)
1837: BC = EA;
1838: DE = [0x011F];
183B: 74 AE              DGT     EA,DE
183D: return 0;
183E: DE = [0x0BF5];
1841: 74 BE              DLT     EA,DE
1843: return 0;
1844: 70 1E 09 99        SBCD    $9909
1848: VV[0x03] &= 0xDF;
184B: VV[0x03] |= 0x10
184E: return 0;
184F: 82                 CALT    ($0084)
1850: goto 1862
1851: 8B                 CALT    ($0096)
1852: 9E                 CALT    ($00BC)
1853: B = A;
1854: A = VV[0x2C];
1856: EA = A * B;
1858: BC = [0x0000];
185B: 74 ED              DNE     EA,BC
185D: return 0;
185E: BC = EA;
185F: goto 2B88;
1862: 55 05 80           OFFIW   VV:05,$80
1865: return 0;
1866: 9E                 CALT    ($00BC)
1867: 67 00              NEI     A,$00
1869: return 0;
186A: push(VA);
186B: 8B                 CALT    ($0096)
186C: 97                 CALT    ($00AE)
186D: VA = pop();
186E: 84                 CALT    ($0088)
186F: DE = [0x9901];
1873: EA += DE;
1875: DE = [0x993D];
1879: 74 BE              DLT     EA,DE
187B: goto 16F7;
187E: HL = EA;
187F: goto 170F;
1882: 97                 CALT    ($00AE)
1883: push(EA);
1884: 8E                 CALT    ($009C)
1885: EA = pop();
1886: 84                 CALT    ($0088)
1887: 48 1A              SKN     CY
1889: return 0;
188A: HL = EA;
188B: return 1;
188C: 55 05 80           OFFIW   VV:05,$80
188F: return 0;
1890: 5C 03              BIT     4,VV:03
1892: goto 18E8
1894: 5D 03              BIT     5,VV:03
1896: goto 18C5
1898: HL = 0x9857;
189B: B = 0x01;
189D: 42                 INR     B
189E: 74 3A 23           LTI     B,$23
18A1: return 0;
18A2: AD                 LDAX    (HL+B)
18A3: 67 00              NEI     A,$00
18A5: return 0;
18A6: push(BC);
18A7: EA = [HL];
18A9: 84                 CALT    ($0088)
18AA: BC = pop();
18AB: 48 1A              SKN     CY
18AD: return 0;
18AE: DE = [0x9905];
18B2: EA += DE;
18B4: DE = [0x993D];
18B8: 74 BE              DLT     EA,DE
18BA: return 0;
18BB: DE = [0x9901];
18BF: 74 AE              DGT     EA,DE
18C1: goto 189D
18C3: goto 18EE
18C5: BC = [0x9909];
18C9: EA = 0x0000;
18CC: 74 ED              DNE     EA,BC
18CE: return 0;
18CF: HL = 0x9905;
18D2: EA = [HL];
18D4: 74 C5              DADD    EA,BC
18D6: DE = [0x993D];
18DA: DE++;
18DB: 74 BE              DLT     EA,DE
18DD: goto 16F7
18E0: DE = [0x9901];
18E4: 74 AE              DGT     EA,DE
18E6: goto 18D4
18E7: goto 18EE
18E8: 97                 CALT    ($00AE)
18E9: A = 0x08;
18EB: 84                 CALT    ($0088)
18EC: BC = EA;
18ED: goto 18CF
18EE: VV[0x03] &= 0x7F;
18F1: HL = EA;
18F2: BC = [0x9903];
18F6: A5                 DMOV    EA,BC
18F7: 74 EE              DNE     EA,DE
18F9: goto 1909
18FA: EA = HL;
18FB: EA -= DE;
18FD: DE = EA;
18FE: [0x993B] = DE;
1902: 40 0B 19           CALL    $190B
1905: return 0;
1906: push(HL);
1907: 8B                 CALT    ($0096)
1908: HL = pop();
1909: 85                 CALT    ($008A)
190A: return 0;
190B: 5E 07              BIT     6,VV:07
190D: goto 191A
190E: EA = DE;
190F: A = 0x10;
1911: 48 3D              DIV     A
1913: 67 00              NEI     A,$00
1915: goto 1929
1916: 55 11 20           OFFIW   VV:11,$20
1919: return 1;
191A: EA = DE;
191B: 5A 09              BIT     2,VV:09
191D: A = 0x0C;
191F: A = 0x06;
1921: 48 3D              DIV     A
1923: 77 00              EQI     A,$00
1925: return 1;
1926: VV[0x07] &= 0xBF;
1929: goto 2291;
192C: 98                 CALT    ($00B0)
192D: 83                 CALT    ($0086)
192E: 40 0B 17           CALL    $170B
1931: 5D 03              BIT     5,VV:03
1933: goto 1979
1935: A = VV[0x0E];
1937: bitmask(A); /* always returns 0 */
193A: 74 C8 0D           ONAW    VV:0D
193D: goto 1983
193F: A = VV[0x0E];
1941: B = 0x11;
1943: EA = A * B;
1945: HL = 0x9879;
1948: EA += HL;
194A: HL = EA;
194B: DE = [0x992B];
194F: A = [HL++];
1950: B = A;
1951: C = 0x10;
1953: 53                 DCR     C
1954: goto 1956
1955: goto 1970
1956: A = [HL++];
1957: 67 00              NEI     A,$00
1959: goto 1970
195A: EA = A * B;
195C: 74 AE              DGT     EA,DE
195E: goto 1953
195F: 40 EC 32           CALL    $32EC
1962: goto 196A
1963: BC = [0x992F];
1967: 74 BD              DLT     EA,BC
1969: goto 1976
196A: EA -= DE;
196C: BC = EA;
196D: goto 2B88;
1970: 74 6B 0F           NEI     C,$0F
1973: goto 16FD;
1976: goto 2B6F;
1979: BC = [0x9907];
197D: A5                 DMOV    EA,BC
197E: BC = [0x0000];
1981: 74 ED              DNE     EA,BC
1983: goto 2B82;
1986: BC = EA;
1987: push(EA);
1988: 40 F3 32           CALL    $32F3
198B: EA = [HL];
198D: DE = EA;
198E: EA = pop();
198F: 74 BE              DLT     EA,DE
1991: goto 1976
1992: DE = [0x992B];
1996: 74 EE              DNE     EA,DE
1998: goto 199D
1999: 74 BE              DLT     EA,DE
199B: goto 196A
199D: 74 C5              DADD    EA,BC
199F: goto 1987

19A0: HL = 0xFF00;
19A3: B  = 0x0c;
19A5: 40 DD 19           CALL    $19DD
19A8: HL = 0xFF48;
19AB: B  = 0x1d;
19AD: 40 DD 19           CALL    $19DD
19B0: return 0;

19B1: 8B                 CALT    ($0096)
19B2: 9E                 CALT    ($00BC)
19B3: push(VA);
19B4: 9E                 CALT    ($00BC)
19B5: push(VA);
19B6: 9E                 CALT    ($00BC)
19B7: C = A;
19B8: VA = pop();
19B9: B = A;
19BA: VA = pop();
19BB: 51                 DCR     A
19BC: return 0;
19BD: 53                 DCR     C
19BE: return 0;
19BF: 74 3A 02           LTI     B,$02
19C2: return 0;
19C3: VV[0x04] &= 0xF7;
19C6: 74 6A 01           NEI     B,$01
19C9: VV[0x04] |= 0x08
19CC: 59 09              BIT     1,VV:09
19CE: A = 0x0C;
19D0: A = 0x1D;
19D2: B = A;
19D3: 59 09              BIT     1,VV:09
19D5: HL = 0xFF00;
19D8: HL = 0xFF48;
19DB: A = 0xFF;
19DD: A = 0x00;
19DF: C = 0x05;
19E1: 3B                 STAX    (HL)
19E2: EA = HL;
19E3: 70 42              EADD    EA,B
19E5: HL = EA;
19E6: 53                 DCR     C
19E7: goto 19E1
19E8: return 0;
19E9: 82                 CALT    ($0084)
19EA: goto 19EF
19EB: VV[0x04] |= 0x80
19EE: return 0;
19EF: VV[0x04] &= 0x7F;
19F2: return 0;
19F3: 8B                 CALT    ($0096)
19F4: 9E                 CALT    ($00BC)
19F5: push(VA);
19F6: 8E                 CALT    ($009C)
19F7: push(VA);
19F8: 8E                 CALT    ($009C)
19F9: C = A;
19FA: VA = pop();
19FB: B = A;
19FC: VA = pop();
19FD: 77 00              EQI     A,$00
19FF: return 0;
1A00: A = C;
1A01: 74 32 3A           SUINB   B,$3A
1A04: goto 1A1F
1A05: 37 40              LTI     A,$40
1A07: goto 1A1F
1A08: 36 3A              SUINB   A,$3A
1A0A: goto 1A1D
1A0B: 60 B2              SUBNB   A,B
1A0D: return 0;
1A0E: C = A;
1A0F: push(BC);
1A10: 59 09              BIT     1,VV:09
1A12: 40 42 1A           CALL    $1A42
1A15: 40 58 1A           CALL    $1A58
1A18: BC = pop();
1A19: 42                 INR     B
1A1A: 53                 DCR     C
1A1B: goto 1A0F
1A1C: return 0;
1A1D: A += 0x3A;
1A1F: B += 0x3A;
1A22: 60 B2              SUBNB   A,B
1A24: return 0;
1A25: 59 09              BIT     1,VV:09
1A27: goto 1A3A
1A28: C = A;
1A29: push(BC);
1A2A: 8E                 CALT    ($009C)
1A2B: 8E                 CALT    ($009C)
1A2C: push(VA);
1A2D: 8E                 CALT    ($009C)
1A2E: VA = pop();
1A2F: B = 0x03;
1A31: EA = A * B;
1A33: 40 9B 11           CALL    $119B
1A36: BC = pop();
1A37: 53                 DCR     C
1A38: goto 1A29
1A39: return 0;
1A3A: 41                 INR     A
1A3B: B = 0x0C;
1A3D: EA = A * B;
1A3F: goto 119B;
1A42: func_1AC2(); /* always returns 0 */
1A45: push(HL);
1A46: 8E                 CALT    ($009C)
1A47: 07 80              ANI     A,$80
1A49: A |= 0x0B;
1A4B: HL = pop();
1A4C: 3D                 STAX    (HL+)
1A4D: C = 0x0A;
1A4F: push(HL);
1A50: push(BC);
1A51: 8E                 CALT    ($009C)
1A52: BC = pop();
1A53: HL = pop();
1A54: 3D                 STAX    (HL+)
1A55: 53                 DCR     C
1A56: goto 1A4F
1A57: return 1;
1A58: func_1AC2(); /* always returns 0 */
1A5B: push(HL);
1A5C: 8E                 CALT    ($009C)
1A5D: 8E                 CALT    ($009C)
1A5E: push(VA);
1A5F: 8E                 CALT    ($009C)
1A60: VA = pop();
1A61: HL = pop();
1A62: 67 00              NEI     A,$00
1A64: return 0;
1A65: 37 0C              LTI     A,$0C
1A67: A = 0x0C;
1A69: 3D                 STAX    (HL+)
1A6A: push(HL);
1A6B: HL++;
1A6C: HL++;
1A6D: C = A;
1A6E: B = 0x10;
1A70: 60 62              SUB     B,A
1A72: goto 1AA0
1A74: push(BC);
1A75: push(HL);
1A76: 8E                 CALT    ($009C)
1A77: EAH = A;
1A78: push(EA);
1A79: 8E                 CALT    ($009C)
1A7A: EA = pop();
1A7B: EAL = A;
1A7C: C = 0x07;
1A7E: 48 A4              DSLL    EA
1A80: 48 35              RLL     A
1A82: 48 A4              DSLL    EA
1A84: 48 36              RLL     B
1A86: 53                 DCR     C
1A87: goto 1A7E
1A88: HL = pop();
1A89: 3D                 STAX    (HL+)
1A8A: A = B;
1A8B: BF 0D              STAX    (HL+$0D)
1A8D: push(HL);
1A8E: 8E                 CALT    ($009C)
1A8F: HL = 0x994D;
1A92: C = 0x01;
1A94: EA = [HL];
1A96: 48 25              SLL     A
1A98: 48 B4              DRLL    EA
1A9A: 48 95              STEAX   (HL++)
1A9C: 53                 DCR     C
1A9D: goto 1A94
1A9E: HL = pop();
1A9F: BC = pop();
1AA0: 53                 DCR     C
1AA1: goto 1A74
1AA3: DE = pop();
1AA4: push(BC);
1AA5: HL = 0x994D;
1AA8: 48 85              LDEAX   (HL++)
1AAA: goto 1AAD
1AAB: 48 A4              DSLL    EA
1AAD: 52                 DCR     B
1AAE: goto 1AAB
1AAF: A = EAH;
1AB0: [DE++] = A;
1AB1: A = EAL;
1AB2: [DE++] = A;
1AB3: BC = pop();
1AB4: EA = [HL];
1AB6: goto 1AB9
1AB7: 48 A4              DSLL    EA
1AB9: 52                 DCR     B
1ABA: goto 1AB7
1ABB: A = EAH;
1ABC: BB 0C              STAX    (DE+$0C)
1ABE: A = EAL;
1ABF: BB 0D              STAX    (DE+$0D)
1AC1: return 0;

/* always returns 0 */
void func_1AC2(void)
{
	if (VV[0x09] & 0x02) {
		A  = 0x1D;
		HL = 0xFF48;
	} else {
		A  = 0x0C;
		HL = 0xFF00;
	}
	EA = A * B;
	EA += HL;
	HL = EA;
	return 0;
}

1AD6: 70 6A 15 98        MOV     B,($9815)
1ADA: 5F 04              BIT     7,VV:04
1ADC: return 0;
1ADD: 74 3A 3A           LTI     B,$3A
1AE0: 74 3A 40           LTI     B,$40
1AE3: return 0;
1AE4: B -= 0x3a;
1AE7: func_1AC2(); /* always returns 0 */
1AEA: A = [HL];
1AEB: 67 FF              NEI     A,$FF
1AED: goto 1AF8
1AEE: VV[0x09] &= 0x7F;
1AF1: 77 00              EQI     A,$00
1AF3: return 1;
1AF4: VV[0x15] = ' ';
1AF7: return 0;
1AF8: VV[0x08] &= 0xFE;
1AFB: 55 04 08           OFFIW   VV:04,$08
1AFE: VV[0x08] |= 0x01
1B01: return 0;
1B02: VV[0x05] |= 0x04

1B05:
	HL = [0x9939];
	EA = 0x9a79;
	74 BF              DLT     EA,HL
	goto 1BB8
	40 0C 1F           CALL    $1F0C
	5F 06              BIT     7,VV:06
	goto 1B1F
	VV[0x06] &= 0xef; /* 1110 1111 */
	5D 06              BIT     5,VV:06
	goto 1B1F
	VV[0x06] |= 0x10; /* 0001 0000 */
1B1F:
	40 4E 30           CALL    $304E
	40 AE 1F           CALL    $1FAE
	40 BC 1B           CALL    $1BBC
	VV[0x10] &= 0xAF;
	VV[0x10] |= 0x01;
	VV[0x2A] = 0x10;
	VV[0x2B] = 0x00;
	8C                 CALT    ($0098)
	goto 1B99
	40 68 2B           CALL    $2B68
	40 13 2C           CALL    $2C13
	40 D5 7B           CALL    $7BD5
	VV[0x13] |= 0x02;
	40 D9 1E           CALL    $1ED9
	VV[0x10] &= 0xFE;
	5B 11              BIT     3,VV:11
	goto 1B60
	VV[0x10] |= 0x40;
	VV[0x2A] = 0x20;
	VV[0x2B] = 0x00;
	8C                 CALT    ($0098)
	goto 1B60
	BC = [0x0001];
	40 A6 2E           CALL    $2EA6
	40 D9 1E           CALL    $1ED9
1B60:
	5C 11              BIT     4,VV:11
	goto 1B99
	VV[0x10] |= 0x10
	VV[0x10] &= 0xBF;
	VV[0x2A] = 0x00;
	VV[0x2B] = 0x10;
	8C                 CALT    ($0098)
	goto 1B99
	BC = [0x000C];
	75 26 00           EQIW    VV:26,$00
	BC = [0x000B];
	40 A6 2E           CALL    $2EA6
	40 D9 1E           CALL    $1ED9
	5B 11              BIT     3,VV:11
	goto 1B99
	VV[0x10] |= 0x40;
	VV[0x2A] = 0x20;
	VV[0x2B] = 0x10;
	8C                 CALT    ($0098)
	goto 1B99
	BC = [0x0001];
	40 A6 2E           CALL    $2EA6
	40 D9 1E           CALL    $1ED9
1B99:
	55 05 08           OFFIW   VV:05,$08
	goto 1BAF
	55 05 30           OFFIW   VV:05,$30
	5A 05              BIT     2,VV:05
	goto 1BB4
	HL = [0x9901];
	EA = HL;
	HL = [0x9903];
	74 EF              DNE     EA,HL
	goto 1BB4
1BAF:
	HL = [0x993D];
	85                 CALT    ($008A)
1BB4:
	9D                 CALT    ($00BA)
	VV[0x06] |= 0x10; /* 0001 0000 */
1BB8:
	VV[0x05] &= 0xFB;
	return 0;

1BBC:
	VV[0x05] &= 0xF7;
	VV[0x11] &= 0xFE;
	55 05 30           OFFIW   VV:05,$30
	goto 1C75
	5F 05              BIT     7,VV:05
	return 0;
	55 05 02           OFFIW   VV:05,$02
	return 0;
	5B 03              BIT     3,VV:03
	if (VV[0x33] == 0x00)
		return 0;
1BD4: VV[0x05] &= 0xBF;
1BD7: 55 11 04           OFFIW   VV:11,$04
1BDA: goto 1BF9
1BDB: 40 79 1D           CALL    $1D79
1BDE: 48 1A              SKN     CY
1BE0: goto 1C00
1BE1: 48 A4              DSLL    EA
1BE3: BC = EA;
1BE4: HL = [0x993D];
1BE8: EA = HL;
1BE9: HL = [0x9903];
1BED: EA -= HL;
1BEF: 74 B5              DSUBNB  EA,BC
1BF1: return 0;
1BF2: 12                 INX     BC
1BF3: 74 B5              DSUBNB  EA,BC
1BF5: return 0;
1BF6: VV[0x05] |= 0x40
1BF9: 40 2A 1C           CALL    $1C2A
	if (VV[0x33] == 0x00)
		return 0;
1C00: 40 79 1D           CALL    $1D79
1C03: HL = [0x9947];
1C07: EA += HL;
1C09: A = VV[0x25];
1C0B: 48 3D              DIV     A
1C0D: push(EA);
1C0E: HL = [0x993D];
1C12: EA = HL;
1C13: 70 61              ESUB    EA,A
1C15: HL = EA;
1C16: [0x9901] = HL;
1C1A: EA = pop();
	A = VV[0x33];
1C1D: 48 3D              DIV     A
1C1F: DE = EA;
1C20: [0x9953] = DE;
1C24: VV[0x34] = A;
1C26: VV[0x05] |= 0x08
1C29: return 0;
1C2A: HL = [0x9939];
1C2E: [0x9951] = HL;
1C32: HL--;
1C33: HL--;
1C34: HL--;
1C35: A = [HL];
1C36: 48 8F 01           LDEAX   (HL+$01)
1C39: BC = EA;
1C3A: 40 C9 22           CALL    $22C9
1C3D: BC = EA;
1C3E: DE = [0x9901];
1C41: EA = [DE];
1C43: EA -= BC;
1C45: [DE] = EA;
1C47: A = [HL];
1C48: 67 20              NEI     A,$20
1C4A: goto 1C54
1C4B: 55 05 40           OFFIW   VV:05,$40
1C4E: goto 1C64
1C4F: VV[0x11] |= 0x01
1C52: goto 1C32
1C54: VV[0x05] |= 0x40
1C57: DE = [0x9947];
1C5A: EA = [DE];
1C5C: EA -= BC;
1C5E: [DE] = EA;
	if (VV[0x33]--)
		goto 1C32;
1C64: HL++;
1C65: HL++;
1C66: HL++;
1C67: [0x9939] = HL;
1C6B: DE = [0x9901];
1C6E: EA = [DE];
1C70: 74 C5              DADD    EA,BC
1C72: [DE] = EA;
1C74: return 0;
1C75: 5A 05              BIT     2,VV:05
1C77: return 0;
1C78: 40 79 1D           CALL    $1D79
1C7B: 5D 05              BIT     5,VV:05
1C7D: 48 A0              DSLR    EA
1C7F: DE = EA;
1C80: HL = 0x9903;
1C83: EA = [HL];
1C85: EA += DE;
1C87: [HL] = EA;
1C89: HL = 0x9901;
1C8C: EA = [HL];
1C8E: EA += DE;
1C90: [HL] = EA;
1C92: return 0;
1C93: HL = 0x9833;
1C96: 48 85              LDEAX   (HL++)
1C98: [HL] = EA;
1C9A: 40 B1 1C           CALL    $1CB1
1C9D: return 0;
1C9E: 40 DC 1C           CALL    $1CDC
1CA1: 55 07 40           OFFIW   VV:07,$40
1CA4: goto 1CB0
1CA5: B = 0x48;
1CA7: HL = 0x990D;
1CAA: EA = [HL];
1CAC: 70 42              EADD    EA,B
1CAE: [HL] = EA;
1CB0: return 1;
1CB1: BC = [0x9903];
1CB5: HL = 0x9A79;
1CB8: DE = [0x9939];
1CBC: 70 1E 0B 99        SBCD    $990B
1CC0: [0x9933] = HL;
1CC4: EA = HL;
1CC5: 74 BE              DLT     EA,DE
1CC7: return 0;
1CC8: 40 00 1D           CALL    $1D00
1CCB: return 1;
1CCC: push(DE);
1CCD: 40 3E 1D           CALL    $1D3E
1CD0: DE = pop();
1CD1: BC = [0x990B];
1CD5: 74 C5              DADD    EA,BC
1CD7: BC = EA;
1CD8: HL++;
1CD9: HL++;
1CDA: HL++;
1CDB: goto 1CBC
1CDC: BC = [0x9901];
1CE0: HL = [0x9939];
1CE4: 70 1E 0D 99        SBCD    $990D
1CE8: [0x9935] = HL;
1CEC: HL--;
1CED: HL--;
1CEE: HL--;
1CEF: 40 00 1D           CALL    $1D00
1CF2: return 0;
1CF3: 40 51 1D           CALL    $1D51
1CF6: BC = [0x990D];
1CFA: DE = EA;
1CFB: A5                 DMOV    EA,BC
1CFC: EA -= DE;
1CFE: BC = EA;
1CFF: goto 1CE4
1D00: BC = [0x982A];
1D04: 48 8F 01           LDEAX   (HL+$01)
1D07: 58 10              BIT     0,VV:10
1D09: goto 1D0E
1D0A: 74 DD              DOFF    EA,BC
1D0C: return 0;
1D0D: goto 1D13
1D0E: EA &= BC;
1D10: 74 FD              DEQ     EA,BC
1D12: return 1;
1D13: AF 02              LDAX    (HL+$02)
1D15: 57 01              OFFI    A,$01
1D17: return 1;
1D18: A = [HL];
1D19: 77 20              EQI     A,$20
1D1B: return 0;
1D1C: A = EAL;
1D1D: 57 10              OFFI    A,$10
1D1F: return 0;
1D20: return 1;
1D21: 5B 05              BIT     3,VV:05
1D23: return 0;
1D24: AF 02              LDAX    (HL+$02)
1D26: 57 01              OFFI    A,$01
1D28: return 0;
1D29: A = [HL];
1D2A: 77 20              EQI     A,$20
1D2C: return 0;
1D2D: DE = [0x9945];
1D31: EA = DE;
1D32: 74 BF              DLT     EA,HL
1D34: return 0;
1D35: return 1;
1D36: A = [HL];
1D37: 48 8F 01           LDEAX   (HL+$01)
1D3A: BC = EA;
1D3B: goto 22C9
1D3E: 40 21 1D           CALL    $1D21
1D41: goto 1D36
1D42: BC = [0x9953];
1D46: DE = [0x9836];
1D4A: EA = 0x0000;
1D4D: 74 EE              DNE     EA,DE
1D4F: goto 1D6B
1D50: goto 1D65
1D51: 40 21 1D           CALL    $1D21
1D54: goto 1D36
1D55: BC = [0x9953];
1D59: DE = [0x9835];
1D5D: EA = DE;
1D5E: DE = [0x9836];
1D62: 74 FE              DEQ     EA,DE
1D64: goto 1D6B
1D65: 23                 DCX     DE
1D66: [0x9836] = DE;
1D6A: 12                 INX     BC
1D6B: A = VV[0x25];
1D6D: A5                 DMOV    EA,BC
1D6E: 84                 CALT    ($0088)
1D6F: DE = [0x9835];
1D73: 23                 DCX     DE
1D74: [0x9835] = DE;
1D78: return 0;
1D79: HL = [0x993D];
1D7D: EA = HL;
1D7E: HL = [0x9901];
1D82: EA -= HL;
1D84: return 0;
1D85: HL = [0x9925];
1D89: [0xC005] = HL;
1D8D: 64 83 07           MVI     EOM,$07
1D90: 4C E1              MOV     A,CR1
1D92: EA = 0x0000;
1D95: EAL = A;
1D96: 48 A4              DSLL    EA
1D98: 37 DB              LTI     A,$DB
1D9A: goto 1DA2
1D9B: EA += A;
1D9D: BC = EA;
1D9E: EA = [0x0434];
1DA1: goto 1DAB
1DA2: 37 FB              LTI     A,$FB
1DA4: goto 7867;
1DA7: BC = EA;
1DA8: EA = [0x035E];
1DAB: EA -= BC;
1DAD: BC = EA;
1DAE: 48 C0              DMOV    EA,ECNT
1DB0: 74 C5              DADD    EA,BC
1DB2: BC = [0x9923];
1DB6: 74 BD              DLT     EA,BC
1DB8: EA -= BC;
1DBA: ETM0 = EA;
1DBC: 5D 10              BIT     5,VV:10
1DBE: goto 1DCC
1DBF: HL = [0x9923];
1DC3: EA = HL;
1DC4: 48 D3              DMOV    ETM1,EA
1DC6: 48 46              SKIT    FE1
1DC8: 00                 NOP     
1DC9: VV[0x10] &= 0xDF;
1DCC: 11                 EXX     
1DCD: 10                 EXA     
1DCE: enable_interrupts();
1DCF: push(EA);
1DD0: push(HL);
1DD1: push(VA);
1DD2: push(BC);
1DD3: push(DE);
1DD4: 40 22 23           CALL    $2322
1DD7: 40 46 1E           CALL    $1E46
1DDA: 40 5E 1E           CALL    $1E5E
1DDD: DE = pop();
1DDE: BC = pop();
1DDF: VA = pop();
1DE0: HL = pop();
1DE1: EA = pop();
1DE2: return; /* FROM INTERRUPT */
1DE3: HL = [0x9925];
1DE7: [0xC005] = HL;
1DEB: 64 83 07           MVI     EOM,$07
1DEE: 4C E1              MOV     A,CR1
1DF0: EA = 0x0000;
1DF3: EAL = A;
1DF4: 48 A4              DSLL    EA
1DF6: 37 DB              LTI     A,$DB
1DF8: goto 1E05
1DF9: 27 D0              GTI     A,$D0
1DFB: EA = [0x01A0];
1DFE: EA += A;
1E00: BC = EA;
1E01: EA = [0x0410];
1E04: goto 1E0E
1E05: 37 FB              LTI     A,$FB
1E07: goto 7867;
1E0A: BC = EA;
1E0B: EA = [0x0339];
1E0E: EA -= BC;
1E10: BC = EA;
1E11: 48 C0              DMOV    EA,ECNT
1E13: 74 C5              DADD    EA,BC
1E15: BC = [0x9923];
1E19: 74 BD              DLT     EA,BC
1E1B: EA -= BC;
1E1D: ETM0 = EA;
1E1F: 5D 10              BIT     5,VV:10
1E21: goto 1E2F
1E22: HL = [0x9923];
1E26: EA = HL;
1E27: 48 D3              DMOV    ETM1,EA
1E29: 48 46              SKIT    FE1
1E2B: 00                 NOP     
1E2C: VV[0x10] &= 0xDF;
1E2F: 11                 EXX     
1E30: 10                 EXA     
1E31: enable_interrupts();
1E32: push(EA);
1E33: push(HL);
1E34: push(VA);
1E35: push(BC);
1E36: push(DE);
1E37: 40 22 23           CALL    $2322
1E3A: 40 46 1E           CALL    $1E46
1E3D: 40 5E 1E           CALL    $1E5E
1E40: DE = pop();
1E41: BC = pop();
1E42: VA = pop();
1E43: HL = pop();
1E44: EA = pop();
1E45: return; /* FROM INTERRUPT */
1E46: MKL |= 0x40; /* 0100 0000 */ /* mask INTE1 */
1E49: 48 45              SKIT    FE0
1E4B: 00                 NOP     
1E4C: MKL &= 0xdf; /* 1101 1111 */ /* activate INTE0 */
1E4F: HL = 0x1E78;
1E52: [0x981B] = HL;
1E56: HL = 0x7A04;
1E59: [0x9818] = HL;
1E5D: return 0;
1E5E: 55 10 02           OFFIW   VV:10,$02
1E61: 30 29              DCRW    VV:29
1E63: return 0;
1E64: VV[0x29] = 0x02;
1E67: HL = [0x9923];
1E6B: EA = HL;
1E6C: 5F 12              BIT     7,VV:12
1E6E: goto 1E74
1E6F: EA++;
1E70: 5E 12              BIT     6,VV:12
1E72: EA++;
1E73: goto 1E75
1E74: A9                 DCX     EA
1E75: 48 D3              DMOV    ETM1,EA
1E77: return 0;
1E78: MKL |= 0x20; /* 0010 0000 */ /* mask INTE0 */
1E7B: 64 83 99           MVI     EOM,$99
1E7E: HL = 0x0000;
1E81: [0xC005] = HL;
1E85: VV[0x10] &= 0x7D;
1E88: VV[0x0F] &= 0xFD;
1E8B: 11                 EXX     
1E8C: 10                 EXA     
1E8D: enable_interrupts();
1E8E: return; /* FROM INTERRUPT */
1E8F: BC = [0x9921];
1E93: A5                 DMOV    EA,BC
1E94: BC = [0x9927];
1E98: 74 C5              DADD    EA,BC
1E9A: 48 D3              DMOV    ETM1,EA
1E9C: EA++;
1E9D: EA++;
1E9E: ETM0 = EA;
1EA0: 55 06 10           OFFIW   VV:06,$10
1EA3: goto 1EB3
1EA4: HL = 0x1D85;
1EA7: [0x981B] = HL;
1EAB: HL = 0x7A5A;
1EAE: [0x9818] = HL;
1EB2: goto 1EC1
1EB3: HL = 0x1DE3;
1EB6: [0x981B] = HL;
1EBA: HL = 0x7A5A;
1EBD: [0x9818] = HL;
1EC1:
	ETMM = 0x0c; /* 0000 1100 */ /*  */
1EC5: VV[0x10] |= 0x20
1EC8: 48 46              SKIT    FE1
1ECA: 00                 NOP     
1ECB: 48 45              SKIT    FE0
1ECD: 00                 NOP     
1ECE: 40 22 23           CALL    $2322
1ED1: 00                 NOP     
1ED2: MKL &= 0xbf; /* 1011 1111 */ /* activate INTE1 */
1ED5: VV[0x10] |= 0x80
1ED8: return 0;
1ED9: 40 11 1F           CALL    $1F11
1EDC: HL = 0x9000;
1EDF: [0x995D] = HL;
1EE3: [0x995F] = HL;
1EE7: HL = 0x0000;
1EEA: [0x9925] = HL;
1EEE: 55 00 04           OFFIW   VV:00,$04
1EF1: 40 D2 2A           CALL    $2AD2
1EF4: 59 09              BIT     1,VV:09
1EF6: A = 0x00;
1EF8: A = 0x1E;
1EFA: VV[0x3E] = A;
1EFC: 92                 CALT    ($00A4)
1EFD: 40 2D 1F           CALL    $1F2D
1F00: 40 4C 23           CALL    $234C
1F03: goto 1F05
1F04: goto 1F00
1F05: 5A 00              BIT     2,VV:00
1F07: 40 D2 2A           CALL    $2AD2
1F0A: return 0;
1F0B:
	func_2089(); /* always returns 0 */
1F0C: 55 0F 02           OFFIW   VV:0F,$02
1F0F: goto 1F0B
1F10: return 0;
1F11: HL = [0x9933];
1F15: 5A 00              BIT     2,VV:00
1F17: goto 1F28
1F18: DE = [0x9935];
1F1C: EA = DE;
1F1D: HL--;
1F1E: HL--;
1F1F: HL--;
1F20: [0x9935] = HL;
1F24: HL = EA;
1F25: HL--;
1F26: HL--;
1F27: HL--;
1F28: [0x9937] = HL;
1F2C: return 0;
1F2D: func_1F75();
1F30: 5A 00              BIT     2,VV:00
1F32: goto 1F49
1F33: HL = [0x990D];
1F37: EA = HL;
1F38: 70 61              ESUB    EA,A
1F3A: A = 0x18;
1F3C: 48 3D              DIV     A
1F3E: EA = [0x0018];
1F41: 77 00              EQI     A,$00
1F43: 48 A4              DSLL    EA
1F45: 70 61              ESUB    EA,A
1F47: BC = EA;
1F48: goto 1F57
1F49: HL = [0x990B];
1F4D: EA = HL;
1F4E: EA += A;
1F50: C = 0x18;
1F52: 48 3F              DIV     C
1F54: C += 0x18;
1F57: 40 93 1F           CALL    $1F93
1F5A: EA = A * C;
1F5C: HL = 0x9927;
1F5F: [HL] = EA;
1F61: VV[0x29] = 0x02;
1F64: 5F 12              BIT     7,VV:12
1F66: goto 1F6E
1F67: 55 12 20           OFFIW   VV:12,$20
1F6A: VV[0x10] |= 0x02
1F6D: goto 1F74
1F6E: 55 07 40           OFFIW   VV:07,$40
1F71: VV[0x10] |= 0x02
1F74: return 0;

void func_1F75(void)
{
	if (VV[0x00] & 0x02) HL = 0x9850;
	else                 HL = 0x1F89;
	A = [HL+[9820]];
	if (VV[0x00] & 0x04)
		A += VV[0x25];
	return;
}

1F89: DW: 0A 01 10 0A 01 2D 20 39 2D 20 34 9A 1F 01 20 AC
1F99: DW: B8 39 73 24 2B 56

int func_1F9F(void)
{
	if (234C())
		return 1;
	if (VV[0x40] & 0x40)
		return 1;
	if (!VV[0x3e]--)
		return 0;
	VV[0x3e] = 0x00;
	return 1;
}

1FAE:
	55 06 10           OFFIW   VV:06,$10
	goto 1FEA;
59 09              BIT     1,VV:09
55 09 04           OFFIW   VV:09,$04
	goto 1FC9;
55 07 40           OFFIW   VV:07,$40
	goto 1FCC;
	if (VV[0x07] & 0x20) HL = 0x200b;
	if (VV[0x08] & 0x04) HL = 0x200b;
	HL = 0x2007;
1FC9: HL = 0x200f;
1FCC: HL = 0x2013;
1FCF: A = [HL++];

	push(VA);
	A &= 0x7f; /* 0111 1111 */
	VV[0x20] = A;
	A = [HL++];
	VV[0x25] = A;
	EA = [HL];
	HL = 0x9923;
	[HL] = EA;
	VA = pop();
	if (A & 0x80) HL = 0xc006;
	else          HL = 0xc005;
	A = [HL];
	return;

1FEA:
	59 09              BIT     1,VV:09
	55 09 04           OFFIW   VV:09,$04
	goto 2001;
	55 07 40           OFFIW   VV:07,$40
	goto 1FCC;
	5D 07              BIT     5,VV:07
	55 08 04           OFFIW   VV:08,$04
	HL = 0x2017;
	HL = 0x201b;
	2001: HL = 0x201f;
	54 CF 1F           JMP     1FCF

2007: 80                 CALT    ($0080)
2008: A = D;
2009: push(VA);
200A: 02                 INX     SP
200B: A = VV[0x0C];
200D: 60 05              illegal 
200F: 81                 CALT    ($0082)
2010: 06                 illegal 
2011: push(VA);
2012: 02                 INX     SP
2013: 82                 CALT    ($0084)
2014: 10                 EXA     
2015: 40 02 04           CALL    $0402
2018: A = D;
2019: 00                 NOP     
201A: SP = 0x0C83;
201D: 00                 NOP     
201E: 02                 INX     SP
201F: 84                 CALT    ($0088)
2020: 06                 illegal 
2021: 00                 NOP     
2022: 02                 INX     SP
2023: HL = 0x9911;
2026: EA = [0x8000];
2029: 48 95              STEAX   (HL++)
202B: 48 95              STEAX   (HL++)
202D: EA = [0x1000];
2030: [HL] = EA;
2032: return;
2033: 45 11 80           ONIW    VV:11,$80
2036: return 0;
2037: HL = 0xC001;
203A: A = [HL];
203B: 70 FB              EQAX    (HL)
203D: goto 203A
203E: C = 0x4E;
2040: 47 01              ONI     A,$01
2042: 74 0B FB           ANI     C,$FB
2045: 47 10              ONI     A,$10
2047: C |= 0x10;
204A: 47 08              ONI     A,$08
204C: C |= 0x20;
204F: 07 66              ANI     A,$66
2051: A >>= 1;
2053: B = A;
2054: 07 03              ANI     A,$03
2056: 48 22              SLR     B
2058: 48 22              SLR     B
205A: A |= B;
205C: 27 03              GTI     A,$03
205E: C |= 0x01;
2061: HL = 0x2079;
2064: A = [HL+A];
2065: 4D DA              MOV     TM0,A
2067: A = C;
2068: 4D CA              MOV     SML,A
206A: A = 0x0C;
206C: 4D C9              MOV     SMH,A
206E: A = 0x93;
2070: 4D CD              MOV     TMM,A
2072: 64 8D EC           ANI     TMM,$EC
2075: 48 4B              SKIT    ER
2077: 00                 NOP     
2078: return 0;
2079: 80                 CALT    ($0080)
207A: 57 47              OFFI    A,$47
207C: 40 C0 80           CALL    $80C0
207F: 40 20 15           CALL    $1520
2082: 10                 EXA     
2083: A = EAH;
2084: SP = 0x2080;
2087: 10                 EXA     
###00002088: SP = 0x115F;

/* always returns 0 */
void func_2089(void)
{
	if ( (VV[0x11] & 0x80)) return;
	if (!(VV[0x11] & 0x40)) return;
	if ( (VV[0x11] & 0x20)) return;
	if (!([0xC002] & 0x80)) return;

	disable_interrupts();
	EA = [0xc002];
	A  = [0xc004];
	[0xc004] = (A |= 0x20); /* 0010 0000 */
	[0xc004] = (A &= 0xfe); /* 1111 1110 */
	enable_interrupts();
	[0xc004] = (A &= 0xdf); /* 1101 1111 */
	DE = [0x9911];
	[DE++] = EAH;
	rollover_DE_from_0x9000_to_0x8000();
	[0x9911] = DE;
	disable_interrupts();
	[0x9915]--;
	if (EA == 0x0000) {
		VV[0x11] |= 0x02;
		[0xC004] &= 0xFD; /* 1111 1101 */
	}
	enable_interrupts();
}

20CE:
	push(VA);
	A = RXB;
	MKH |= 0x02; /* 0000 0010 */
	enable_interrupts();
	59 11              BIT     1,VV:11
	48 6B              SKNIT   ER
	goto 210D
	push(EA);
	push(DE);
	push(HL);
	DE = [0x9911];
	[DE++] = A;
	rollover_DE_from_0x9000_to_0x8000();
	[0x9911] = DE;
	disable_interrupts();
	DE = 0x9915;
	EA = [DE];
	A9                 DCX     EA
	[DE] = EA;
	HL = 0x0000;
	74 EF              DNE     EA,HL
	VV[0x11] |= 0x02
	enable_interrupts();
	HL = 0x0100;
	74 FF              DEQ     EA,HL
	goto 210A
	VV[0x11] |= 0x40
	40 0C 23           CALL    $230C
	A = 0x13;
	TXB = A;
210A:
	HL = pop();
	DE = pop();
	EA = pop();
210D:
	VA = pop();
	MKH &= 0xfd; /* 1111 1101 */
	return; /* FROM INTERRUPT */

2112:
	40 A5 0E           CALL    $0EA5
	func_2089(); /* always returns 0 */

2116:
	if (func_2127())
		return 0;
	goto 2112;

211B:
int func_211B(void)
{
	return ([0x9915] == 0x1000);
}

2127:
	MKH |= 0x02; /* 0000 0010 */
	if (func_211B()) {
		MKH &= 0xfd; /* 1111 1101 */
		return 0;
	}
	DE = 0x9915;
	EA = [DE];
	EA++;
	[DE] = EA;
	VV[0x11] &= 0xFD;
	5F 11              BIT     7,VV:11
	40 08 23           CALL    $2308
	DE = [0x9913];
	A = [DE++];
	VV[0x15] = A;
	rollover_DE_from_0x9000_to_0x8000();
	[0x9913] = DE;
	MKH &= 0xfd; /* 1111 1101 */
	5E 11              BIT     6,VV:11
	goto 2169
	DE = 0x9915;
	EA = [DE];
	HL = 0x0210;
	if (EA != HL)
		goto 2169;
	VV[0x11] &= 0xbf; /* 1011 1111 */
	A = 0x11;
	TXB = A;
	40 05 23           CALL    $2305
2169:
	40 E9 2F           CALL    $2FE9
	A = VV[0x15];
	return 1;

216F: HL = [0x9901];
2173: [0x9903] = HL;
2177: VV[0x03] |= 0x08
217A: VV[0x11] &= 0xC3;
217D: HL = 0x0000;
2180: [0x9947] = HL;
	VV[0x33] = 0x00;
2187: HL = 0x9A79;
218A: [0x9945] = HL;
218E: 58 11              BIT     0,VV:11
2190: goto 21EE
2192: DE = [0x9951];
2196: EA = DE;
2197: DE = [0x9939];
219B: DE++;
219C: DE++;
219D: DE++;
219E: EA -= DE;
21A0: A = 0x03;
21A2: 48 3D              DIV     A
21A4: BC = EA;
21A5: HL = 0x9A79;
21A8: EA = 0x0000;
21AB: goto 21DC
21AD: push(BC);
21AE: push(EA);
21AF: A = [DE++];
21B0: 48 84              LDEAX   (DE++)
21B2: 77 20              EQI     A,$20
21B4: goto 21B9
21B5: EA = pop();
21B6: BC = pop();
21B7: goto 21DC
21B9: 3D                 STAX    (HL+)
21BA: push(VA);
21BB: 59 02              BIT     1,VV:02
21BD: goto 21C2
21BE: A = EAL;
21BF: 07 F7              ANI     A,$F7
21C1: EAL = A;
21C2: 48 95              STEAX   (HL++)
21C4: VV[0x03] &= 0xF7;
21C7: A = EAH;
21C8: 57 10              OFFI    A,$10
21CA: VV[0x11] |= 0x10
21CD: A = EAL;
21CE: 57 20              OFFI    A,$20
21D0: VV[0x11] |= 0x08
21D3: VA = pop();
21D4: BC = EA;
21D5: 40 C9 22           CALL    $22C9
21D8: BC = pop();
21D9: 74 C5              DADD    EA,BC
21DB: BC = pop();
21DC: 53                 DCR     C
21DD: goto 21AD
21DF: DE = [0x9905];
21E3: [0x9903] = DE;
21E7: EA += DE;
21E9: DE = EA;
21EA: [0x9901] = DE;
21EE: [0x9939] = HL;
21F2: return 0;

void rollover_DE_from_0x9000_to_0x8000(void)
{
	EA = 0x9000;
	if (EA == DE)
		DE = 0x8000;
}

void rollover_DE_from_0x7fff_to_0x8fff(void)
{
	EA = 0x7fff;
	if (EA == DE)
		DE = 0x8fff;
}

2205: BC = [0x9939];
2209: EA = 0x9DA9;
220C: 74 AD              DGT     EA,BC
220E: return 0;
220F: return 1;
2210: HL = [0x9939];
2214: EA = 0x9A79;
2217: 74 BF              DLT     EA,HL
2219: return 1;
221A: return 0;

221B:
	40 05 22           CALL    $2205
	8B                 CALT    ($0096)
	VV[0x03] &= 0x7f;
	HL = 0x9901;
	EA = [HL];
	DE = [0x993b];
	EA += DE;
	[HL] = EA;
	if (VV[0x09] & 0x10)
		VV[0x11] |= 0x10;
	if (VV[0x08] & 0x20)
		VV[0x11] |= 0x08;
	HL = 0x9808;
	EA = [HL];
	HL = [0x9939];
	A = VV[0x15];
	if (VV[0x05] & 0x80)
		func_2254();
	[HL++] = A;
	[HL++] = EA; /* uint16_t */
	[0x9939] = HL;
	return 0;

void func_2254(void)
{
	if (A != 0x20) {
		if (VV[0x03] & 0x08) {
			[0x9945] = HL;
			return 0;
		}
		push(EA);
		push(HL);
		HL = 0x9947;
		EA = [HL];
		EA += DE;
		[HL] = EA;
		VV[0x33]++; /* skip on carry? */
		HL = pop();
		EA = pop();
	}
	VV[0x03] &= 0xf7; /* 1111 0111 */
	return 0;
}

int func_2272(void)
{
	EA = [0x9935];
	HL = [0x9937];
	if (EA == HL)
		return 0;
	if (VV[0x00] & 0x04) {
		A  = [HL++];
		EA = [HL  ];
		HL -= 4;
	} else {
		A  = [HL++];
		EA = [HL++];
	}
	[0x9937] = HL;
	return 1;
}

2291: push(EA);
2292: 40 05 22           CALL    $2205
2295: 8B                 CALT    ($0096)
2296: EA = pop();
2297: 55 07 40           OFFIW   VV:07,$40
229A: VV[0x11] |= 0x20
229D: A = VV[0x09];
229F: A |= 0x01;
22A1: HL = [0x9939];
22A5: 48 95              STEAX   (HL++)
22A7: 3D                 STAX    (HL+)
22A8: [0x9939] = HL;
22AC: [0x9945] = HL;
22B0: HL = 0x9901;
22B3: EA = [HL];
22B5: DE = [0x993B];
22B9: EA += DE;
22BB: [HL] = EA;
22BD: HL = 0x0000;
22C0: [0x9833] = HL;
22C4: [0x9947] = HL;
22C8: return 0;
22C9: push(BC);
22CA: func_22E6(); /* always returns 0 */
22CD: 55 07 40           OFFIW   VV:07,$40
22D0: goto 22D8
22D1: 74 5A 04           OFFI    B,$04
22D4: A = 0x06;
22D6: A = 0x0C;
22D8: A = 0x10;
22DA: 84                 CALT    ($0088)
22DB: BC = pop();
22DC: 74 5A 01           OFFI    B,$01
22DF: return 0;
22E0: 74 5B 08           OFFI    C,$08
22E3: 48 A4              DSLL    EA
22E5: return 0;

void func_22E6(void)
{
	if (B & 0x01) {
		EAL = A;
		A = C;
		EAH = A;
		return 0;
	}
	if      (VV[0x07] & 0x40) A = 0x09;
	else if (C & 0x80)        A = 0x0A;
	else                      A = 0x0C;
	if (B & 0x04)
		A += 2;
	EA = 0x0000;
	EAL = A;
	return 0;
}

2305:
	[0xC004] &= 0xFE;
2308:
	[0xC004] |= 0x02;
	return 0;

230C:
	[0xC004] |= 0x01;
	return 0;
2313:
	HL = 0x0400;
	[0x995B] = HL;
	memset(0x9000, 0x00, 0x07fe);
	return 0;

2322:
	55 12 80           OFFIW   VV:12,$80
	goto 125C;
	DE = [0x995B];
	EA = [DE];
	HL = 0x0400;
	74 EF              DNE     EA,HL
	return 0;
	EA++;
	[DE] = EA;
	DE = [0x995F];
	EA = [DE];
	HL = 0x9925;
	[HL] = EA;
	EA = 0x0000;
	[DE++] = EA;
	9A                 CALT    ($00B4)
	[0x995F] = DE;
	return 1;

234C:
	VV[0x40] &= 0xBF;
	EA = 0x0100;
	DE = [0x995B];
74 AE              DGT     EA,DE
	goto 235D;
	VV[0x40] |= 0x40;
	return 1;
235D:
	55 40 10           OFFIW   VV:40,0x10
	goto 237A;
	VV[0x40] = 0x00;
	A = 0x00;
	[0xc000] = A;
	VV[0x3c] = A;
	VV[0x3d] = A;
	if (!func_2272())
		return 0;
	HL = 0x9837;
	[HL++] =  A;
	[HL  ] = EA; /* VV[0x38] */
	BC = EA;
237A:
	func_2436();
	goto 23A0
	37 B0              LTI     A,$B0
	37 B3              LTI     A,$B3
	goto 2387;
	VV[0x40] |= 0x80;
2387:
	func_22E6(); /* always returns 0 */
	55 39 02           OFFIW   VV:39,$02
	48 25              SLL     A
	VV[0x3A] = A;
	40 D0 24           CALL    $24D0
	HL = 0x9965;
	func_2686(); /* always returns 0 */
	func_25EF(); /* always returns 0 */
	40 2A 26           CALL    $262A
23A0:
	A = VV[0x3A];
	36 01              SUINB   A,$01
	return 1;
	A += VV[0x3D];
	VV[0x3A] = A;
	DE = [0x995D];
	if (VV[0x37] == ' ')
		goto 23DE
	5A 00              BIT     2,VV:00
	goto 23C7
	40 18 24           CALL    $2418
	HL = [0x9959];
23BD:
	HL--;
	HL--;
	EA = [HL];
	BC = EA;
	40 F1 23           CALL    $23F1
	goto 23BD
	goto 23D9
23C7:
	58 40              BIT     0,VV:40
	HL = 0x9965;
	HL = 0x99ED;
23CF:
	48 85              LDEAX   (HL++)
	BC = EA;
40 F1 23           CALL    $23F1
23D5: goto 23CF
23D6: 40 18 24           CALL    $2418
23D9: [0x995D] = DE;
23DD: return 1;
23DE: 55 00 04           OFFIW   VV:00,$04
23E1: 40 18 24           CALL    $2418
23E4: BC = [0x0000];
23E7: 40 F1 23           CALL    $23F1
23EA: goto 23E4
23EB: 5A 00              BIT     2,VV:00
23ED: 40 18 24           CALL    $2418
23F0: goto 23D9
23F1: 5C 38              BIT     4,VV:38
23F3: goto 2405
23F4: 55 38 04           OFFIW   VV:38,$04
23F7: goto 2403
23F8: 5A 00              BIT     2,VV:00
23FA: goto 2400
23FB: 74 5D 02           OFFI    E,$02
23FE: goto 2403
23FF: goto 2405
2400: 74 4D 02           ONI     E,$02
2403: C = 0x80;
2405: EA = [DE];
2407: EA |= BC;
2409: [DE++] = EA;
240B: 9A                 CALT    ($00B4)
240C: push(HL);
240D: HL = 0x995B;
2410: disable_interrupts();
2411: [HL]--;
2412: enable_interrupts();
2413: HL = pop();
2414: 30 3A              DCRW    VV:3A
2416: return 0;
2417: return 1;
2418: A = VV[0x3D];
241A: goto 2428
241B: 23                 DCX     DE
241C: 23                 DCX     DE
241D: 9A                 CALT    ($00B4)
241E: HL = 0x995B;
2421: disable_interrupts();
2422: EA = [HL];
2424: EA++;
2425: [HL] = EA;
2427: enable_interrupts();
2428: 51                 DCR     A
2429: goto 241B
242A: return 0;
242B: 74 6C 98           NEI     D,$98
242E: D = 0x90;
2430: 74 6C 8F           NEI     D,$8F
2433: D = 0x97;
2435: return 0;

2436: 5C 40              BIT     4,VV:40
2438: goto 243F;
2439: BC = [0x9961];
243D: goto 2482;
243F: 58 39              BIT     0,VV:39
2441: 55 10 50           OFFIW   VV:10,$50
	VV[0x38] &= 0xef;
2447: 58 39              BIT     0,VV:39
2449: goto 2457;
244A: BC = [0x9837];
244E: A5                 DMOV    EA,BC
244F: 55 39 02           OFFIW   VV:39,$02
2452: 48 A4              DSLL    EA
2454: BC = EA;
2455: goto 2482;
2457: 55 05 08           OFFIW   VV:05,$08
245A: 77 20              EQI     A,$20
245C: goto 2462;
245D: 40 A0 24           CALL    $24A0
2460: goto 2482;
2462: 67 20              NEI     A,$20
2464: goto 2472;
2465: 5C 10              BIT     4,VV:10
2467: goto 246B;
2468: 5C 39              BIT     4,VV:39
246A: goto 2472;
246B: 55 10 40           OFFIW   VV:10,$40
246E: 55 38 20           OFFIW   VV:38,$20
2471: return 1;
2472: func_22E6(); /* always returns 0 */
2475: 55 39 02           OFFIW   VV:39,$02
2478: 48 25              SLL     A
247A: 55 38 08           OFFIW   VV:38,$08
247D: 48 25              SLL     A
247F: C = A;
2480: B = 0x00;
2482: 74 7A 00           EQI     B,$00
2485: goto 248B
2486: VV[0x40] &= 0xEF;
2489: A = C;
248A: goto 2490
248B: VV[0x40] |= 0x10
248E: A = 0xFF;
2490: 60 33              SUBNB   C,A
2492: 52                 DCR     B
2493: 70 1E 61 99        SBCD    $9961
2497: VV[0x3A] = A;
2499: VV[0x3d] = 0x00;
249C: VV[0x37] = ' ';
249F: return 0;
24A0: HL = 0x9937;
24A3: EA = [HL];
24A5: 5A 00              BIT     2,VV:00
24A7: goto 24AC
24A8: EA++;
24A9: EA++;
24AA: EA++;
24AB: goto 24AF
24AC: A9                 DCX     EA
24AD: A9                 DCX     EA
24AE: A9                 DCX     EA
24AF: HL = [0x9945];
24B3: 74 AF              DGT     EA,HL
24B5: return 1;
24B6: HL = 0x9953;
24B9: EA = [HL];
24BB: 5A 00              BIT     2,VV:00
24BD: goto 24C7
24BE: A = VV[0x35];
24C0: 74 A8 36           GTAW    VV:36
24C3: EA++;
24C4: 30 35              DCRW    VV:35
24C6: goto 24CE
24C7: 65 36 00           NEIW    VV:36,$00
24CA: goto 24CE
24CB: EA++;
24CC: 30 36              DCRW    VV:36
24CE: BC = EA;
24CF: return 0;

24D0:
	if (VV[0x38] & 0x02) {
		B = [0x9837];
		B -= 0x3a;
		func_1AC2(); /* always returns 0 */
		if (VV[0x39] & 0x02) {
			A = [HL++];
			VV[0x3B] = A;
			VV[0x3C] = 0x00;
			EA = 0x000E;
			EA += HL;
			DE = 0x26E9;
			if (!(VV[0x38] & 0x80))
				DE = 0x26E8;
			[0x9963] = DE;
			B = 0x80;
			goto 2818;
		}
		VV[0x3B] = 0x0B;
		A = [HL++];
		if (!(A & 0x80))
			VV[0x40] |= 0x02;
		EA = [0x2000];
		func_25E2(EA); /* always returns 0 */
		goto 27C9;
	}
	A = VV[0x37];
	EA = 0x3401; /* IMPORTANT */
	if (!(VV[0x38] & 0x40))
		EA = 0x3301;
	HL = EA = [EA + 2*A];
	VV[CHARTABLE_FIELD_1] = [HL++];
	if (!(VV[0x39] & 0x02) || (VV[0x38] & 0x01) || !(VV[CHARTABLE_FIELD_1] & 0x02))
		goto 250A;
	func_25C9(0xFC); /* always returns 0 */
	func_26A6(); /* always returns 0 */
	func_26B0(); /* always returns 0 */
	EA = HL;
	A = VV[0x3b];
	if (B & 0x80)
		A += 0x03;
	EA += A;
	goto 2818;
250A:
	A = [HL];
	if (!(A & 0x80))
		VV[0x40] |= 0x02;
	if (VV[0x39] & 0x02 || !(VV[0x39] & 0x80) || !(VV[CHARTABLE_FIELD_1] & 0x08)) {
		if (VV[0x07] & 0x40 || !(VV[CHARTABLE_FIELD_1] & 0x10)) {
			if (!(VV[CHARTABLE_FIELD_1] & 0x20) || (!(VV[0x07] & 0x40) && (VV[0x38] & 0x80))) {
				HL++;
				if (!(VV[CHARTABLE_FIELD_1] & 0x40)) {
					VV[0x3B] = 0x09;
					HL++;
					A = [HL++];
					func_25E2(A); /* always returns 0 */ /* lower byte only */
					goto 27C9;
				}
				VV[0x3B] = 0x0B;
				A = [HL++];
				if (VV[0x40] & 0x80) {
					func_25E2(A); /* always returns 0 */ /* lower byte only */
					goto 27C9;
				}
				if (VV[0x38] & 0x80) {
					EA = 0x6000;
					func_25E2(EA); /* always returns 0 */
					goto 27C9;
				}
				if (VV[0x38] & 0x04 || !(VV[0x07] & 0x40)) {
					func_25E2(A); /* always returns 0 */ /* lower byte only */
					goto 27C9;
				}
				EA = 0x2000;
				EAL = A;
				func_25E2(EA); /* always returns 0 */
				goto 27C9;
			}
			VV[0x3B] = 0x09;
			func_25C9(0xC0); /* always returns 0 */
			goto 27C9;
		}
		VV[0x3B] = 0x08;
		func_25C9(0xE0); /* always returns 0 */
		goto 27C9;
	}
	if (!(VV[CHARTABLE_FIELD_1] & 0x04) || (!(VV[0x07] & 0x40) && !(VV[0x38] & 0x80))) {
		func_25C9(0xF0); /* always returns 0 */
		VV[0x3B] = 0x09;
		HL++;
		A = [HL++];
		func_25E2(A); /* always returns 0 */ /* lower byte only */
		goto 27C9;
	}
	VV[0x3B] = 0x08;
	func_25C9(0xF8); /* always returns 0 */
	goto 27C9;

/* always returns 0 */
void func_25C9(uint8_t A)
{
	const uint8_t local_var[6] = { 0x0C, 0x0D, 0x09, 0x08, 0x0B, 0x08 };
	A &= VV[CHARTABLE_FIELD_1];
	A ^= 0xff;
	B = A;
	EA = HL;
	for (int i = 0; i < 6; i++) {
		A = local_var[i];
		if (B & 0x80)
			EA += A;
		B <<= 1;
	}
	HL = EA;
	return 0;
}
/* always returns 0 */
void func_25E2(EA)
{
	if (!(VV[0x07] & 0x40))
		if (!(VV[0x38] & 0x80))
			return;
	[C001] = EA;
	return;
}
/* always returns 0 */
void func_25EF(void)
{
	if (!(VV[0x38] & 0x0c))
		return 0;
	EA = 0x0000;
	DE = [0x9959];
	[DE++] = EA;
	[DE  ] = EA;
	HL = 0x9965;
	DE = [0x99ED];
	push(DE);
	VV[0x40] |= 0x01
	A = VV[0x3a];
	B = A;
	if (VV[0x38] & 0x08)
		A <<= 1, A &= borrow;
	VV[0x3a] = A;
	A = B + VV[0x3d];
	BC = 0x0000;
	if (!(VV[0x39] & 0x02) || !(VV[0x38] & 0x04)) {
		func_28BC(); /* always returns 0 */
	} else {
		func_28BF(); /* always returns 1, already skipped */
	}
	HL = pop();
	func_2686(); /* always returns 0 */
	return 0;
}

262A:
	55 39 02           OFFIW   VV:39,$02
	5F 39              BIT     7,VV:39
	return 0;
	if (VV[0x40] & 0x01) {
		DE = 0x9965;
		HL = 0x99ED;
	} else {
		DE = 0x99ED;
		HL = 0x9965;
	}
	push(HL);
	push(HL);
	push(DE);
	A = VV[0x3A];
	A += VV[0x3D];
	51                 DCR     A
	VV[0x3B] = A;
	C = A;
264C:
	HL++;
	A = [HL++];
	[DE++] = A;
	53                 DCR     C
	goto 264C
	HL = pop();
	EA = [0x0044];
	EA += HL;
	BC = [0x0042];
	{ memset(EA, 0x00, B*255+C); A = 0x00; }
	push(EA);
	B = 0x01;
265E:
	EA++;
	DE = EA;
	push(HL);
	A = VV[0x3B];
	C = A;
2664:
	A = [HL++];
	60 8A              ANA     A,B
	70 9A              ORAX    (DE)
	[DE++] = A;
	53                 DCR     C
	goto 2664
	HL = pop();
	48 26              SLL     B
	48 0A              SK      CY
	goto 265E
	HL = pop();
	DE = pop();
	A = VV[0x3B];
	C = A;
2677:
	A = [HL++];
	DE++;
	[DE++] = A;
	53                 DCR     C
	goto 2677
	C = 0x07;
	[DE++] = 0x00;
	[DE++] = [HL++];
	53                 DCR     C
	goto 267E
	HL = pop();
	func_2686(); /* always returns 0 */
	return 0;

/* always returns 0 */
void func_2686(void)
{
	[C000] = 0x00;
	EA = DE - HL;
	B = EAL >> 1;
	A = VV[0x3a];
	if (A >= B) {
		A -= B;
		if (A--)
			func_2AEA(); /* always returns 0 */
	} else {
		A -= B;
		A = ~A + 1; /* negate */
		VV[0x3d] = A;
	}
	[0x9959] = DE;
	return 0;
}
/* always returns 0 */
void func_26A6(void)
{
	B = A = [HL++];
	A &= 0x1f; /* 0001 1111 */
	VV[0x3C] = A;
	A = [HL++];
	VV[0x3B] = A;
	return;
}
/* always returns 0 */
void func_26B0(void)
{
	if (!(VV[0x38] & 0x80)) {
		HL += 3;
		[0x9963] = DE;
		return;
	}
	if (!(B & 0x40)) {
		[0x9963] = HL;
		HL += 3;
		return;
	}
	if (B & 0x80)
		A += 0x03;
	A <<= 1;
	A += 0x03;
	EA = HL;
	EA += A;
	HL = EA;
	func_26A6(); /* always returns 0 */
	[0x9963] = DE;
	return;
}

/* always returns 0 */
void func_26DB(void)
{
	push(HL);
	HL = [0x9963];
	DE = 0xC001;
	C = 0x02;
	31                 BLOCK   
	HL = pop();
	return;
}

26E8: 00                 NOP     
26E9: 00                 NOP     
	00                 NOP     
	1F                 MOV     L,A

/* always returns 0 */
void func_26EC(void)
{
	if (VV[0x39] & 0x40)
		goto 2723;
	if (VV[0x10] & 0x40)
		HL = EA;
	EA = 0x99ED;
	func_26F8(); /* always returns 0 */
	return 0;
}
/* always returns 0 */
void func_26F8(void)
{
	[0xC000] = 0x00;
	if (B & 0x80) {
		C = 0x01;
		if (!(VV[0x38] & 0x02))
			C = 0x02;
		DE = 0xC001;
		31                 BLOCK   
	}
	DE = EA;
	C = VV[0x3b];
	EA = 0x0000;
	do {
		[DE++] = [C000];
		[DE++] = [HL++];
		if (VV[0x38] & 0x02)
			[DE++] = EA;
	} while (C--);
	return 0;
}

2723:
	push(BC);
	push(EA);
	EA = 0x9965;
	func_26F8(); /* always returns 0 */
	HL = pop();
	BC = pop();
	EA = 0x99ED;
	func_26F8(); /* always returns 0 */
	HL = 0x9965;
	DE = 0x99ED;
	70 6B 3B 98        MOV     C,($983B)
	55 38 02           OFFIW   VV:38,$02
	48 27              SLL     C
	5E 10              BIT     6,VV:10
	goto 27B8
	goto 277D
2748:
	push(BC);
	B = 0x00;
	HL++;
	C = [DE + 0x01];
	A = [HL++];
	if (A & 0x40 || C & 0x80) B |= 0x80;
	if (A & 0x20 || C & 0x20) B |= 0x40;
	if (A & 0x08 || C & 0x10) B |= 0x20;
	if (C & 0x04            ) B |= 0x10;
	if (A & 0x01            ) B |= 0x08;
	A = [DE];
	if (A & 0x80            ) B |= 0x04;
	func_27BC(); /* always returns 0 */
	BC = pop();
277D:
	53                 DCR     C
	goto 2748
	return 0;
2781:
	push(BC);
	B = 0x00;
	A = [HL++];
	if (A & 0x80            ) B |= 0x04;
	A = [DE + 0x01];
	C = A;
	A = [HL++];
	if (A & 0x80            ) B |= 0x80;
	if (C & 0x40            ) B |= 0x40;
	if (A & 0x10            ) B |= 0x20;
	if (A & 0x04 || C & 0x08) B |= 0x10;
	if (A & 0x02 || C & 0x02) B |= 0x08;
	if (C & 0x01            ) B |= 0x04;
	func_27BC(); /* always returns 0 */
	BC = pop();
27B8:
	53                 DCR     C
	goto 2781
	return 0;

/* always returns 0 */
void func_27BC(void)
{
	EA = 0x0000;
	A = B;
	EAH = A;
	if (!(VV[0x39] & 0x40)) /* 0010 0000 */
		EA >>= 3;
	[DE++] = EA;
	return 0;
}

27C9:
	if (VV[0x40] & 0x80 || VV[0x39] & 0x40 || !(VV[0x39] & 0x02) || VV[0x10] & 0x10 || !(VV[0x10] & 0x40))
		goto 27DA;
	goto 284F;
27DA:
	DE = 0x9965;
	B = 0x00;
	40 E8 27           CALL    $27E8
	40 03 28           CALL    $2803
	return 0;
	VV[0x3B] = A;
27E8:
	goto 27FF
27E9:
	A = B;
	A ^= 0xff;
	70 8D              ANAX    (HL+)
	70 6B 00 C0        MOV     C,($C000)
	74 5B 80           OFFI    C,$80
	goto 27FF
	B = A;
	9B                 CALT    ($00B6)
	59 39              BIT     1,VV:39
	goto 27FF
	A = 0x00;
	B = A;
	9B                 CALT    ($00B6)
27FF:
	30 3B              DCRW    VV:3B
	goto 27E9
	return 0;

2803:
	5E 07              BIT     6,VV:07
	5B 39              BIT     3,VV:39
	return 0;
	A = 0x01;
	55 39 04           OFFIW   VV:39,$04
	A += 2;
	47 80              ONI     A,$80
	67 00              NEI     A,$00
	return 0;
	HL--;
	HL--;
	HL--;
	return 1;

2818:
	func_26EC(); /* always returns 0 */
	func_26DB(); /* always returns 0 */
	DE = 0x9965;
	A = VV[0x3C];
	51                 DCR     A
	func_2AEA(); /* always returns 0 */
	HL = 0x99ED;
	A = VV[0x3B];
	48 25              SLL     A
	55 38 02           OFFIW   VV:38,$02
	VV[0x3B] = A;
	BC = [0xFFFF];
	while (VV[0x3b]--) {
		48 85              LDEAX   (HL++)
		70 69 00 C0        MOV     A,($C000)
		if (A & 0x80)
			continue;
		EA &= BC;
		[DE++] = EA;
		BC = [0xFFFF];
		EA ^= BC;
		BC = EA;
	}
	return 0;
284F:
	DE = 0x99ED;
	C = [0x983B];
	53                 DCR     C
	31                 BLOCK   
	40 03 28           CALL    $2803
	goto 2864;
	C = A;
	A += VV[0x3B];
	VV[0x3B] = A;
	53                 DCR     C
	31                 BLOCK   
2864:
	HL = 0x99ED;
	DE = [0x9965];
	EA = 0x0000;
	30 3B              DCRW    VV:3B
286F:
	A = [HL++];
	B = A;
	70 6B 00 C0        MOV     C,($C000)
	74 4B 80           ONI     C,$80
	goto 2889
	30 3B              DCRW    VV:3B
	goto 286F
	return 0;
287D:
	40 65 29           CALL    $2965
	40 09 29           CALL    $2909
	9B                 CALT    ($00B6)
	EAH = A;
	A = B;
	EAL = A;
	A = C;
	B = A;
2889:
	if (VV[0x3b] != 0x00)
		goto 2890;
	C = 0x00;
	goto 289D
2890:
	A = [HL++];
	C = [C000];
	74 4B 80           ONI     C,$80
	goto 289C
	30 3B              DCRW    VV:3B
	goto 2889
289C:
	C = A;
289D:
	40 58 29           CALL    $2958
	40 09 29           CALL    $2909
	9B                 CALT    ($00B6)
	EAH = A;
	30 3B              DCRW    VV:3B
	goto 287D
	return 0;

/* always returns 0 */
void func_28BC(void)
{
	while (A--) {
		EA = [HL++];
		push(EA);
		EA |= BC;
		[DE++] = EA;
		if (VV[0x38] & 0x08) {
			if (!(VV[0x38] & 0x04))
				EA = 0x0000;
			[DE++] = EA;
		}
		BC = pop();
	}
	return 0;
}
/* always returns 1 */
void func_28BF(void)
{
	if (++A)
		[0x9957] = BC;
	EA = BC;
28C5:
	push(EA);
	EA = [HL++];
	push(EA);
	EA |= BC;
	if (!(VV[0x38] & 0x08))
		goto 28E1;
	BC = [0x9957];
	push(BC);
	BC = EA;
	[0x9957] = BC;
	BC = pop();
	EA |= BC;
	[DE++] = EA;
	EA = 0x0000;
	goto 28EC
28E1:
	push(EA);
	BC = 0xFFFF;
	EA = [HL];
	EA ^= BC;
	BC = pop();
	EA &= BC;
28EC:
	[DE++] = EA;
	EA = pop();
	BC = pop();
	51                 DCR     A
	goto 28C5
	return 1;
}

28F4: 40 11 29           CALL    $2911
28F7: EA = 0x0000;
28FA: EAH = A;
28FB: 55 40 02           OFFIW   VV:40,$02
28FE: 48 A0              DSLR    EA
2900: 55 39 40           OFFIW   VV:39,$40
2903: 40 25 29           CALL    $2925
2906: [DE++] = EA;
2908: return 0;
2909: 5C 39              BIT     4,VV:39
290B: return 0;
290C: 57 02              OFFI    A,$02
290E: A |= 0x01;
2910: return 0;
2911: 55 10 10           OFFIW   VV:10,$10
2914: 5C 39              BIT     4,VV:39
2916: return 0;
2917: 55 40 80           OFFIW   VV:40,$80
291A: goto 2922
291B: 47 01              ONI     A,$01
291D: A = 0x00;
291F: A = 0x0F;
2921: return 0;
2922: A &= 0x0f;
2924: return 0;
2925: push(BC);
2926: C = 0x00;
2928: 55 10 40           OFFIW   VV:10,$40
292B: 48 A4              DSLL    EA
292D: A = EAH;
292E: 57 80              OFFI    A,$80
2930: C |= 0x80;
2933: 57 20              OFFI    A,$20
2935: C |= 0x40;
2938: 57 08              OFFI    A,$08
293A: C |= 0x20;
293D: 57 02              OFFI    A,$02
293F: C |= 0x10;
2942: 55 10 40           OFFIW   VV:10,$40
2945: goto 294C
2946: A = EAL;
2947: 57 80              OFFI    A,$80
2949: C |= 0x08;
294C: EA = 0x0000;
294F: A = C;
2950: EAH = A;
2951: 5D 39              BIT     5,VV:39
2953: EA >>= 4;
2956: BC = pop();
2957: return 0;
2958: push(DE);
2959: push(HL);
295A: func_298C(); /* always returns 0 */
295D: func_29B8(); /* always returns 0 */
2960: 60 9C              ORA     A,D
2962: HL = pop();
2963: DE = pop();
2964: return 0;
2965: push(DE);
2966: push(HL);
2967: A = B;
2968: func_29B8(); /* always returns 0 */
296B: D = A
296C: A = C;
296D: A &= 0x7f;
296F: A = [HL+A];
2970: 74 4B 80           ONI     C,$80
2973: A &= 0x7f;
2975: D |= A;
2977: 74 14 FF           XRI     D,$FF
297A: A = B;
297B: 48 25              SLL     A
297D: 60 8B              ANA     A,C
297F: 1E                 MOV     H,A
2980: A = C;
2981: 48 25              SLL     A
2983: 60 8A              ANA     A,B
2985: 60 9E              ORA     A,H
2987: 60 8C              ANA     A,D
2989: HL = pop();
298A: DE = pop();
298B: return 0;

/* always returns 0 */
void func_298C(void)
{
	A = EAL;
	48 25              SLL     A
	60 8B              ANA     A,C
	D = A;
	A = EAL;
	E = A;
	A = C;
	48 25              SLL     A
	60 8D              ANA     A,E
	D |= A;
	A = B;
	48 25              SLL     A
	A |= B;
	E = A;
	push(BC);
	HL = 0x2A52;
	A = EAL;
	func_29C4(); /* always returns 0 */
	E |= A;
	A = C;
	func_29C4(); /* always returns 0 */
	A |= E;
	A ^= 0xff;
	60 0C              ANA     D,A
	BC = pop();
	A = B;
	return;
}
/* always returns 0 */
void func_29B8(void)
{
	HL = 0x29D2;
	A &= 0x7f;
	A = [HL+A];
	if (!(B & 0x80))
		A &= 0x7f; /* 0111 1111 */
	return;
}
/* always returns 0 */
void func_29C4(void)
{
	if (A == 0x7c)
		A = 0xfc;
	B = A;
	A &= 0x7f;
	A = [HL+A];
	if (!(B & 0x80))
		A &= 0xbf; /* 1011 1111 */
	return;
}

29D2: DW: 00 00 00 02 00 00 04 06 00 00 00 02 08 08 0C 0E
29E2: DW: 00 00 00 02 00 00 04 06 10 10 10 12 18 18 1C 1E
29F2: DW: 00 00 00 02 00 00 04 06 00 00 00 02 08 08 0C 0E
2A02: DW: 20 20 20 22 20 20 24 26 30 30 30 32 38 38 3C 3E
2A12: DW: 80 80 80 82 80 80 84 86 80 80 80 82 88 88 8C 8E
2A22: DW: 80 80 80 82 80 80 84 86 90 90 90 92 98 98 9C 9E
2A32: DW: C0 C0 C0 C2 C0 C0 C4 C6 C0 C0 C0 C2 C8 C8 CC CE
2A42: DW: E0 E0 E0 E2 E0 E0 E4 E6 F0 F0 F0 F2 F8 F8 FC FE

2A52: DW: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04
2A62: DW: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 08 0C
2A72: DW: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04
2A82: DW: 00 00 00 00 00 00 00 00 00 00 00 00 18 10 18 1C
2A92: DW: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04
2AA2: DW: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 08 0C
2AB2: DW: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 04
2AC2: DW: 40 40 40 40 40 40 40 40 60 60 60 60 78 70 78 7C

2AD2: 55 07 40           OFFIW   VV:07,$40
2AD5: goto 2ADD
2AD6: 45 09 06           ONIW    VV:09,$06
2AD9: A = 0x06;
2ADB: A = 0x0C;
2ADD: A = 0x00;
2ADF: 40 97 24           CALL    $2497
	VV[0x38] &= 0xef;
2AE5: 40 A0 23           CALL    $23A0
2AE8: 00                 NOP     
2AE9: return 0;

void func_2AEA(void)
{
	EA = 0x0000;
	do {
		B = [C000];
		if (!(B & 0x80))
			[DE++] = EA;
	} while (A--);
	return 0;
}

2AFA: 40 8F 2E           CALL    $2E8F
2AFD: A = 0x20;
2AFF: A = 0x00;
2B01: B = A;
2B02: 70 6B 4F 98        MOV     C,($984F)
2B06: push(BC);
2B07: 90                 CALT    ($00A0)
2B08: A = 0x00;
2B0A: A = 0x10;
2B0C: BC = pop();
2B0D: A |= B;
2B0F: B = A;
2B10: 60 93              XRA     A,C
2B12: 47 30              ONI     A,$30
2B14: goto 2B2D
2B15: 74 0B 4F           ANI     C,$4F
2B18: A = B;
2B19: 60 9B              ORA     A,C
2B1B: VV[0x4F] = A;
2B1D: BC = [0x0000];
2B20: 70 1E 4B 98        SBCD    $984B
2B24: 5D 4F              BIT     5,VV:4F
2B26: goto 2B2D
2B27: 5C 4F              BIT     4,VV:4F
2B29: VV[0x14] |= 0x02
2B2C: goto 2B33
2B2D: 55 4F 10           OFFIW   VV:4F,$10
2B30: VV[0x14] |= 0x02
2B33: 40 BF 32           CALL    $32BF
2B36: A = 0x05;
2B38: 70 79 07 C0        MOV     ($C007),A
2B3C: PC |= 0x04; /* 0000 0100 */
2B3F: delay(30);
2B42: PC &= 0xfb; /* 1111 1011 */
2B45: delay(25);
2B48: 5C 4F              BIT     4,VV:4F
2B4A: 55 4F 20           OFFIW   VV:4F,$20
2B4D: A = 0x0C;
2B4F: A = 0x24;
2B51: 40 12 30           CALL    $3012
2B54: 40 1C 30           CALL    $301C
2B57: VV[0x13] |= 0x02
2B5A: VV[0x2C] = 0x24;
2B5D: BC = [0x0000];
2B60: 70 1E 2B 99        SBCD    $992B
2B64: VV[0x26] = 0x00;
2B67: return 0;
2B68: A = VV[0x26];
2B6A: 67 00              NEI     A,$00
2B6C: return 0;
2B6D: goto 2BA0
2B6F: 40 EC 32           CALL    $32EC
2B72: goto 2D79;
2B75: 40 F3 32           CALL    $32F3
2B78: EA = [HL];
2B7A: HL = [0x992B];
2B7E: EA -= HL;
2B80: BC = EA;
2B81: goto 2B88
2B82: 70 6B 2C 98        MOV     C,($982C)
2B86: B = 0x00;
2B88: push(BC);
2B89: 55 14 40           OFFIW   VV:14,$40
2B8C: 40 13 2C           CALL    $2C13
2B8F: 40 B0 31           CALL    $31B0
2B92: BC = pop();
2B93: 40 B8 2B           CALL    $2BB8
2B96: A = VV[0x26];
2B98: A5                 DMOV    EA,BC
2B99: 70 61              ESUB    EA,A
2B9B: 48 0A              SK      CY
2B9D: goto 2BB2
2B9E: 60 E3              SUB     A,C
2BA0: A += 0x0c;
2BA2: 5D 4F              BIT     5,VV:4F
2BA4: A += 0x18;
2BA6: C = A;
2BA7: B = 0x80;
2BA9: 91                 CALT    ($00A2)
2BAA: EA = [0x000C];
2BAD: 5D 4F              BIT     5,VV:4F
2BAF: EA = [0x0024];
2BB2: BC = EA;
2BB3: 91                 CALT    ($00A2)
2BB4: VV[0x26] = 0x00;
2BB7: return 0;
2BB8: VV[0x03] &= 0xFE;
2BBB: 40 F3 32           CALL    $32F3
2BBE: EA = [HL];
2BC0: DE = EA;
2BC1: HL = 0x992B;
2BC4: EA = [HL];
2BC6: 74 C5              DADD    EA,BC
2BC8: 74 BE              DLT     EA,DE
2BCA: goto 2BD9
2BCB: 55 4F 20           OFFIW   VV:4F,$20
2BCE: goto 2BFE
2BD0: HL = [0x992F];
2BD4: 74 BF              DLT     EA,HL
2BD6: goto 2BF4
2BD7: goto 2BFE
2BD9: VV[0x13] &= 0xFD;
2BDC: push(HL);
2BDD: HL = 0x0000;
2BE0: [0x9A75] = HL;
2BE4: HL = pop();
	if (!func_32E5())
		goto 2BF0;
2BE9: HL = pop();
2BEA: VV[0x26] = 0x00;
2BED: goto 2D7D;
2BF0: EA -= DE;
2BF2: goto 2BC8
2BF4: HL = EA;
2BF5: EA = DE;
2BF6: EA -= HL;
2BF8: 74 C5              DADD    EA,BC
2BFA: BC = EA;
2BFB: EA = 0x0000;
2BFE: HL = 0x992B;
2C01: [HL] = EA;
2C03: HL = 0x984B;
2C06: EA = [HL];
2C08: 74 C5              DADD    EA,BC
2C0A: A = EAH;
2C0B: 57 C0              OFFI    A,$C0
2C0D: EA = [0x3FFF];
2C10: [HL] = EA;
2C12: return 0;

2C13:
	40 08 2E           CALL    $2E08
	goto 2C27
	40 EC 32           CALL    $32EC
	goto 2D47;
	55 01 04           OFFIW   VV:01,$04
	goto 2C27
	40 7D 2D           CALL    $2D7D
	goto 2D07;
2C27:
	VV[0x14] &= 0xFD;
	return 0;

2C2B:
	40 CF 32           CALL    $32CF
	5E 14              BIT     6,VV:14
	return 0;
	40 4E 10           CALL    $104E
	goto 0EC2;
2C37: 40 CF 32           CALL    $32CF
	40 4B 2E           CALL    $2E4B
	00                 NOP     
	90                 CALT    ($00A0)
	goto 2C4C
	VV[0x13] |= 0x04
	55 13 20           OFFIW   VV:13,$20
	40 C4 32           CALL    $32C4
	VV[0x13] &= 0xDF;
2C4C:
	BC = [0x0FE4];
	99                 CALT    ($00B2)
	40 79 2C           CALL    $2C79
	BC = [0x0FEB];
	99                 CALT    ($00B2)
	40 A4 2C           CALL    $2CA4
	BC = [0x0FF2];
	99                 CALT    ($00B2)
	40 B2 2C           CALL    $2CB2
	goto 32B9;

2C64:
	59 14              BIT     1,VV:14
	goto 2C6D
	5D 4F              BIT     5,VV:4F
	return 0;
	90                 CALT    ($00A0)
	return 0;
	return 1;

2C6D:
	5A 13              BIT     2,VV:13
	return 1;
	90                 CALT    ($00A0)
	return 0;
	5D 4F              BIT     5,VV:4F
	40 08 2E           CALL    $2E08
	return 1;
	return 0;

2C79:
	40 64 2C           CALL    $2C64
	goto 2CD0
	VV[0x13] &= 0xFB;
	VV[0x13] |= 0x01
2C84:
	40 82 2B           CALL    $2B82
	40 7E 30           CALL    $307E
2C8A:
	40 E4 0F           CALL    $0FE4
	return 0;
	BC = [0x990F];
	EA = [0x0006];
	74 AD              DGT     EA,BC
	goto 2C8A
	40 E5 32           CALL    $32E5
	goto 2C84
	59 14              BIT     1,VV:14
	40 08 2E           CALL    $2E08
	goto 2C84
	goto 2D7D

2CA4:
	40 EC 32           CALL    $32EC
	goto 2CB2
	40 64 2C           CALL    $2C64
	goto 2CB5
	VV[0x13] &= 0xFB;
	goto 2B6F;

2CB2:
	55 14 02           OFFIW   VV:14,$02
2CB5:
	goto 2CD0
	5A 13              BIT     2,VV:13
	goto 2CBE
	90                 CALT    ($00A0)
	goto 2CD0
	5D 4F              BIT     5,VV:4F
	goto 2CDA
2CBE:
	goto 2D79

2CC0:
	5D 13              BIT     5,VV:13
	goto 2CCC
	40 EC 32           CALL    $32EC
	goto 2D79
	VV[0x13] &= 0xDF;
	return 0;
2CCC:
	40 08 2E           CALL    $2E08
	return 0;
2CD0:
	40 EC 32           CALL    $32EC
	goto 2D47
	55 4F 20           OFFIW   VV:4F,$20
	goto 2D5B
2CDA:
	90                 CALT    ($00A0)
	40 91 2D           CALL    $2D91
	90                 CALT    ($00A0)
	goto 2D03
	BC = [0x02D0];
	59 14              BIT     1,VV:14
	40 6F 2D           CALL    $2D6F
	91                 CALT    ($00A2)
	BC = [0x02AC];
	40 D2 2E           CALL    $2ED2
	goto 2D07
	40 D0 31           CALL    $31D0
	BC = [0x80B2];
	91                 CALT    ($00A2)
	BC = [0x9847];
	EA = [0x0042];
	74 C5              DADD    EA,BC
2D01: BC = EA;
	91                 CALT    ($00A2)
2D03:
	40 25 2D           CALL    $2D25
	goto 2D1C

2D07:
	40 C4 32           CALL    $32C4
	59 14              BIT     1,VV:14
	goto 2DA5
	55 14 40           OFFIW   VV:14,$40
	VV[0x13] |= 0x40
	5E 14              BIT     6,VV:14
	VV[0x13] |= 0x80
	goto 2C2B;

2D1C: VV[0x13] &= 0x3B;
2D1F: 5D 4F              BIT     5,VV:4F
2D21: VV[0x14] |= 0x10
2D24: return 0;
2D25: 40 B9 32           CALL    $32B9
2D28: VV[0x14] &= 0xFD;
2D2B: 90                 CALT    ($00A0)
2D2C: goto 2D2E
2D2D: return 1;
2D2E: BC = [0x0000];
2D31: 70 1E 2B 99        SBCD    $992B
2D35: 70 1E 29 99        SBCD    $9929
2D39: 70 1E 4B 98        SBCD    $984B
2D3D: VV[0x26] = 0x00;
2D40: VV[0x13] &= 0xFD;
2D43: VV[0x14] &= 0xFD;
2D46: return 0;
2D47: 59 14              BIT     1,VV:14
2D49: 40 79 2D           CALL    $2D79
2D4C: 90                 CALT    ($00A0)
2D4D: goto 2D5B
2D4E: BC = [0x8AB6];
2D51: 91                 CALT    ($00A2)
2D52: BC = [0x01DE];
2D55: 40 D2 2E           CALL    $2ED2
2D58: goto 2D07
2D5A: goto 2D5F
2D5B: 90                 CALT    ($00A0)
2D5C: goto 2D5F
2D5D: goto 2D07
2D5F: 40 D0 31           CALL    $31D0
2D62: BC = [0x9843];
2D66: EA = [0x0181];
2D69: 74 C5              DADD    EA,BC
2D6B: BC = EA;
2D6C: 91                 CALT    ($00A2)
2D6D: goto 2D03
2D6F: BC = [0x04AE];
2D72: 40 E5 32           CALL    $32E5
2D75: BC = [0x0393];
2D78: return 0;
2D79: 5D 4F              BIT     5,VV:4F
2D7B: goto 2D91
2D7D: 40 08 2E           CALL    $2E08
2D80: 40 D0 31           CALL    $31D0
	BC = 0x2520; /* '% ' */
	if (!func_32E5())
		BC = 0x0BD0;
2D8C: 91                 CALT    ($00A2)
2D8D: 40 6F 2D           CALL    $2D6F
2D90: goto 2D9E
2D91: 90                 CALT    ($00A0)
2D92: goto 2D94
2D93: goto 2D7D
2D94: 40 D0 31           CALL    $31D0
2D97: BC = [0x8D80];
2D9A: 91                 CALT    ($00A2)
2D9B: BC = [0x0070];
2D9E: 40 AE 2E           CALL    $2EAE
2DA1: goto 2DAE
2DA2: VV[0x14] &= 0xEF;
2DA5: VV[0x13] &= 0xDF;
2DA8: VV[0x14] |= 0x02
2DAB: goto 32BF;
2DAE: VV[0x13] |= 0x20
2DB1: 40 E5 32           CALL    $32E5
2DB4: goto 2DBC
2DB5: 40 25 2D           CALL    $2D25
2DB8: VV[0x13] |= 0x02
2DBB: goto 2DC2
2DBC: 40 B9 32           CALL    $32B9
2DBF: 40 C5 2D           CALL    $2DC5
2DC2: goto 2C2B;
2DC5: 5D 4F              BIT     5,VV:4F
2DC7: goto 2DE4
2DC8: EA = [0x0BD0];
2DCB: HL = [0x992B];
2DCF: EA += HL;
2DD1: A = VV[0x26];
2DD3: EA += A;
2DD5: HL = [0x992D];
2DD9: 74 BF              DLT     EA,HL
2DDB: goto 2DDE
2DDC: goto 2DFF
2DDE: EA -= HL;
2DE0: 74 BF              DLT     EA,HL
2DE2: goto 2DDE
2DE3: goto 2DFF
2DE4: HL = [0x992B];
2DE8: EA = HL;
2DE9: A = VV[0x26];
2DEB: EA += A;
2DED: HL = 0x0D80;
	int borrow = (EA >= HL);
	EA -= HL;
	if (!borrow)
		goto 2DF4;
2DF3: goto 2DFF
2DF4: HL = [0x9931];
2DF8: DE = [0x0000];
2DFB: 74 A7              DADDNC  EA,HL
2DFD: goto 2DFF
2DFE: goto 2DFB
2DFF: HL = EA;
2E00: [0x992B] = HL;
2E04: VV[0x26] = 0x00;
2E07: return 0;

2E08:
	disable_interrupts();
	DE = [9929];
	HL = [990F];
	enable_interrupts();
	EA = 0x0000;
	74 FF              DEQ     EA,HL
	goto 2E21;
	EA = DE;
	A = VV[0x26];
	70 61              ESUB    EA,A
	48 1A              SKN     CY
	return 0;
	goto 2E28;
2E21:
	EA = DE;
	5F 01              BIT     7,VV:01
	goto 2E2F
	int borrow = (EA >= HL);
	EA -= HL;
	if (!borrow)
		return 0;
2E28:
	DE = [0x0142];
	74 AE              DGT     EA,DE
	return 0;
	return 1;
2E2F:
	EA += HL;
	DE = [0x0142];
	74 AE              DGT     EA,DE
	return 0;
	func_2089();
	goto 2E08;
2E3A:
	40 C8 0F           CALL    $0FC8
	goto 2E41
2E3E:
	A, B = read_stable_PA();
2E41:
	VV[0x4F] |= 0x10
	47 02              ONI     A,$02
	return 1;
	VV[0x4F] &= 0xEF;
	return 0;

2E4B:
	40 8F 2E           CALL    $2E8F
	goto 2E68
	55 4F 20           OFFIW   VV:4F,$20
	goto 2E60
	5A 13              BIT     2,VV:13
	return 1;
	90                 CALT    ($00A0)
	goto 2E59
	return 1;
2E59:
	81                 CALT    ($0082)
	goto 2E4B
2E5B:
	81                 CALT    ($0082)
	40 8F 2E           CALL    $2E8F
	return 1;
2E60:
	40 7D 2E           CALL    $2E7D
	goto 2E5B
	VV[0x4F] &= 0xDF;
	goto 2E7A
2E68:
	55 4F 20           OFFIW   VV:4F,$20
	return 1;
	goto 2E73
2E6D:
	81                 CALT    ($0082)
	40 8F 2E           CALL    $2E8F
	goto 2E73
	return 1;
2E73:
	40 7D 2E           CALL    $2E7D
	goto 2E6D
	VV[0x4F] |= 0x20
2E7A:
	goto 32BF;
2E7D:
	40 08 2E           CALL    $2E08
2E80:
	goto 2E82
	return 1;
2E82:
	BC = [0x9929];
	EA = 0x0000;
	74 FD              DEQ     EA,BC
	return 0;
	90                 CALT    ($00A0)
	return 0;
	return 1;

2E8F:
	40 9F 2E           CALL    $2E9F
	goto 2E97
	5D 4F              BIT     5,VV:4F
	return 1;
	goto 2E9B
2E97:
	55 4F 20           OFFIW   VV:4F,$20
	return 0;
2E9B:
	40 C8 0F           CALL    $0FC8
	goto 2EA2
2E9F:
	A, B = read_stable_PA();
2EA2:
	57 04              OFFI    A,$04
	return 0;
	return 1;

2EA6:
	A = C;
	A += VV[0x26];
	VV[0x26] = A;
	91                 CALT    ($00A2)
	return 0;
2EAE:
	func_2089(); /* always returns 0 */
	HL = 0x990F;
	EA = [HL];
	DE = [0x0000];
	74 AE              DGT     EA,DE
	return 0;
	5C 4F              BIT     4,VV:4F
	goto 2EAE
	DE = EA;
2EBE:
	EA = [HL];
	74 EE              DNE     EA,DE
	goto 2EBE
	5C 4F              BIT     4,VV:4F
	goto 2EAE
	HL = [0x990F];
	[0x9A77] = HL;
	40 F0 2E           CALL    $2EF0
	return 1;
2ED2:
	func_2089(); /* always returns 0 */
2ED3: HL = 0x990F;
2ED6: EA = [HL];
2ED8: DE = [0x0000];
2EDB: 74 AE              DGT     EA,DE
2EDD: return 0;
2EDE: 55 4F 10           OFFIW   VV:4F,$10
2EE1: goto 2ED2
2EE2: DE = EA;
2EE3: EA = [HL];
2EE5: 74 EE              DNE     EA,DE
2EE7: goto 2EE3
2EE8: 55 4F 10           OFFIW   VV:4F,$10
2EEB: goto 2ED2
2EEC: 40 F0 2E           CALL    $2EF0
2EEF: return 1;
2EF0: disable_interrupts();
2EF1: 55 01 10           OFFIW   VV:01,$10
2EF4: 55 01 22           OFFIW   VV:01,$22
2EF7: goto 2EFE
2EF8: 70 1E 0F 99        SBCD    $990F
2EFC: enable_interrupts();
2EFD: return 0;
2EFE: enable_interrupts();
2EFF: 40 B9 32           CALL    $32B9
2F02: 55 01 80           OFFIW   VV:01,$80
2F05: B |= 0x80;
2F08: 91                 CALT    ($00A2)
2F09: return 0;
2F0A: 59 13              BIT     1,VV:13
2F0C: 55 03 02           OFFIW   VV:03,$02
2F0F: return 1;
2F10: 5C 13              BIT     4,VV:13
2F12: goto 2F1A
2F13: 40 67 30           CALL    $3067
2F16: 40 B3 2F           CALL    $2FB3
2F19: goto 2F34
2F1A: 45 0F C0           ONIW    VV:0F,$C0
2F1D: 55 01 30           OFFIW   VV:01,$30
2F20: return 1;
2F21: 40 EC 32           CALL    $32EC
2F24: 59 14              BIT     1,VV:14
2F26: 55 13 02           OFFIW   VV:13,$02
2F29: return 1;
2F2A: EA = 0x0000;
2F2D: BC = [0x992B];
2F31: 74 FD              DEQ     EA,BC
2F33: return 1;
2F34: 5C 13              BIT     4,VV:13
2F36: 55 4F 80           OFFIW   VV:4F,$80
2F39: goto 2F43
2F3A: 40 EC 32           CALL    $32EC
2F3D: goto 2F52
2F3E: 55 01 04           OFFIW   VV:01,$04
2F41: goto 2F52
2F42: goto 2F4C
2F43: BC = [0x9A75];
2F47: EA = [0x03FF];
2F4A: 74 ED              DNE     EA,BC
2F4C: 40 3E 2E           CALL    $2E3E
2F4F: goto 2F52
2F50: goto 2FAA
2F52: BC = [0x9A75];
2F56: 12                 INX     BC
2F57: EA = [0x03FF];
2F5A: 74 BD              DLT     EA,BC
2F5C: 40 1B 21           CALL    $211B
2F5F: BC = [0x0000];
2F62: 40 10 22           CALL    $2210
2F65: BC = [0x0000];
2F68: 70 1E 75 9A        SBCD    $9A75
2F6C: EA = 0x0000;
2F6F: 74 ED              DNE     EA,BC
2F71: return 1;
2F72: 55 13 10           OFFIW   VV:13,$10
2F75: return 1;
2F76: EA = 0x0000;
2F79: BC = [0x984B];
2F7D: 5F 4F              BIT     7,VV:4F
2F7F: 74 ED              DNE     EA,BC
2F81: goto 2F96
2F82: 5D 4F              BIT     5,VV:4F
2F84: 55 14 01           OFFIW   VV:14,$01
2F87: return 1;
2F88: BC = [0x9A75];
2F8C: EA = [0x03FF];
2F8F: 74 FD              DEQ     EA,BC
2F91: return 1;
2F92: 40 C8 2F           CALL    $2FC8
2F95: goto 2FAA
2F96: BC = [0xC805];
2F99: push(BC);
2F9A: delay(C);
2F9B: 40 03 10           CALL    $1003
2F9E: goto 2FA8
2F9F: BC = pop();
2FA0: 52                 DCR     B
2FA1: goto 2F99
2FA2: VV[0x13] |= 0x10
2FA5: 81                 CALT    ($0082)
2FA6: 88                 CALT    ($0090)
2FA7: return 1;
2FA8: BC = pop();
2FA9: return 1;
2FAA: VV[0x4F] &= 0x7F;
2FAD: VV[0x13] &= 0xEF;
2FB0: goto 32BF;
2FB3: BC = [0x9A75];
2FB7: EA = [0x03FF];
2FBA: 74 FD              DEQ     EA,BC
2FBC: return 0;
2FBD: 70 69 04 C0        MOV     A,($C004)
2FC1: 16 10              XRI     A,$10
2FC3: 70 79 04 C0        MOV     ($C004),A
2FC7: return 0;
2FC8: 40 B9 32           CALL    $32B9
2FCB: 90                 CALT    ($00A0)
2FCC: goto 2FCE
2FCD: return 0;
2FCE: EA = [0x0268];
2FD1: BC = [0x9849];
2FD5: 74 C5              DADD    EA,BC
2FD7: BC = [0x9847];
2FDB: EA -= BC;
2FDD: BC = EA;
2FDE: 91                 CALT    ($00A2)
2FDF: 40 B9 32           CALL    $32B9
2FE2: 90                 CALT    ($00A0)
2FE3: goto 2FE5
2FE4: return 0;
2FE5: VV[0x4F] |= 0x80
2FE8: return 1;
2FE9: 55 4F 80           OFFIW   VV:4F,$80
2FEC: 40 1C 30           CALL    $301C
2FEF: 5C 13              BIT     4,VV:13
2FF1: return 0;
2FF2: VV[0x13] &= 0xEF;
2FF5: BC = [0x0000];
2FF8: 70 1E 75 9A        SBCD    $9A75
2FFC: 70 69 04 C0        MOV     A,($C004)
3000: A |= 0x10;
3002: 70 79 04 C0        MOV     ($C004),A
3006: 5B 13              BIT     3,VV:13
3008: return 0;
3009: VV[0x13] &= 0xF7;
300C: 5D 4F              BIT     5,VV:4F
300E: A = 0x24;
3010: A = 0x0C;
3012: C = A;
3013: push(BC);
3014: B = 0x80;
3016: 91                 CALT    ($00A2)
3017: BC = pop();
3018: B = 0x00;
301A: 91                 CALT    ($00A2)
301B: return 0;
301C: 5F 4F              BIT     7,VV:4F
301E: return 0;
301F: 40 D0 31           CALL    $31D0
3022: EA = [0x028C];
3025: BC = [0x9849];
3029: 74 C5              DADD    EA,BC
302B: BC = [0x9847];
302F: EA -= BC;
3031: BC = EA;
3032: B |= 0x80;
3035: 91                 CALT    ($00A2)
3036: VV[0x4F] &= 0x7F;
3039: BC = [0x0024];
303C: 91                 CALT    ($00A2)
303D: 40 B9 32           CALL    $32B9
3040: BC = [0x0000];
3043: 70 1E 4B 98        SBCD    $984B
3047: VV[0x14] &= 0xEF;
304A: VV[0x13] |= 0x02
304D: return 0;
304E: 5C 14              BIT     4,VV:14
3050: return 0;
3051: VV[0x14] &= 0xEF;
3054: 40 F3 32           CALL    $32F3
3057: EA = [HL];
3059: HL = [0x984B];
305D: HL++;
305E: 5D 4F              BIT     5,VV:4F
3060: 74 BF              DLT     EA,HL
3062: return 0;
3063: A = 0x24;
3065: goto 3012
3067: VV[0x13] |= 0x01
306A: 40 E4 0F           CALL    $0FE4
306D: goto 3072
306E: 40 D1 30           CALL    $30D1
3071: goto 3077
3072: 87                 CALT    ($008E)
3073: return 0;
3074: 40 9C 30           CALL    $309C
3077: 40 B9 32           CALL    $32B9
307A: 40 7E 30           CALL    $307E
307D: goto 306A
307E: 58 13              BIT     0,VV:13
3080: return 0;
3081: 40 B9 32           CALL    $32B9
3084: BC = [0x8702];
3087: push(BC);
3088: 80                 CALT    ($0080)
3089: A, B = read_stable_PA();
308C: BC = pop();
308D: 07 C0              ANI     A,$C0
308F: 67 C0              NEI     A,$C0
3091: goto 3098
3092: 52                 DCR     B
3093: goto 3087
3094: VV[0x13] &= 0xFE;
3097: return 0;
3098: VV[0x13] |= 0x01
309B: return 0;
309C: EA = 0x0000;
309F: HL = [0x984B];
30A3: 74 FF              DEQ     EA,HL
30A5: goto 30C2
30A7: HL = [0x9847];
30AB: 55 4F 20           OFFIW   VV:4F,$20
30AE: HL = [0x9843];
30B2: EA = [0x01B0];
30B5: 74 FF              DEQ     EA,HL
30B7: goto 30BC
30B8: 81                 CALT    ($0082)
30B9: 87                 CALT    ($008E)
30BA: return 0;
30BB: goto 30B8
30BC: 5D 4F              BIT     5,VV:4F
30BE: goto 3120
30C0: goto 3123
30C2: HL = [0x9849];
30C6: EA = [0x006C];
30C9: 74 FF              DEQ     EA,HL
30CB: goto 3126
30CD: 81                 CALT    ($0082)
30CE: 87                 CALT    ($008E)
30CF: return 0;
30D0: goto 30CD
30D1: EA = 0x0000;
30D4: HL = [0x984B];
30D8: 74 FF              DEQ     EA,HL
30DA: goto 30F9
30DC: HL = [0x9847];
30E0: 55 4F 20           OFFIW   VV:4F,$20
30E3: HL = [0x9843];
30E7: EA = [0xFFFC];
30EA: 74 FF              DEQ     EA,HL
30EC: goto 30F3
30ED: 81                 CALT    ($0082)
30EE: 40 E4 0F           CALL    $0FE4
30F1: return 0;
30F2: goto 30ED
30F3: 5D 4F              BIT     5,VV:4F
30F5: goto 310A
30F7: goto 310D
30F9: HL = [0x9849];
30FD: EA = [0xFF94];
3100: 74 FF              DEQ     EA,HL
3102: goto 3110
3104: 81                 CALT    ($0082)
3105: 40 E4 0F           CALL    $0FE4
3108: return 0;
3109: goto 3104
310A: HL = 0x9847;
310D: HL = 0x9843;
3110: HL = 0x9849;
3113: 5F 4F              BIT     7,VV:4F
3115: VV[0x13] |= 0x08
3118: EA = [HL];
311A: A9                 DCX     EA
311B: A9                 DCX     EA
311C: BC = [0x8002];
311F: goto 3130
3120: HL = 0x9847;
3123: HL = 0x9843;
3126: HL = 0x9849;
3129: EA = [HL];
312B: EA++;
312C: EA++;
312D: BC = 0x0002;
3130: [HL] = EA;
3132: push(EA);
3133: 91                 CALT    ($00A2)
3134: EA = pop();
3135: HL = 0x0000;
3138: 74 FF              DEQ     EA,HL
313A: return 0;
313B: 81                 CALT    ($0082)
313C: goto 1026;

313F:
	EA = 0x7FFF;
	if (!(EA & BC))
		return 0;
	disable_interrupts();
	if (VV[0x01] & 0x80)
		goto 3160;
	if (B & 0x80)
		goto 3160;
	if (VV[0x01] & 0x22)
		goto 3160;
	if (!(VV[0x01] & 0x10))
		goto 3160;
	if (!(VV[0x01] & 0x08))
		goto 3160;
	HL = 0x990F;
	EA = [HL];
	74 C5              DADD    EA,BC
	[HL] = EA;
	enable_interrupts();
	return 0;
3160:
	enable_interrupts();
	push(BC);
3162:
	func_2089(); /* always returns 0 */
	59 0F              BIT     1,VV:0F
	55 01 30           OFFIW   VV:01,$30
	goto 3162
	40 B0 31           CALL    $31B0
	BC = pop();
	VV[0x01] |= 0x90
	if (!(B & 0x80))
		VV[0x01] &= 0x7F;
	B &= 0x7f;
	[0x990f] = BC;
	EA = 0x000A;
	74 BD              DLT     EA,BC
	goto 3189
	VV[0x01] |= 0x48
	A = 0x0B;
	goto 318E
3189:
	VV[0x01] &= 0xB5;
	A = 0x02;
318E:
	VV[0x27] = A;
	PC  |= 0x04; /* 0000 0100 */
	ETMM = 0x04; /* 0000 0100 */ /*  */
	disable_interrupts();
	ETM0 = ECNT + 100;
	[0x981B] = 0x31F5;
	IRR &= ~FE0; /* clear FE0 */
	MKL &= 0xdf; /* 1101 1111 */ /* activate INTE0 */
	enable_interrupts();
	return 0;

31B0:
	BC = [0x984B];
	HL = 0x9843;
	5D 4F              BIT     5,VV:4F
	HL = 0x9847;
	EA = [HL];
	74 C5              DADD    EA,BC
	BC = EA;
	74 5A 80           OFFI    B,$80
	goto 31D0
	EA = 0x0168;
	5D 4F              BIT     5,VV:4F
	EA = 0x01D4;
	74 AD              DGT     EA,BC
	return 0;
31D0:
	5D 4F              BIT     5,VV:4F
	goto 7885;
	goto 7882;
31D8:
	BC = [0x984B];
	HL = 0x9843;
	5D 4F              BIT     5,VV:4F
	HL = 0x9847;
	EA = [HL];
	74 C5              DADD    EA,BC
	BC = EA;
	EA = [0x0168];
	5D 4F              BIT     5,VV:4F
	EA = [0x01D4];
	74 AD              DGT     EA,BC
	return 1;
	return 0;
31F5:
	11                 EXX     
	10                 EXA     
	push(EA);
	push(VA);
	push(BC);
	push(HL);
	48 C0              DMOV    EA,ECNT
	push(EA);
	5D 01              BIT     5,VV:01
	goto 3214
	enable_interrupts();
	64 4A 04           ONI     PC,$04
	goto 320B
	PC &= 0xfb; /* 1111 1011 */
	goto 325A
320B:
	MKL |= 0x20; /* 0010 0000 */ /* mask INTE0 */
	VV[0x01] &= 0xDF;
	EA = pop();
	goto 326A
3214:
	40 6F 32           CALL    $326F
	enable_interrupts();
	40 3E 2E           CALL    $2E3E
	goto 322F
	HL = [0x9929];
	74 5E 80           OFFI    H,$80
	HL = 0x7FFF;
	HL++;
	5F 01              BIT     7,VV:01
	goto 3232;
	HL--;
	HL--;
	74 5E 80           OFFI    H,$80
322F:
	HL = 0x0000;
3232:
	[0x9929] = HL;
	HL = 0x990F;
	[HL]--;
	BC = [0x0000];
	74 FD              DEQ     EA,BC
	goto 3246
	VV[0x01] |= 0x20
	VV[0x01] &= 0xED;
3246:
	5B 01              BIT     3,VV:01
	goto 3257
	BC = [0x0004];
	74 ED              DNE     EA,BC
	VV[0x01] |= 0x02
	65 27 06           NEIW    VV:27,$06
	VV[0x01] &= 0xBF;
3257:
	55 01 62           OFFIW   VV:01,$62
325A:
	30 27              DCRW    VV:27
	A = VV[0x27];
	48 25              SLL     A
	HL = 0x32A3;
	48 8C              LDEAX   (HL+A)
	HL = pop();
	EA += HL;
	ETM0 = EA;
326A:
	HL = pop();
	BC = pop();
	VA = pop();
	EA = pop();
	return; /* FROM INTERRUPT */

326F:
void func_326F(void)
{
	if (VV[0x01] & 0x80) HL = 0x3289;
	else                 HL = 0x3293;
	A = [HL+[C007]];
	[C007] = A;
	[C007] = [HL+A];
	return;
}

3289: DW: 09 05 0A 09 06 04 02 09 09 01 08 09 06 09 05 01
3269: DW: 04 09 0A 08 02 09 09 09 09 09 F4 77 F9 47 A7 0F
32A9: DW: 95 0C 0C 0B 47 0A E5 09 47 0A 0C 0B 95 0C A7 0F

32B9:
	45 01 30           ONIW    VV:01,$30
	return 0;
	func_2089(); /* always returns 0 */
	goto 32B9;
32BF:
	40 B9 32           CALL    $32B9
	90                 CALT    ($00A0)
	goto 32C7;
32C4:
	HL = 0x0166;
32C7:
	HL = 0x0000;
	[0x9929] = HL;
32CE:
	return 0;

32CF:
void func_32CF(void)
{
	40 08 2E           CALL    $2E08
	goto 32E1;
	90                 CALT    ($00A0)
	goto 32E1;
	if (func_32EC())
		goto 32DD;
	if (VV[0x13] & 0xc0)
		goto 32E1;
32DD:
	[0xC004] |= 0x40;
	return;
32E1:
	[0xC004] &= 0xBF;
	return;
}

32E5:
int func_32E5(void)
{
	if (VV[0x4f] & 0x20)
		return 0;
	if (VV[0x02] & 0x20)
		return 1;
	return 0;
}

32EC:
int func_32EC(void)
{
	if (VV[0x4f] & 0x20)
		return 1;
	if (VV[0x02] & 0x20)
		return 0;
	return 1;
}

32F3:
void func_32F3(void)
{
	if (!(VV[0x02] & 0x20)) HL = 0x992D;
	else                    HL = 0x984D;
	if (!(VV[0x4f] & 0x20))
		HL = 0x9931;
	return;
}

/* FUCKING IMPORTANT THIS IS 0x3555!!! */
3301: 3555 359a 35d9 3620 3667 36a2 36d1 3722
3311: 374b 378e 3806 3882 38d1 392a 3982 39c7
3321: 3a0c 3a4f 3aca 3b1d 3b6c 3bb7 3bf6 3c2d
3331: 3c85 3d05 3d70 3db5 3dfc 3e43 3e8e 3ecd
3341: 3f38 3f45 3f68 3f99 3fe0 4029 40a3 4123
3351: 4150 4181 41b2 41f9 423c 4269 42a8 42cf
3361: 431a 4361 439c 43e3 442c 446d 44b4 44fd
3371: 4564 45ab 45f2 4619 4646 4685 46c4 4703
3381: 4748 4797 4806 484b 4898 48dd 4920 4965
3391: 49b2 49f9 4a30 4a7b 4aec 4b37 4b86 4bf5
33a1: 4c40 4c8d 4ce0 4d2f 4d70 4db3 4e1e 4e6e
33b1: 4ee9 4f60 4fd7 5016 504b 5096 50cb 50fe
33c1: 510c 5137 517c 51c5 5204 5251 5290 52d1
33d1: 531a 5361 539c 53d9 5444 547f 54c8 550d
33e1: 5554 559f 55ea 562b 566a 56a9 56f0 5768
33f1: 57e3 585a 58dc 5923 5960 5985 59c0 5a0b

3401: 5a52 3dfc 3e8e 5aa3 3d70 3555 3982 39c7
3411: 5b01 5b50 359a 5b8f 5bca 3667 3c2d 392a
3421: 3e43 3b1d 3aca 5c0d 3db5 3620 5c54 35d9
3431: 5c9b 3c85 3d05 5d1d 36d1 3ecd 38d1 5d62
3441: 5dab 5df0 5e2b 5e72 3806 378e 5eb9 5efe
3451: 374b 5f45 5f86 5fc5 6050 3722 60db 6126
3461: 6171 617f 618d 619b 61a9 61b7 61c5 61d3
3471: 61e1 61ef 61fd 620b 6219 6227 6235 6243
3481: 6251 625f 626d 627b 6289 6297 62a5 62b3
3491: 62c1 62cf 62dd 62eb 62f9 6307 6315 6323
34a1: 6331 633f 634d 635b 6369 6377 6385 6393
34b1: 63a1 63af 63bd 63cb 63d9 63e7 63f5 6403
34c1: 6411 3a4f 6456 649b 64de 6525 6576 65c1
34d1: 6604 664f 6696 66e9 6728 677f 67cd 680a
34e1: 6851 6890 68db 691e 6961 6977 698d 69d0
34f1: 36a2 6a17 6a46 6a71 6ab4 6af3 6b32 3f38
3501: 6b65 6ba0 6bdf 6c56 6cae 6d25 6d64 6db8
3511: 6e38 6e75 6eba 6f06 6f51 6f9c 6fd7 700e
3521: 7045 707c 70b3 7107 715a 71ae 71f5 7249
3531: 7294 72d9 734c 73bf 7432 74b4 7533 757a
3541: 75a5 75ec 7639 76c8 771b 774a 777d

77B1:
	stepper_vref(0x07);
	[0xc008] = 0x00;
	[0xc00b] = 0x00;
	[0xc00a] = 0xba;
	[0xc009] = 0xb5;
	[0xc008] = 0x0d;
	if (read_debounced_PA() & 0x01) [0x991D] = 0x7B76;
	else                            [0x991D] = 0x7B66;
	stepper_vref(0x06);
	VV[0x1d] = 0x03;
	delay(25);
77E8:
	func_7845();
	30 1D              DCRW    VV:1D
	goto 77E8;
	stepper_vref(0x07);
	delay(75);
	VV[0x00] |= 0x80;
	if (read_debounced_PA() & 0x01) {
		[0x9917] = 0x03E3;
		func_7875();
	}
	[0x9917] = 0x0000;
	func_7882();
	VV[0x00] &= 0x7f;
	[0x991D] = 0x7B76;
	stepper_vref(0x06);
	delay(6);
	VV[0x1d] = 0x14;
7823:
	func_7845();
	96                 CALT    ($00AC)
	goto 782C;
	55 00 02           OFFIW   VV:00,$02
	goto 7831;
782C:
	30 1D              DCRW    VV:1D
	goto 7823
	goto 7864
7831:
	func_7845();
	func_7845();
	stepper_vref(0x07);
	delay(75)
	HL = 0x0003;
	[0x9917] = HL;
	return 0;

7845:
	VV[0x00] |= 0x02;
	94                 CALT    ($00A8)
	delay(3);
	96                 CALT    ($00AC)
	VV[0x00] &= 0xfd;
	return 0;

uint8_t func_7851(void)
{
	A = [C008];
	HL = 0x7860;
	for (int i = 0; i < 5; i++)
		if (A == [HL++])
			return 0;
	return 1;
}

7860: DW: 0C 0D 0E 0F /* should be 5 bytes? */

7864:
	HL = 0x104A;
7867:
	HL = 0x1047;
	push(HL);
	40 48 0C           CALL    $0C48
	40 9A 0C           CALL    $0C9A
	BC = pop();
	48 29              CALB    
7874: goto 7874

7875:
DE = [9917];
EA = 0x000a;
if (DE <= EA)
	return;

787F: HL = 000A;
7882: HL = 010D;
7885: HL = 00D1;
7888: DE = [9917];
788C: EA = HL;
788D: 74 EE              DNE     EA,DE
788F: 54 A4 7B           JMP     $func_7ba4
7892: push(HL);
7893: 93                 CALT    ($00A6)	func_7ba4();
7894: HL = pop();
7895: 5F 00              BIT     7,VV:00
7897: A = 0x03;
7899: A = 0x01;
789B: VV[0x1F] = A;
789D: push(HL);
789E: DE = [9917];
78A2: EA = HL;
78A3: VV[0x00] &= 0xBF;
	int borrow = (EA >= DE);
	EA -= DE;
	if (!borrow)
		goto 78AA;
78A9: goto 78B0
78AA: VV[0x00] |= 0x40
78AD: EA = DE;
78AE: EA -= HL;
78B0: HL = 0x001E;
78B3: 74 BF              DLT     EA,HL
78B5: goto 78BF
78B6: EA = [0x001E];
78B9: A = VV[0x00];
78BB: 16 40              XRI     A,$40
78BD: VV[0x00] = A;
78BF: HL = 0x9949;
78C2: [HL] = EA;
78C4: 95                 CALT    ($00AA)
78C5: 5F 00              BIT     7,VV:00
78C7: VV[0x00] |= 0x01
78CA: HL = pop();
78CB: 5F 00              BIT     7,VV:00
78CD: goto 7888
78CF: 54 A4 7B           JMP     $func_7ba4

78D2: VV[0x00] |= 0x10
78D5: 58 00              BIT     0,VV:00
78D7: goto 78DF
func_7bb1();
78DB: VV[0x00] &= 0xFE;
78DE: goto 78E0
78DF: 93                 CALT    ($00A6)	func_7ba4();
78E0: VV[0x1F] = 0x03;
78E3: func_1F75();
78E6: HL = 0x990B;
78E9: DE = [0x9919];
78EC: 48 85              LDEAX   (HL++)
78EE: BC = [0x02B8];
78F1: 74 C5              DADD    EA,BC
78F3: 5A 00              BIT     2,VV:00
78F5: goto 78F9
78F6: 70 61              ESUB    EA,A
78F8: goto 78FB
78F9: EA += A;
78FB: B = 0x18;
78FD: 48 3E              DIV     B
78FF: [DE++] = EA;
7901: EA = [HL];
7903: BC = [0x02B8];
7906: 74 C5              DADD    EA,BC
7908: 5A 00              BIT     2,VV:00
790A: goto 790E
790B: 70 61              ESUB    EA,A
790D: goto 7910
790E: EA += A;
7910: A = 0x18;
7912: 48 3D              DIV     A
7914: 77 00              EQI     A,$00
7916: EA++;
7917: [DE] = EA;
7919: 40 FB 7B           CALL    $7BFB
791C: EA = DE;
	int borrow = (EA >= BC);
	EA -= BC;
	if (!borrow)
		goto 7940;
7921: VV[0x00] |= 0x40
7924: HL = 0x000F;
	int borrow = (EA >= HL);
	EA -= HL;
	if (!borrow)
		goto 7949;
792B: HL = 0x001E;
792E: 75 20 03           EQIW    VV:20,$03
7931: 74 B7              DSUBNB  EA,HL
7933: goto 795E
7935: EA = DE;
7936: EA -= BC;
7938: A = 0x0F;
793A: 70 61              ESUB    EA,A
793C: VV[0x00] &= 0xBF;
793F: goto 7957
7940: HL = 0x0010;
7943: A5                 DMOV    EA,BC
7944: EA -= DE;
7946: 74 BF              DLT     EA,HL
7948: goto 7950
7949: EA = [0x001E];
794C: VV[0x00] |= 0x40
794F: goto 7957
7950: A = 0x0F;
7952: EA += A;
7954: VV[0x00] |= 0x40
7957: HL = 0x9949;
795A: [HL] = EA;
795C: 95                 CALT    ($00AA)
795D: 93                 CALT    ($00A6)	func_7ba4();
795E: func_1F9F();
7961: goto 795E
7962: 40 FB 7B           CALL    $7BFB
7965: A = 0x11;
7967: EA = HL;
7968: EA -= BC;
796A: EA += A;
796C: HL = EA;
796D: [0x9949] = HL;
7971: VV[0x0F] |= 0x02
7974: EA = DE;
7975: EA -= BC;
7977: A9                 DCX     EA
7978: HL = EA;
7979: [0x994B] = HL;
797D: A = VV[0x20];
797F: VV[0x1F] = A;
7981: VV[0x00] &= 0xBF;
7984: 95                 CALT    ($00AA)
7985: VV[0x00] &= 0xEF;
	ETMM = 0x04; /* 0000 0100 */ /*  */
798C: return 0;
798D: 40 BE 7B           CALL    $7BBE
7990: 55 00 10           OFFIW   VV:00,$10
7993: 5A 00              BIT     2,VV:00
7995: goto 799C
7996: A = VV[0x00];
7998: 16 40              XRI     A,$40
799A: VV[0x00] = A;
799C: 5E 00              BIT     6,VV:00
799E: HL = 0x7B66;
79A1: HL = 0x7B76;
79A4: [991D] = HL;
79A8: A = VV[0x1F];
79AA: 48 25              SLL     A
79AC: 48 A8              TABLE   
79AE: goto 79B9
[7C6E]
[7C7E]
[7C9C]
[7CAC]
[7CBC]
79B9: 70 1E 1F 99        SBCD    $991F
79BD: VV[0x0F] |= 0x90
79C0: 40 1F 7C           CALL    $7C1F
79C3: 65 1F 04           NEIW    VV:1F,$04
79C6: goto 79CB
79C7: 75 1F 01           EQIW    VV:1F,$01
79CA: goto 79E2
79CB: VV[0x00] |= 0x20
79CE: HL = 0x9949;
79D1: EA = [HL];
79D3: 48 A4              DSLL    EA
79D5: [HL] = EA;
79D7: HL = 0x994B;
79DA: EA = [HL];
79DC: 48 A4              DSLL    EA
79DE: [HL] = EA;
79E0: A = 0x1C;
79E2: A = 0x0E;
79E4: VV[0x1D] = A;
79E6: stepper_vref(0x05);
79E9: 64 9D E0           ORI     TMM,$E0
79EC: HL = 0x7A04;
79EF: [0x9818] = HL;
79F3: VV[0x0F] |= 0x01
79F6: A = 0xE6;
79F8: TM1 = A;
79FA: 48 42              SKIT    FT1
79FC: 00                 NOP     
79FD: 64 8D 3F           ANI     TMM,$3F
7A00: MKL &= 0xfb; /* 1111 1011 */ /* activate INTT1 */
7A03: return 0;

7A04:
	48 C0              DMOV    EA,ECNT
	HL = EA;
	[0x9921] = HL;
	40 34 7A           CALL    $7A34
	goto 7A16;
	40 16 0C           CALL    $0C16
	11                 EXX     
	10                 EXA     
	enable_interrupts();
	return; /* FROM INTERRUPT */

7A16:
	94                 CALT    ($00A8)
	11                 EXX     
	10                 EXA     
	enable_interrupts();
	push(VA);
	push(EA);
	push(BC);
	push(DE);
	push(HL);
	A = VV[0x1D];
	HL = [991F];
	A = [HL+A];
	TM1 = A;
	40 C4 7A           CALL    $7AC4
	40 99 7A           CALL    $7A99
	HL = pop();
	DE = pop();
	BC = pop();
	EA = pop();
	VA = pop();
	return; /* FROM INTERRUPT */

7A34:
	if (!(VV[0x0f] & 0x41))
		return 0;
	if (!(VV[0x0f] & 0x01))
		goto 7A50
	VV[0x0f] &= 0xfe;
	5E 0F              BIT     6,VV:0F
	goto 7A4C
	stepper_vref(0x07);
	A = 0xc0;
	TM1 = A;
	VV[0x1e] = 0x0e;
	return 1;
7A4C:
	stepper_vref(0x06);
	return 0;
7A50:
	30 1E              DCRW    VV:1E
	return 1;
	VV[0x0f] &= 0xbf;
	40 F7 0B           CALL    $0BF7
	return 1;

7A5A:
	94                 CALT    ($00A8)
	11                 EXX     
	10                 EXA     
	enable_interrupts();
	[9949]--;
	return; /* FROM INTERRUPT */

7A6A: VV[0x0F] &= 0xCF;
7A6D: VV[0x0F] |= 0x08
7A70: A = VV[0x1F];
7A72: 48 25              SLL     A
7A74: 48 A8              TABLE   
7A76: goto 7A81
[7C6F]
[7C7F]
[7C9D]
[7CAD]
[7CBD]
7A81: 70 1E 1F 99        SBCD    $991F
7A85: HL = 0x7A04;
7A88: [0x9818] = HL;
7A8C: 55 00 80           OFFIW   VV:00,$80
7A8F: 5E 00              BIT     6,VV:00
7A91: return 0;
7A92: 25 1D 13           GTIW    VV:1D,$13
7A95: VV[0x1D] = 0x13;
7A98: return 0;
7A99: 55 0F 69           OFFIW   VV:0F,$69
7A9C: return 0;
7A9D: 40 1D 7B           CALL    $7B1D
7AA0: return 0;
7AA1: 55 00 80           OFFIW   VV:00,$80
7AA4: goto 7AB9
7AA5: 55 0F 10           OFFIW   VV:0F,$10
7AA8: return 0;
7AA9: 96                 CALT    ($00AC)
7AAA: goto 7AB5
7AAB: 55 00 02           OFFIW   VV:00,$02
7AAE: goto 7864;
7AB1: VV[0x00] |= 0x02
7AB4: return 0;
7AB5: VV[0x00] &= 0xFD;
7AB8: return 0;
7AB9: 5E 00              BIT     6,VV:00
7ABB: goto 7AC0
7ABC: 96                 CALT    ($00AC)
7ABD: return 0;
7ABE: goto 7A6A
7AC0: 96                 CALT    ($00AC)
7AC1: goto 7A6A
7AC3: return 0;
7AC4: 45 0F 18           ONIW    VV:0F,$18
7AC7: return 0;
7AC8: 5C 0F              BIT     4,VV:0F
7ACA: goto 7AF7
7ACC: 65 1F 04           NEIW    VV:1F,$04
7ACF: goto 7AD4
7AD0: 75 1F 01           EQIW    VV:1F,$01
7AD3: goto 7ADA
7AD4: 65 1D 0E           NEIW    VV:1D,$0E
7AD7: stepper_vref(0x05);
7ADA: 30 1D              DCRW    VV:1D
7ADC: 75 1D 00           EQIW    VV:1D,$00
7ADF: return 0;
7AE0: 65 1F 04           NEIW    VV:1F,$04
7AE3: goto 7AE8
7AE4: 75 1F 01           EQIW    VV:1F,$01
7AE7: goto 7AEC
7AE8: stepper_vref(0x03);
7AEB: goto 7AEF
7AEC: stepper_vref(0x05);
7AEF: VV[0x0F] &= 0xEF;
7AF2: 5D 0F              BIT     5,VV:0F
7AF4: return 0;
7AF5: goto 7A6A
7AF7: 20 1D              INRW    VV:1D
7AF9: 5D 00              BIT     5,VV:00
7AFB: A = 0x0F;
7AFD: A = 0x1D;
7AFF: 74 F8 1D           EQAW    VV:1D
7B02: return 0;
7B03: 55 00 80           OFFIW   VV:00,$80
7B06: A = func_7851();
7B09: goto 7B13
7B0A: 30 1D              DCRW    VV:1D
7B0C: 70 69 9A 7C        MOV     A,($7C9A)
7B10: TM1 = A;
7B12: return 0;
7B13: VV[0x0F] |= 0x41
7B16: VV[0x0F] &= 0x77;
7B19: VV[0x00] &= 0xDF;
7B1C: return 0;
7B1D: HL = 0x9949;
7B20: [HL]--;
7B21: 5F 00              BIT     7,VV:00
7B23: C9                 JR      7B2D
	HL = 0x0000;
	if (EA != HL)
		return 1;
	goto 7864;
7B2D:
	if (VV[0x0f] & 0x08)
		return 1;
	5D 00              BIT     5,VV:00
	HL = 0x000F;
	HL = 0x001D;
	74 AF              DGT     EA,HL
	goto 7A6A;
	59 0F              BIT     1,VV:0F
	return 1;
	HL = 0x994B;
	[HL]--;
	DE = 0x0000;
	74 EE              DNE     EA,DE
	goto 1E8F;
	return 1;

7B4D:
	HL = [991D];
	A  = [C008];
	if (!(VV[0x00] & 0x20)) {
		A = [HL + A];
		[C008] = A;
	}
	A = [HL + A];
	[C008] = A;
	goto 0C16;

7B66: DW: 0D 0D 0D 0D 0D 0F 0C 0D 0D 0D 0D 0E 08 05 06 0B
7B76: DW: 0D 0D 0D 0D 0D 0D 0E 0D 0C 0D 0D 0F 06 08 0B 05

void read_debounced_PA(void)
{
	do {
		A = read_stable_PA();
		delay(10);
		B = read_stable_PA();
	} while (A != B);
	if (!(A&0x01))
		skip next on return;
}
7b95:
void read_debounced_PA(void)
{
	A = read_stable_PA();
	if (!(A&0x01))
		skip next on return;
}

/* THIS SEEMS TO BE THE MAIN LOOP FOR NOW */
void func_7ba4(void)
{
	while (VV[0x00] & 0x10) {
		if (VV[0x0f] & 0xc0)
			func_1F9F(); /* ignore rets, there's a nop after this */
		func_2089(); /* always returns 0 */
	}
}

void func_7bb1(void)
{
	while (VV[0x0f] & 0xc0 || VV[0x01] & 0x30) {
		if (VV[0x00] & 0x10)
			func_1F9F(); /* ignore rets, there's a nop after this */
		func_2089(); /* always returns 0 */
	}
}

7BB9:
	func_1F9F(); /* ignore rets, there's a nop after this */
	func_2089(); /* always returns 0 */
7BBE:
	func_7ba4();
59 0F              BIT     1,VV:0F
	return 0;
7BC2: 5C 01              BIT     4,VV:01
7BC4: 64 5A 04           OFFI    PC,$04
7BC7: goto 7BB9
	disable_interrupts();
7BC9: 00                 NOP     
7BCA: 5D 01              BIT     5,VV:01
7BCC: goto 7BD3
7BCD: MKL |= 0x20; /* 0010 0000 */ /* mask INTE0 */
7BD0: VV[0x01] &= 0xDF;
7BD3:
	enable_interrupts();
	return 0;
7BD5: VV[0x00] &= 0xFB;
7BD8: 55 00 08           OFFIW   VV:00,$08
7BDB:
	return 0;
7BDC: HL = 0x990B;
7BDF: 48 85              LDEAX   (HL++)
7BE1: BC = EA;
7BE2: EA = [HL];
7BE4: DE = EA;
7BE5: 74 C5              DADD    EA,BC
7BE7: 48 A0              DSLR    EA
7BE9: A = 0x18;
7BEB: 48 3D              DIV     A
7BED: A = 0x1D;
7BEF: EA += A;
7BF1: HL = [0x9917];
7BF5: 74 B7              DSUBNB  EA,HL
7BF7: VV[0x00] |= 0x04
	return 0;
7BFB: HL = 0x9917;
7BFE: 48 85              LDEAX   (HL++)
7C00: BC = EA;
7C01: 48 85              LDEAX   (HL++)
7C03: DE = EA;
7C04: EA = [HL];
7C06: HL = EA;
7C07: 5A 00              BIT     2,VV:00
	return 0;
7C0A: EA = 0x0363;
7C0D: EA -= BC;
7C0F: BC = EA;
7C10: EA = 0x0363;
7C13: EA -= HL;
7C15: push(EA);
7C16: EA = 0x0363;
7C19: EA -= DE;
7C1B: HL = EA;
7C1C: EA = pop();
7C1D: DE = EA;
7C1E: return 0;
7C1F: HL = 0x9917;
7C22: EA = [HL];
7C24: BC = [0x9949];
7C28: 5E 00              BIT     6,VV:00
7C2A: goto 7C43
7C2B: EA -= BC;
7C2D: DE = [0x0029];
7C30: 74 BE              DLT     EA,DE
7C32: goto 7C5B
7C34: DE = [0x000A];
7C37: EA -= DE;
7C39: 74 C5              DADD    EA,BC
7C3B: BC = EA;
7C3C: 70 1E 49 99        SBCD    $9949
7C40: EA = DE;
7C41: goto 7C5B
7C43: 74 C5              DADD    EA,BC
7C45: DE = [0x01F4];
7C48: 74 AE              DGT     EA,DE
7C4A: goto 7C5B
7C4B: DE = EA;
7C4C: EA = [0x0213];
7C4F: EA -= DE;
7C51: 74 C5              DADD    EA,BC
7C53: BC = EA;
7C54: 70 1E 49 99        SBCD    $9949
7C58: EA = [0x0213];
7C5B: [HL] = EA;
7C5D: return 0;

void stepper_vref(int v)
{
	/* v from 0 to 7 */
	PA = v << 3;
	return;
}

7c6e  2b 2b 2b 2c 2d 2e 30 32  35 39 3f 47 52 62 8a e6  |+++,-.0259?GRb..|
7c7e  2b 2b 2b 2b 2b 2b 2b 2b  2b 2b 2b 2c 2c 2d 2e 2f  |+++++++++++,,-./|
7c8e  30 31 32 35 37 3a 3d 41  45 4d 59 6c 87 e6 1b 1b  |01257:=AEMYl....|
7c9e  1b 1c 1d 1f 21 23 26 2a  2f 35 3d 49 60 e6 20 20  |....!#&*/5=I`.  |
7cae  20 21 22 23 24 26 29 2d  31 38 40 4a 60 e6 20 20  | !"#$&)-18@J`.  |
7cbe  20 20 20 20 20 21 21 21  21 22 22 23 23 24 25 26  |     !!!!""##$%&|
7cce  27 28 2a 2d 30 35 3b 46  52 67 87 e6 8e 77 00     |'(*-05;FRg...w. |

7CDB:
	77 00              EQI     A,$00
	return 0;
	8E                 CALT    ($009C)
	C = A;
	push(BC);
	8E                 CALT    ($009C)
	BC = pop();
	B = A;
	8E                 CALT    ($009C)
	if (A == 0x00)
		goto 7D32;
	if (A == 0x01) {
		8E                 CALT    ($009C)
		if (A != 0xfe)
			return 0;
		8E                 CALT    ($009C)
		if (A != 0x80)
			return 0;
		A = VV[0x31] ^ 0xff;
		func_7D9B(); /* always returns 0 */
		A = VV[0x32] ^ 0xff;
		A &= 0x0f;
		func_7D9B(); /* always returns 0 */
		8B                 CALT    ($0096)
		return 0;
	}
	if (A == 0x03)
		goto 7D10;
	if (A == 0x04)
		goto 7CFA;
	return 0;
7CFA:
	8B                 CALT    ($0096)
	8E                 CALT    ($009C)
	77 FB              EQI     A,$FB
	return 0;
	8E                 CALT    ($009C)
	77 02              EQI     A,$02
	return 0;
	8E                 CALT    ($009C)
	C = A;
	B = 0x80;
	40 88 2B           CALL    $2B88
	A = 0x0C;
	40 12 30           CALL    $3012
	return 0;
7D10:
	40 FD 16           CALL    $16FD
	8E                 CALT    ($009C)
	77 FC              EQI     A,$FC
	return 0;
	8E                 CALT    ($009C)
	77 81              EQI     A,$81
	return 0;
	8E                 CALT    ($009C)
	37 03              LTI     A,$03
	return 0;
	VV[0x06] |= 0x80;
	if (A == 0x00)
		VV[0x06] &= 0x5F;
	if (A == 0x01)
		VV[0x06] |= 0x20;
	if (A == 0x02)
		VV[0x06] &= 0xdf;
	return 0;

7D32:
	8E                 CALT    ($009C)
	if (A != 0xff)
		return 0;
	8E                 CALT    ($009C)
	if (A != 0x00)
		return 0;
	8E                 CALT    ($009C)
	37 02              LTI     A,$02
	return 0;
	if (A != 0x00)
		A = 0x02;
	5D 06              BIT     5,VV:06
	if (++A)
		EA = 0x7D7C;
	EA += A;
	HL = EA;
	A = [HL];
	[9846] = A;
	EA = 0x0D21;
	EA += A;
	HL = EA;
	EA = 0x9850;
	EA += A;
	A = [HL];
	HL = EA;
	B  = A;
	push(HL);
	push(BC);
	8E                 CALT    ($009C)
	BC = pop();
	HL = pop();
	A += B;
	3B                 STAX    (HL)
	8E                 CALT    ($009C)
	return 0;
	40 C9 15           CALL    $15C9
	40 14 15           CALL    $1514
	40 2F 15           CALL    $152F
	goto 7D78;
	40 2B 15           CALL    $152B
	40 C9 15           CALL    $15C9
7D78:
	40 D6 04           CALL    $04D6
	return 0;

7D7C: DW: 03 00 04 01 00

/* always returns 0 */
void func_7D9B(void)
{
	40 59 0E           CALL    $0E59
	VV[0x15] = EAL;
	push(EA);
	40 CD 05           CALL    $05CD
	EA = pop();
	VV[0x15] = EAH;
	40 CD 05           CALL    $05CD
	return 0;
}
